pax_global_header                                                                                   0000666 0000000 0000000 00000000064 12563604362 0014521 g                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        52 comment=f1a27b480d0e1a23831c8b486a2542680e19b97e
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            moonlight-embedded-2.1.1/                                                                           0000775 0000000 0000000 00000000000 12563604362 0015251 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        moonlight-embedded-2.1.1/.gitmodules                                                                0000664 0000000 0000000 00000000166 12563604362 0017431 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        [submodule "common"]
	path = third_party/moonlight-common-c
	url = https://github.com/irtimmer/moonlight-common-c.git
                                                                                                                                                                                                                                                                                                                                                                                                          moonlight-embedded-2.1.1/CMakeLists.txt                                                             0000664 0000000 0000000 00000007603 12563604362 0020017 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        project(moonlight-embedded C)
cmake_minimum_required(VERSION 3.1)
SET(CMAKE_MODULE_PATH "${PROJECT_SOURCE_DIR}/cmake")
include(${CMAKE_ROOT}/Modules/GNUInstallDirs.cmake)

set(MOONLIGHT_MAJOR_VERSION 2)
set(MOONLIGHT_MINOR_VERSION 1)
set(MOONLIGHT_PATCH_VERSION 0)
set(MOONLIGHT_VERSION ${MOONLIGHT_MAJOR_VERSION}.${MOONLIGHT_MINOR_VERSION}.${MOONLIGHT_PATCH_VERSION})

aux_source_directory(./src SRC_LIST)
aux_source_directory(./src/input SRC_LIST)

set(MOONLIGHT_DEFINITIONS)

find_package(ALSA REQUIRED)
find_package(Opus REQUIRED)
find_package(Broadcom)
find_package(Freescale)
find_package(CEC 3.0)

find_package(PkgConfig REQUIRED)
pkg_check_modules(EVDEV REQUIRED libevdev)
pkg_check_modules(UDEV REQUIRED libudev)
pkg_check_modules(SDL sdl2>=2.0.4)
pkg_check_modules(AVCODEC libavcodec)
pkg_check_modules(AVUTIL libavutil)
pkg_check_modules(SWSCALE libswscale)

SET(SOFTWARE_FOUND AVCODEC_FOUND AND AVUTIL_FOUND AND SWSCALE_FOUND AND SDL_FOUND)
SET(MOONLIGHT_COMMON_INCLUDE_DIR ./third_party/moonlight-common-c)
SET(GAMESTREAM_INCLUDE_DIR ./libgamestream)

if(CMAKE_BUILD_TYPE MATCHES Debug)
  list(APPEND SRC_LIST ./src/video/fake.c)
  list(APPEND MOONLIGHT_DEFINITIONS HAVE_FAKE LC_DEBUG)
elseif(NOT BROADCOM_FOUND AND NOT FREESCALE_FOUND AND NOT ${SOFTWARE_FOUND})
  message(FATAL_ERROR "No video output available")
endif()

if (${SOFTWARE_FOUND})
  list(APPEND SRC_LIST ./src/video/ffmpeg.c ./src/video/sdl.c ./src/audio/sdl.c)
  list(APPEND MOONLIGHT_DEFINITIONS HAVE_SDL)
endif()

if (BROADCOM_FOUND OR FREESCALE_FOUND OR CMAKE_BUILD_TYPE MATCHES Debug)
  list(APPEND MOONLIGHT_DEFINITIONS HAVE_EMBEDDED)
endif()

list(APPEND SRC_LIST ./src/audio/alsa.c)

add_subdirectory(libgamestream)

add_executable(moonlight ${SRC_LIST})
target_link_libraries(moonlight gamestream)
set_property(TARGET moonlight PROPERTY C_STANDARD 99)

if (CEC_FOUND AND CEC_VERSION_COMPATIBLE)
  list(APPEND MOONLIGHT_DEFINITIONS HAVE_LIBCEC)
  target_include_directories(moonlight PRIVATE ./third_party/libcec ${CEC_INCLUDE_DIRS}/libcec)
  target_link_libraries(moonlight ${CEC_LIBRARIES})
endif()

if(BROADCOM_FOUND)
  list(APPEND MOONLIGHT_DEFINITIONS HAVE_PI)
  aux_source_directory(./third_party/ilclient ILCLIENT_SRC_LIST)
  add_library(moonlight-pi SHARED ./src/video/pi.c ${ILCLIENT_SRC_LIST})
  target_include_directories(moonlight-pi PRIVATE ./third_party/ilclient ${BROADCOM_INCLUDE_DIRS} ${GAMESTREAM_INCLUDE_DIR} ${MOONLIGHT_COMMON_INCLUDE_DIR})
  target_link_libraries(moonlight-pi gamestream ${BROADCOM_LIBRARIES})
  set_property(TARGET moonlight-pi PROPERTY COMPILE_DEFINITIONS ${BROADCOM_DEFINITIONS})
  install(TARGETS moonlight-pi DESTINATION ${CMAKE_INSTALL_LIBDIR})
endif()

if(FREESCALE_FOUND)
  list(APPEND MOONLIGHT_DEFINITIONS HAVE_IMX)
  add_library(moonlight-imx SHARED ./src/video/imx.c)
  target_include_directories(moonlight-imx PRIVATE ${FREESCALE_INCLUDE_DIRS} ${GAMESTREAM_INCLUDE_DIR} ${MOONLIGHT_COMMON_INCLUDE_DIR})
  target_link_libraries(moonlight-imx gamestream ${FREESCALE_LIBRARIES})
  install(TARGETS moonlight-imx DESTINATION ${CMAKE_INSTALL_LIBDIR})
endif()

if (${SOFTWARE_FOUND})
  target_include_directories(moonlight PRIVATE ${SDL_INCLUDE_DIRS} ${AVCODEC_INCLUDE_DIRS} ${AVUTIL_INCLUDE_DIRS} ${SWSCALE_INCLUDE_DIRS})
  target_link_libraries(moonlight ${SDL_LIBRARIES} ${AVCODEC_LIBRARIES} ${AVUTIL_LIBRARIES} ${SWSCALE_LIBRARIES})
endif()

set_property(TARGET moonlight PROPERTY COMPILE_DEFINITIONS ${MOONLIGHT_DEFINITIONS})
target_include_directories(moonlight PRIVATE ${GAMESTREAM_INCLUDE_DIR} ${MOONLIGHT_COMMON_INCLUDE_DIR} ${OPUS_INCLUDE_DIRS} ${EVDEV_INCLUDE_DIRS} ${UDEV_INCLUDE_DIRS})
target_link_libraries(moonlight ${EVDEV_LIBRARIES} ${ALSA_LIBRARY} ${OPUS_LIBRARY} ${UDEV_LIBRARIES} ${CMAKE_DL_LIBS})

add_subdirectory(docs)

install(TARGETS moonlight DESTINATION ${CMAKE_INSTALL_BINDIR})
install(DIRECTORY mappings DESTINATION ${CMAKE_INSTALL_DATADIR})
install(FILES moonlight.conf DESTINATION ${CMAKE_INSTALL_SYSCONFDIR})
                                                                                                                             moonlight-embedded-2.1.1/LICENSE                                                                    0000664 0000000 0000000 00000104513 12563604362 0016262 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                                            GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<http://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<http://www.gnu.org/philosophy/why-not-lgpl.html>.
                                                                                                                                                                                     moonlight-embedded-2.1.1/README.md                                                                  0000664 0000000 0000000 00000003776 12563604362 0016545 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Moonlight Embedded

Moonlight Embedded is an open source implementation of NVIDIA's GameStream, as used by the NVIDIA Shield, but built for Linux.

Moonlight Embedded allows you to stream your full collection of Steam games from
your powerful Windows desktop to your (embedded) Linux system, like Raspberry Pi, CuBox-i and Hummingboard.

## Documentation

More information about installing and runnning Moonlight Embedded is available on the [wiki](https://github.com/irtimmer/moonlight-embedded/wiki).

## Features

* Streams Steam and all of your games from your PC to your embedded system.
* Use mDNS to scan for compatible GeForce Experience (GFE) machines on the network.
* Qwerty Keyboard, Mouse and Gamepad support
* Support hardware video decoding on Raspberry Pi and i.MX 6 devices

## Requirements

* [GFE compatible](http://shield.nvidia.com/play-pc-games/) computer with GTX 600/700/900 series GPU (for the PC you're streaming from)
* High-end wireless router (802.11n dual-band recommended) or wired network
* Geforce Experience 2.1.1 or higher

## Quick Start

* Ensure your GFE server and client are on the same network
* Turn on Shield Streaming in the GFE settings
* Pair Moonlight Embedded with the GFE server
* Accept the pairing confirmation on your PC
* Connect to the GFE Server with Moonlight Embedded
* Play games!

## Bugs

Bugs can be reported to the [issue tracker](https://github.com/irtimmer/moonlight-embedded/issues).

## See also

[Moonlight-common-c](https://github.com/moonlight-stream/moonlight-common-c) is the shared codebase between
different C implementations of Moonlight

[Moonlight-common-c](https://github.com/irtimmer/moonlight-common-c) is the fork used by Moonlight Embedded

## Discussion

[XDA](http://forum.xda-developers.com/showthread.php?t=2505510)  
[Raspberry Pi Forum](http://www.raspberrypi.org/forums/viewtopic.php?f=78&t=65878)  
[SolidRun Community](http://www.solid-run.com/community/viewtopic.php?f=13&t=1489&p=11173)  

## Contribute

1. Fork us
2. Write code
3. Send Pull Requests
  moonlight-embedded-2.1.1/cmake/                                                                     0000775 0000000 0000000 00000000000 12563604362 0016331 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        moonlight-embedded-2.1.1/cmake/FindBroadcom.cmake                                                   0000664 0000000 0000000 00000002414 12563604362 0021663 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        find_path(BROADCOM_INCLUDE_DIR
  NAMES bcm_host.h
  DOC "Broadcom include directory"
  PATHS /opt/vc/include)
mark_as_advanced(BCM_INCLUDE_DIR)

find_library(VCOS_LIBRARY
  NAMES libvcos.so
  DOC "Path to VCOS Library"
  PATHS /opt/vc/lib)
mark_as_advanced(VCOS_LIBRARY)

find_library(VCHIQ_LIBRARY
  NAMES libvchiq_arm.so
  DOC "Path to VCHIQ Library"
  PATHS /opt/vc/lib)
mark_as_advanced(VCHIQ_LIBRARY)

find_library(OPENMAXIL_LIBRARY
  NAMES libopenmaxil.so
  DOC "Path to OpenMAX IL Library"
  PATHS /opt/vc/lib)
mark_as_advanced(OPENMAXIL_LIBRARY)

find_library(BCM_HOST_LIBRARY
  NAMES libbcm_host.so
  DOC "Path to Broadcom Host Library"
  PATHS /opt/vc/lib)
mark_as_advanced(BCM_HOST_LIBRARY)

include(${CMAKE_ROOT}/Modules/FindPackageHandleStandardArgs.cmake)
FIND_PACKAGE_HANDLE_STANDARD_ARGS(Broadcom DEFAULT_MSG BROADCOM_INCLUDE_DIR VCOS_LIBRARY VCHIQ_LIBRARY OPENMAXIL_LIBRARY BCM_HOST_LIBRARY)

set(BROADCOM_LIBRARIES ${BCM_HOST_LIBRARY} ${OPENMAXIL_LIBRARY} ${VCHIQ_LIBRARY} ${VCOS_LIBRARY})
set(BROADCOM_INCLUDE_DIRS ${BROADCOM_INCLUDE_DIR} ${BROADCOM_INCLUDE_DIR}/interface/vmcs_host/linux ${BROADCOM_INCLUDE_DIR}/interface/vcos/pthreads)
set(BROADCOM_DEFINITIONS USE_VCHIQ_ARM HAVE_LIBOPENMAX=2 OMX OMX_SKIP64BIT USE_EXTERNAL_OMX HAVE_LIBBCM_HOST USE_EXTERNAL_LIBBCM_HOST)
                                                                                                                                                                                                                                                    moonlight-embedded-2.1.1/cmake/FindCEC.cmake                                                        0000664 0000000 0000000 00000001057 12563604362 0020531 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # - Try to find CEC
# Once done this will define
#
# CEC_FOUND - system has libcec
# CEC_INCLUDE_DIRS - the libcec include directory
# CEC_LIBRARIES - The libcec libraries

if(PKG_CONFIG_FOUND)
  pkg_check_modules (CEC libcec>=3.0.0)
else()
  find_path(CEC_INCLUDE_DIRS libcec/cec.h)
  find_library(CEC_LIBRARIES cec)
endif()

include(FindPackageHandleStandardArgs)
find_package_handle_standard_args(CEC DEFAULT_MSG CEC_INCLUDE_DIRS CEC_LIBRARIES)

list(APPEND CEC_DEFINITIONS -DHAVE_LIBCEC=1)
mark_as_advanced(CEC_INCLUDE_DIRS CEC_LIBRARIES CEC_DEFINITIONS)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 moonlight-embedded-2.1.1/cmake/FindFreescale.cmake                                                  0000664 0000000 0000000 00000001365 12563604362 0022032 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        find_path(FREESCALE_INCLUDE_DIR
  NAMES vpu_lib.h
  DOC "Freescale include directory"
  PATHS /opt/fsl/include)
mark_as_advanced(BROADCOM_INCLUDE_DIR)

find_path(KERNEL_INCLUDE_DIR
  NAMES linux/mxc_v4l2.h
  DOC "Kernel include directory"
  PATHS /lib/modules/${CMAKE_SYSTEM_VERSION}/build)
mark_as_advanced(KERNEL_INCLUDE_DIR)

find_library(VPU_LIBRARY
  NAMES libvpu.so
  DOC "Path to Freescale VPU Library"
  PATHS /opt/fsl/lib)
mark_as_advanced(VCOS_LIBRARY)

include(${CMAKE_ROOT}/Modules/FindPackageHandleStandardArgs.cmake)
FIND_PACKAGE_HANDLE_STANDARD_ARGS(Freescale DEFAULT_MSG FREESCALE_INCLUDE_DIR KERNEL_INCLUDE_DIR VPU_LIBRARY)

set(FREESCALE_LIBRARIES ${VPU_LIBRARY})
set(FREESCALE_INCLUDE_DIRS ${FREESCALE_INCLUDE_DIR} ${KERNEL_INCLUDE_DIR})
                                                                                                                                                                                                                                                                           moonlight-embedded-2.1.1/cmake/FindOpus.cmake                                                       0000664 0000000 0000000 00000005324 12563604362 0021066 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # - Find opus library
# Find the native Opus headers and libraries. Opus depends on Ogg and will
# provide Ogg headers/libraries as well.
#
#  OPUS_INCLUDE_DIRS   - where to find opus/opus.h, ogg/ogg.h, etc
#  OPUS_LIBRARIES      - List of libraries when using libopus
#  OPUS_FOUND          - True if opus is found.


#=============================================================================
#Copyright 2000-2009 Kitware, Inc., Insight Software Consortium
#Copyright 2014, Mateusz "maxmati" Nowotynski
#All rights reserved.
#
#Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#* Redistributions of source code must retain the above copyright notice, 
#this list of conditions and the following disclaimer.
#
#* Redistributions in binary form must reproduce the above copyright notice, 
#this list of conditions and the following disclaimer in the documentation 
#and/or other materials provided with the distribution.
#
#* Neither the names of Kitware, Inc., the Insight Software Consortium, nor 
#the names of their contributors may be used to endorse or promote products 
#derived from this software without specific prior written  permission.
#
#THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
#AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
#IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
#ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
#LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
#CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
#SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
#INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
#CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
#ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
#POSSIBILITY OF SUCH DAMAGE.
#=============================================================================


# Look for the opusfile header file.
find_path( OPUS_INCLUDE_DIR
  NAMES opus/opus.h
  DOC "Opus include directory" )
mark_as_advanced( OPUS_INCLUDE_DIR )

# Look for the opus library.
find_library( OPUS_LIBRARY
  NAMES opus
  DOC "Path to Opus library" )
mark_as_advanced( OPUS_LIBRARY )


# handle the QUIETLY and REQUIRED arguments and set OPUSFILE_FOUND to TRUE if 
# all listed variables are TRUE
include( ${CMAKE_ROOT}/Modules/FindPackageHandleStandardArgs.cmake )
FIND_PACKAGE_HANDLE_STANDARD_ARGS( Opus DEFAULT_MSG OPUS_LIBRARY OPUS_INCLUDE_DIR )

set( OPUS_LIBRARIES ${OPUS_LIBRARY})
set( OPUS_INCLUDE_DIRS ${OPUS_INCLUDE_DIR} ${OPUS_INCLUDE_DIR}/opus )                                                                                                                                                                                                                                                                                                            moonlight-embedded-2.1.1/debian/                                                                    0000775 0000000 0000000 00000000000 12563604362 0016473 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        moonlight-embedded-2.1.1/debian/changelog                                                           0000664 0000000 0000000 00000001422 12563604362 0020344 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        moonlight-embedded (2.1.1-1) RELEASED; urgency=high

  * Update to version 2.1.1

 -- Iwan Timmer <irtimmer@gmail.com>  Sat, 15 Aug 2015 11:34:26 +0200

moonlight-embedded (2.1.0-1) RELEASED; urgency=low

  * Support OSMC
  * Update Moonlight-embedded to version 2.1.0

 -- Iwan Timmer <irtimmer@gmail.com>  Fri, 14 Aug 2015 16:13:67 +0200

moonlight-embedded (2.0.2-1) RELEASED; urgency=medium

  * More (untested) gamepad mappings included
  * Bigger range for gamepad sticks
  * Better error messaging
  * Input detection bug fixed

 -- Iwan Timmer <irtimmer@gmail.com>  Sat, 7 Jul 2015 21:05:48 +0200

moonlight-embedded (2.0.1-1) RELEASED; urgency=high

  * Initial release
  * This is my first Debian package

 -- Iwan Timmer <irtimmer@gmail.com>  Sat, 20 Jun 2015 13:58:32 +0200
                                                                                                                                                                                                                                              moonlight-embedded-2.1.1/debian/compat                                                              0000664 0000000 0000000 00000000002 12563604362 0017671 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        9
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              moonlight-embedded-2.1.1/debian/control                                                             0000664 0000000 0000000 00000001474 12563604362 0020104 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        Source: moonlight-embedded
Section: games
Priority: extra
Maintainer: Iwan Timmer <irtimmer@gmail.com>
Build-Depends: debhelper (>= 8.0.0), cmake, libopus-dev, libexpat1-dev, libasound2-dev, libudev-dev, libavahi-client-dev, libcurl4-openssl-dev, libevdev-dev, libraspberrypi-dev | rbp-userland-dev-osmc
Standards-Version: 3.9.3
Homepage: https://github.com/irtimmer/moonlight-embedded

Package: moonlight-embedded
Architecture: armhf
Depends: libopus0, libexpat1, libssl1.0.0, libasound2, libudev0, libavahi-client3, libcurl3, libevdev2, libraspberrypi0 | rbp-userland-osmc, ${shlibs:Depends}, ${misc:Depends}
Recommends: alsa-base
Suggests: alsa-utils
Description: GameStream client for Linux
 Game streaming client for Nvidia's GameStream.
 Stream games from your Windows computer with Nvidia graphic card to your linux box.
                                                                                                                                                                                                    moonlight-embedded-2.1.1/debian/copyright                                                           0000664 0000000 0000000 00000001756 12563604362 0020437 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        Format: http://www.debian.org/doc/packaging-manuals/copyright-format/1.0/
Upstream-Name: moonlight-embedded
Source: https://github.com/irtimmer/moonlight-embedded

Files: *
Copyright: 2014, 2015 Iwan Timmer <irtimmer@gmail.com>
License: GPL-3+
 This package is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 3 of the License, or
 (at your option) any later version.
 .
 This package is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 .
 You should have received a copy of the GNU General Public License
 along with this program. If not, see <http://www.gnu.org/licenses/>
 .
 On Debian systems, the complete text of the GNU General
 Public License version 3 can be found in "/usr/share/common-licenses/GPL-3".
                  moonlight-embedded-2.1.1/debian/patches/                                                            0000775 0000000 0000000 00000000000 12563604362 0020122 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        moonlight-embedded-2.1.1/debian/patches/install.patch                                               0000664 0000000 0000000 00000010454 12563604362 0022615 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        Compile using older version (2.8) of CMake
Index: moonlight-embedded/CMakeLists.txt
===================================================================
--- moonlight-embedded.orig/CMakeLists.txt	2015-08-14 14:05:22.000000000 +0000
+++ moonlight-embedded/CMakeLists.txt	2015-08-14 14:06:06.000000000 +0000
@@ -1,5 +1,5 @@
 project(moonlight-embedded C)
-cmake_minimum_required(VERSION 3.1)
+cmake_minimum_required(VERSION 2.8)
 SET(CMAKE_MODULE_PATH "${PROJECT_SOURCE_DIR}/cmake")
 include(${CMAKE_ROOT}/Modules/GNUInstallDirs.cmake)
 
@@ -53,11 +53,11 @@
 
 add_executable(moonlight ${SRC_LIST})
 target_link_libraries(moonlight gamestream)
-set_property(TARGET moonlight PROPERTY C_STANDARD 99)
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -std=gnu99")
 
 if (CEC_FOUND AND CEC_VERSION_COMPATIBLE)
   list(APPEND MOONLIGHT_DEFINITIONS HAVE_LIBCEC)
-  target_include_directories(moonlight PRIVATE ./third_party/libcec ${CEC_INCLUDE_DIRS}/libcec)
+  include_directories(./third_party/libcec ${CEC_INCLUDE_DIRS}/libcec)
   target_link_libraries(moonlight ${CEC_LIBRARIES})
 endif()
 
@@ -65,7 +65,7 @@
   list(APPEND MOONLIGHT_DEFINITIONS HAVE_PI)
   aux_source_directory(./third_party/ilclient ILCLIENT_SRC_LIST)
   add_library(moonlight-pi SHARED ./src/video/pi.c ${ILCLIENT_SRC_LIST})
-  target_include_directories(moonlight-pi PRIVATE ./third_party/ilclient ${BROADCOM_INCLUDE_DIRS} ${GAMESTREAM_INCLUDE_DIR} ${MOONLIGHT_COMMON_INCLUDE_DIR})
+  include_directories(./third_party/ilclient ${BROADCOM_INCLUDE_DIRS})
   target_link_libraries(moonlight-pi gamestream ${BROADCOM_LIBRARIES})
   set_property(TARGET moonlight-pi PROPERTY COMPILE_DEFINITIONS ${BROADCOM_DEFINITIONS})
   install(TARGETS moonlight-pi DESTINATION ${CMAKE_INSTALL_LIBDIR})
@@ -74,18 +74,18 @@
 if(FREESCALE_FOUND)
   list(APPEND MOONLIGHT_DEFINITIONS HAVE_IMX)
   add_library(moonlight-imx SHARED ./src/video/imx.c)
-  target_include_directories(moonlight-imx PRIVATE ${FREESCALE_INCLUDE_DIRS} ${GAMESTREAM_INCLUDE_DIR} ${MOONLIGHT_COMMON_INCLUDE_DIR})
+  include_directories(${FREESCALE_INCLUDE_DIRS})
   target_link_libraries(moonlight-imx gamestream ${FREESCALE_LIBRARIES})
   install(TARGETS moonlight-imx DESTINATION ${CMAKE_INSTALL_LIBDIR})
 endif()
 
 if (${SOFTWARE_FOUND})
-  target_include_directories(moonlight PRIVATE ${SDL_INCLUDE_DIRS} ${AVCODEC_INCLUDE_DIRS} ${AVUTIL_INCLUDE_DIRS} ${SWSCALE_INCLUDE_DIRS})
+  include_directories(${SDL_INCLUDE_DIRS} ${AVCODEC_INCLUDE_DIRS} ${AVUTIL_INCLUDE_DIRS} ${SWSCALE_INCLUDE_DIRS})
   target_link_libraries(moonlight ${SDL_LIBRARIES} ${AVCODEC_LIBRARIES} ${AVUTIL_LIBRARIES} ${SWSCALE_LIBRARIES})
 endif()
 
 set_property(TARGET moonlight PROPERTY COMPILE_DEFINITIONS ${MOONLIGHT_DEFINITIONS})
-target_include_directories(moonlight PRIVATE ${GAMESTREAM_INCLUDE_DIR} ${MOONLIGHT_COMMON_INCLUDE_DIR} ${OPUS_INCLUDE_DIRS} ${EVDEV_INCLUDE_DIRS} ${UDEV_INCLUDE_DIRS})
+include_directories(${GAMESTREAM_INCLUDE_DIR} ${MOONLIGHT_COMMON_INCLUDE_DIR} ${OPUS_INCLUDE_DIRS} ${EVDEV_INCLUDE_DIRS} ${UDEV_INCLUDE_DIRS})
 target_link_libraries(moonlight ${EVDEV_LIBRARIES} ${ALSA_LIBRARY} ${OPUS_LIBRARY} ${UDEV_LIBRARIES} ${CMAKE_DL_LIBS})
 
 add_subdirectory(docs)
Index: moonlight-embedded/libgamestream/CMakeLists.txt
===================================================================
--- moonlight-embedded.orig/libgamestream/CMakeLists.txt	2015-08-14 14:05:22.000000000 +0000
+++ moonlight-embedded/libgamestream/CMakeLists.txt	2015-08-14 14:10:39.000000000 +0000
@@ -14,13 +14,13 @@
 add_library(moonlight-common SHARED ${MOONLIGHT_COMMON_SRC_LIST})
 
 add_library(gamestream SHARED ${GAMESTREAM_SRC_LIST})
-set_property(TARGET gamestream PROPERTY C_STANDARD 99)
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -std=gnu99")
 target_link_libraries(gamestream moonlight-common)
 
 set_target_properties(gamestream PROPERTIES SOVERSION 0 VERSION ${MOONLIGHT_VERSION})
 set_target_properties(moonlight-common PROPERTIES SOVERSION 0 VERSION ${MOONLIGHT_VERSION})
 
-target_include_directories(gamestream PRIVATE ../third_party/moonlight-common-c ../third_party/h264bitstream ${AVAHI_INCLUDE_DIRS})
+include_directories(../third_party/h264bitstream ../third_party/moonlight-common-c ${AVAHI_INCLUDE_DIRS})
 target_link_libraries(gamestream ${CURL_LIBRARIES} ${OPENSSL_LIBRARIES} ${EXPAT_LIBRARIES} ${AVAHI_LIBRARIES})
 
 target_link_libraries(gamestream ${CMAKE_THREAD_LIBS_INIT} ${CMAKE_DL_LIBS})
                                                                                                                                                                                                                    moonlight-embedded-2.1.1/debian/patches/series                                                      0000664 0000000 0000000 00000000016 12563604362 0021334 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        install.patch
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  moonlight-embedded-2.1.1/debian/rules                                                               0000775 0000000 0000000 00000000152 12563604362 0017551 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #!/usr/bin/make -f
# Uncomment this to turn on verbose mode.
#export DH_VERBOSE=1

%:
	dh $@ --with quilt
                                                                                                                                                                                                                                                                                                                                                                                                                      moonlight-embedded-2.1.1/debian/source/                                                             0000775 0000000 0000000 00000000000 12563604362 0017773 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        moonlight-embedded-2.1.1/debian/source/format                                                       0000664 0000000 0000000 00000000014 12563604362 0021201 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        3.0 (quilt)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    moonlight-embedded-2.1.1/docs/                                                                      0000775 0000000 0000000 00000000000 12563604362 0016201 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        moonlight-embedded-2.1.1/docs/CMakeLists.txt                                                        0000664 0000000 0000000 00000000535 12563604362 0020744 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        add_custom_command(OUTPUT moonlight.1 COMMAND pod2man --section=1 --center="Moonlight Embedded Manual" --name="MOONLIGHT" --release="moonlight 2.1.0" ${CMAKE_CURRENT_SOURCE_DIR}/README.pod > moonlight.1)
add_custom_target(docs ALL DEPENDS moonlight.1)

install(FILES ${CMAKE_CURRENT_BINARY_DIR}/moonlight.1 DESTINATION ${CMAKE_INSTALL_MANDIR}/man1)
                                                                                                                                                                   moonlight-embedded-2.1.1/docs/README.pod                                                            0000664 0000000 0000000 00000006671 12563604362 0017654 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        =head1 NAME

Moonlight Embedded - Open source implementation of NVIDIA's GameStream

=head1 SYNOPSIS

Usage: I<moonlight> E<lt>actionE<gt> [options] [host]
       I<moonlight> E<lt>configfileE<gt>

=head1 ACTIONS

=over 4

=item B<map>

Create a mapping file for a gamepad.

=item B<pair>

Pair this computer with the host.

=item B<stream>

Stream game from host to this computer.

=item B<list>

List all available games and application on host.

=item B<quit>

Quit the current running game or application on host.

=item B<help>

Show help for all available commands.

=back

=head1 OPTIONS

=over 4

=item B<-config> [I<CONFIG>]

Load configuration file I<CONFIG>.
All options specified before B<-config> will be overwritten by the options in I<CONFIG>.
This options can be used multiple times.

=item B<-save> [I<CONFIG>]

Save the configuration provided by the options on the command line and all loaded configuration files to the file I<CONFIG>.

=item B<-720>

Use the resolution 1280x720 for streaming.
This is the default option.

=item B<-1080>

Use the resolution 1920x1080 for streaming.

=item B<-width> [I<WIDTH>]

Change the horizontal resolution to I<WIDTH>

=item B<-height> [I<HEIGHT>]

Change the vertical resolution to I<HEIGHT>

=item B<-30fps>

Use 30 fps for streaming.

=item B<-60fps>

Use 60 fps for streaming.
This is the default configuration.

=item B<-bitrate> [I<BITRATE>]

Change bitrate to I<BITRATE> kbps.
By default the bitrate depends on the selected resolution and fps.
For resolution 1080p and 60 fps and higher 20 Mbps is used.
For resolution 1080p or 60 fps and higher 10 Mbps is used
For other configurations 5 Mbps is used by default.

=item B<-packetsize> [I<PACKETSIZE>]

Change the network packetsize to I<PACKETSIZE>.
The packetsize should the smaller than the MTU of the network.
By default a safe value of 1024 is used.

=item B<-remote>

Enable the optimizations for remote connections in GFE.

=item B<-app> [I<APP>]

Change the requested app to execute to I<APP>.
By default Steam is started.

=item B<-nosops>

Stop GFE from changing the graphical settings of the requested game or application.

=item B<-localaudio>

Play the audio on the host instead of this computer.

=item B<-keydir> [I<DIRECTORY>]

Change the directory to save encryption keys to I<DIRECTORY>.
By default the encryption keys are stored in $XDG_CACHE_DIR/moonlight or ~/.cache/moonlight

=item B<-mapping> [I<MAPPING>]

Use I<MAPPING> as the mapping file for all inputs specified after this B<-mapping>.
If no B<-input> is specified after the B<-mapping> this mapping is used for autoloaded inputs.

=item B<-input> [I<INPUT>]

Enable the I<INPUT> device.
By default all available input devices are enabled.
Only evdev devices /dev/input/event* are supported.
To use a different gamepad mapping then the default the B<-mapping> should be specified before the B<-input>.

=item B<-audio> [I<DEVICE>]

Use <DEVICE> as audio output device.
The default value is 'sysdefault'

=back

=head1 CONFIG FILE

Moonlight Embedded will load a confiuration file from:

  $XDG_CONFIG_HOME/moonligt/moonlight.conf (fallback to ~/.config/moonligt/moonlight.conf)

If no user specified configuration file is available the configuration will be loaded from:

  /etc/moonlight/moonlight.conf

A documented example configuration file can be found at /etc/moonlight/moonlight.conf.

=head1 COMMENTS

Use Ctrl+Alt+Shift+Q to quit the streaming session.

=head1 AUTHOR

Iwan Timmer E<lt>irtimmer@gmail.comE<gt>
                                                                       moonlight-embedded-2.1.1/libgamestream/                                                             0000775 0000000 0000000 00000000000 12563604362 0020065 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        moonlight-embedded-2.1.1/libgamestream/CMakeLists.txt                                               0000664 0000000 0000000 00000002426 12563604362 0022631 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        find_package(Threads REQUIRED)
find_package(CURL REQUIRED)
find_package(OpenSSL REQUIRED)
find_package(EXPAT REQUIRED)

pkg_check_modules(AVAHI REQUIRED avahi-client)

aux_source_directory(./ GAMESTREAM_SRC_LIST)
aux_source_directory(../third_party/h264bitstream GAMESTREAM_SRC_LIST)

aux_source_directory(../third_party/moonlight-common-c/limelight-common MOONLIGHT_COMMON_SRC_LIST)
aux_source_directory(../third_party/moonlight-common-c/limelight-common/OpenAES MOONLIGHT_COMMON_SRC_LIST)

add_library(moonlight-common SHARED ${MOONLIGHT_COMMON_SRC_LIST})

add_library(gamestream SHARED ${GAMESTREAM_SRC_LIST})
set_property(TARGET gamestream PROPERTY C_STANDARD 99)
target_link_libraries(gamestream moonlight-common)

set_target_properties(gamestream PROPERTIES SOVERSION 0 VERSION ${MOONLIGHT_VERSION})
set_target_properties(moonlight-common PROPERTIES SOVERSION 0 VERSION ${MOONLIGHT_VERSION})

target_include_directories(gamestream PRIVATE ../third_party/moonlight-common-c ../third_party/h264bitstream ${AVAHI_INCLUDE_DIRS})
target_link_libraries(gamestream ${CURL_LIBRARIES} ${OPENSSL_LIBRARIES} ${EXPAT_LIBRARIES} ${AVAHI_LIBRARIES})

target_link_libraries(gamestream ${CMAKE_THREAD_LIBS_INIT} ${CMAKE_DL_LIBS})

install(TARGETS gamestream moonlight-common DESTINATION ${CMAKE_INSTALL_LIBDIR})
                                                                                                                                                                                                                                          moonlight-embedded-2.1.1/libgamestream/client.c                                                     0000664 0000000 0000000 00000030233 12563604362 0021510 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#include "http.h"
#include "xml.h"
#include "mkcert.h"
#include "client.h"
#include "errors.h"

#include "limelight-common/Limelight.h"

#include <sys/stat.h>
#include <stdbool.h>
#include <stdio.h>
#include <string.h>
#include <openssl/sha.h>
#include <openssl/aes.h>
#include <openssl/rand.h>
#include <openssl/evp.h>
#include <openssl/x509.h>
#include <openssl/pem.h>
#include <openssl/err.h>

#define UNIQUE_FILE_NAME "uniqueid.dat"
#define P12_FILE_NAME "client.p12"

#define UNIQUEID_BYTES 8
#define UNIQUEID_CHARS (UNIQUEID_BYTES*2)

static char unique_id[UNIQUEID_CHARS+1];
static X509 *cert;
static char cert_hex[4096];
static EVP_PKEY *privateKey;

const char* gs_error;

static int mkdirtree(const char* directory) {
  char buffer[1024];
  char* p = buffer;

  // The passed in string could be a string literal
  // so we must copy it first
  strcpy(p, directory);

  while (*p != 0) {
    // Find the end of the path element
    do {
      p++;
    } while (*p != 0 && *p != '/');

    char oldChar = *p;
    *p = 0;

    // Create the directory if it doesn't exist already
    if (mkdir(buffer, 0775) == -1 && errno != EEXIST) {
        return -1;
    }

    *p = oldChar;
  }

  return 0;
}

static int load_unique_id(const char* keyDirectory) {
  char uniqueFilePath[4096];
  sprintf(uniqueFilePath, "%s/%s", keyDirectory, UNIQUE_FILE_NAME);

  FILE *fd = fopen(uniqueFilePath, "r");
  if (fd == NULL) {
    unsigned char unique_data[UNIQUEID_BYTES];
    RAND_bytes(unique_data, UNIQUEID_BYTES);
    for (int i = 0; i < UNIQUEID_BYTES; i++) {
      sprintf(unique_id + (i * 2), "%02x", unique_data[i]);
    }
    fd = fopen(uniqueFilePath, "w");
    if (fd == NULL)
      return GS_FAILED;

    fwrite(unique_id, UNIQUEID_CHARS, 1, fd);
  } else {
    fread(unique_id, UNIQUEID_CHARS, 1, fd);
  }
  fclose(fd);
  unique_id[UNIQUEID_CHARS] = 0;

  return GS_OK;
}

static int load_cert(const char* keyDirectory) {
  char certificateFilePath[4096];
  sprintf(certificateFilePath, "%s/%s", keyDirectory, CERTIFICATE_FILE_NAME);

  char keyFilePath[4096];
  sprintf(&keyFilePath[0], "%s/%s", keyDirectory, KEY_FILE_NAME);

  FILE *fd = fopen(certificateFilePath, "r");
  if (fd == NULL) {
    printf("Generating certificate...");
    CERT_KEY_PAIR cert = mkcert_generate();
    printf("done\n");

    char p12FilePath[4096];
    sprintf(p12FilePath, "%s/%s", keyDirectory, P12_FILE_NAME);

    mkcert_save(certificateFilePath, p12FilePath, keyFilePath, cert);
    mkcert_free(cert);
    fd = fopen(certificateFilePath, "r");
  }

  if (fd == NULL) {
    gs_error = "Can't open certificate file";
    return GS_FAILED;
  }

  if (!(cert = PEM_read_X509(fd, NULL, NULL, NULL))) {
    gs_error = "Error loading cert into memory";
    return GS_FAILED;
  }

  rewind(fd);

  int c;
  int length = 0;
  while ((c = fgetc(fd)) != EOF) {
    sprintf(cert_hex + length, "%02x", c);
    length += 2;
  }
  cert_hex[length] = 0;

  fclose(fd);

  fd = fopen(keyFilePath, "r");
  if (fd == NULL) {
    gs_error = "Error loading key into memory";
    return GS_FAILED;
  }

  PEM_read_PrivateKey(fd, &privateKey, NULL, NULL);
  fclose(fd);

  return GS_OK;
}

static int load_server_status(PSERVER_DATA server) {
  char *pairedText = NULL;
  char *currentGameText = NULL;
  char *versionText = NULL;

  int ret = GS_INVALID;
  char url[4096];
  sprintf(url, "https://%s:47984/serverinfo?uniqueid=%s", server->address, unique_id);

  PHTTP_DATA data = http_create_data();
  if (data == NULL) {
    ret = GS_OUT_OF_MEMORY;
    goto cleanup;
  }
  if (http_request(url, data) != GS_OK) {
    ret = GS_IO_ERROR;
    goto cleanup;
  }

  if (xml_search(data->memory, data->size, "currentgame", &currentGameText) != GS_OK) {
    goto cleanup;
  }

  if (xml_search(data->memory, data->size, "PairStatus", &pairedText) != GS_OK)
    goto cleanup;

  if (xml_search(data->memory, data->size, "appversion", &versionText) != GS_OK)
    goto cleanup;

  server->paired = pairedText != NULL && strcmp(pairedText, "1") == 0;
  server->currentGame = currentGameText == NULL ? 0 : atoi(currentGameText);
  char *versionSep = strstr(versionText, ".");
  if (versionSep != NULL) {
    *versionSep = 0;
  }
  server->serverMajorVersion = atoi(versionText);
  ret = GS_OK;

  cleanup:
  if (data != NULL)
    http_free_data(data);

  if (pairedText != NULL)
    free(pairedText);

  if (currentGameText != NULL)
    free(currentGameText);

  if (versionText != NULL)
    free(versionText);

  return ret;
}

static void bytes_to_hex(unsigned char *in, char *out, size_t len) {
  for (int i = 0; i < len; i++) {
    sprintf(out + i * 2, "%02x", in[i]);
  }
  out[len * 2] = 0;
}

static int sign_it(const char *msg, size_t mlen, unsigned char **sig, size_t *slen, EVP_PKEY *pkey) {
  int result = GS_FAILED;

  *sig = NULL;
  *slen = 0;

  EVP_MD_CTX *ctx = EVP_MD_CTX_create();
  if (ctx == NULL)
    return GS_FAILED;

  const EVP_MD *md = EVP_get_digestbyname("SHA256");
  if (md == NULL)
    goto cleanup;

  int rc = EVP_DigestInit_ex(ctx, md, NULL);
  if (rc != 1)
    goto cleanup;

  rc = EVP_DigestSignInit(ctx, NULL, md, NULL, pkey);
  if (rc != 1)
    goto cleanup;

  rc = EVP_DigestSignUpdate(ctx, msg, mlen);
  if (rc != 1)
    goto cleanup;

  size_t req = 0;
  rc = EVP_DigestSignFinal(ctx, NULL, &req);
  if (rc != 1 || !(req > 0))
    goto cleanup;

  *sig = OPENSSL_malloc(req);
  if (*sig == NULL)
    goto cleanup;

  *slen = req;
  rc = EVP_DigestSignFinal(ctx, *sig, slen);
  if (rc != 1 || req != *slen)
    goto cleanup;

  result = GS_OK;

  cleanup:
  EVP_MD_CTX_destroy(ctx);
  ctx = NULL;

  return result;
}

int gs_pair(PSERVER_DATA server, char* pin) {
  int ret = GS_OK;
  char url[4096];

  if (server->paired) {
    gs_error = "Already paired";
    return GS_WRONG_STATE;
  }

  if (server->currentGame != 0) {
    gs_error = "The computer is currently in a game. You must close the game before pairing";
    return GS_WRONG_STATE;
  }

  unsigned char salt_data[16];
  char salt_hex[33];
  RAND_bytes(salt_data, 16);
  bytes_to_hex(salt_data, salt_hex, 16);

  sprintf(url, "https://%s:47984/pair?uniqueid=%s&devicename=roth&updateState=1&phrase=getservercert&salt=%s&clientcert=%s", server->address, unique_id, salt_hex, cert_hex);
  PHTTP_DATA data = http_create_data();
  if (data == NULL)
    return GS_OUT_OF_MEMORY;
  else if ((ret = http_request(url, data)) != GS_OK)
    goto cleanup;

  unsigned char salt_pin[20];
  unsigned char aes_key_hash[20];
  AES_KEY aes_key;
  memcpy(salt_pin, salt_data, 16);
  memcpy(salt_pin+16, salt_pin, 4);
  SHA1(salt_pin, 20, aes_key_hash);
  AES_set_encrypt_key((unsigned char *)aes_key_hash, 128, &aes_key);

  unsigned char challenge_data[16];
  unsigned char challenge_enc[16];
  char challenge_hex[33];
  RAND_bytes(challenge_data, 16);
  AES_encrypt(challenge_data, challenge_enc, &aes_key);
  bytes_to_hex(challenge_enc, challenge_hex, 16);

  sprintf(url, "https://%s:47984/pair?uniqueid=%s&devicename=roth&updateState=1&clientchallenge=%s", server->address, unique_id, challenge_hex);
  if ((ret = http_request(url, data)) != GS_OK)
    goto cleanup;

  char *result;
  if (xml_search(data->memory, data->size, "challengeresponse", &result) != GS_OK) {
    ret = GS_INVALID;
    goto cleanup;
  }

  char challenge_response_data_enc[48];
  char challenge_response_data[48];
  for (int count = 0; count < strlen(result); count++) {
    sscanf(&result[count], "%2hhx", &challenge_response_data_enc[count / 2]);
  }
  free(result);

  for (int i = 0; i < 48; i += 16) {
    AES_decrypt(&challenge_response_data_enc[i], &challenge_response_data[i], &aes_key);
  }

  char client_secret_data[16];
  RAND_bytes(client_secret_data, 16);

  char challenge_response[16 + 256 + 16];
  char challenge_response_hash[32];
  char challenge_response_hash_enc[32];
  char challenge_response_hex[33];
  memcpy(challenge_response, challenge_response_data + 20, 16);
  memcpy(challenge_response + 16, cert->signature->data, 256);
  memcpy(challenge_response + 16 + 256, client_secret_data, 16);
  SHA1(challenge_response, 16 + 256 + 16, challenge_response_hash);

  for (int i = 0; i < 32; i += 16) {
    AES_encrypt(&challenge_response_hash[i], &challenge_response_hash_enc[i], &aes_key);
  }
  bytes_to_hex(challenge_response_hash_enc, challenge_response_hex, 32);

  sprintf(url, "https://%s:47984/pair?uniqueid=%s&devicename=roth&updateState=1&serverchallengeresp=%s", server->address, unique_id, challenge_response_hex);
  if ((ret = http_request(url, data)) != GS_OK)
    goto cleanup;

  if (xml_search(data->memory, data->size, "pairingsecret", &result) != GS_OK) {
    ret = GS_INVALID;
    goto cleanup;
  }

  unsigned char *signature = NULL;
  size_t s_len;
  if (sign_it(client_secret_data, 16, &signature, &s_len, privateKey) != GS_OK) {
      gs_error = "Failed to sign data";
      ret = GS_FAILED;
      goto cleanup;
  }

  char client_pairing_secret[16 + 256];
  char client_pairing_secret_hex[(16 + 256) * 2 + 1];
  memcpy(client_pairing_secret, client_secret_data, 16);
  memcpy(client_pairing_secret + 16, signature, 256);
  bytes_to_hex(client_pairing_secret, client_pairing_secret_hex, 16 + 256);

  sprintf(url, "https://%s:47984/pair?uniqueid=%s&devicename=roth&updateState=1&clientpairingsecret=%s", server->address, unique_id, client_pairing_secret_hex);
  if ((ret = http_request(url, data)) != GS_OK)
    goto cleanup;

  sprintf(url, "https://%s:47984/pair?uniqueid=%s&devicename=roth&updateState=1&phrase=pairchallenge", server->address, unique_id);
  if ((ret = http_request(url, data)) != GS_OK)
    goto cleanup;

  server->paired = true;

  cleanup:
  http_free_data(data);

  return ret;
}

int gs_applist(PSERVER_DATA server, PAPP_LIST *list) {
  int ret = GS_OK;
  char url[4096];
  PHTTP_DATA data = http_create_data();
  if (data == NULL)
    return GS_OUT_OF_MEMORY;

  sprintf(url, "https://%s:47984/applist?uniqueid=%s", server->address, unique_id);
  if (http_request(url, data) != GS_OK)
    ret = GS_IO_ERROR;
  else if (xml_applist(data->memory, data->size, list) != GS_OK)
    ret = GS_INVALID;

  http_free_data(data);
  return ret;
}

int gs_start_app(PSERVER_DATA server, STREAM_CONFIGURATION *config, int appId, bool sops, bool localaudio) {
  RAND_bytes(config->remoteInputAesKey, 16);
  memset(config->remoteInputAesIv, 0, 16);

  srand(time(NULL));
  char url[4096];
  u_int32_t rikeyid = 1;
  char rikey_hex[33];
  bytes_to_hex(config->remoteInputAesKey, rikey_hex, 16);

  PHTTP_DATA data = http_create_data();
  if (data == NULL)
    return GS_OUT_OF_MEMORY;

  if (server->currentGame == 0)
    sprintf(url, "https://%s:47984/launch?uniqueid=%s&appid=%d&mode=%dx%dx%d&additionalStates=1&sops=%d&rikey=%s&rikeyid=%d&localAudioPlayMode=%d", server->address, unique_id, appId, config->width, config->height, config->fps, sops, rikey_hex, rikeyid, localaudio);
  else
    sprintf(url, "https://%s:47984/resume?uniqueid=%s&rikey=%s&rikeyid=%d", server->address, unique_id, rikey_hex, rikeyid);

  int ret = http_request(url, data);
  if (ret == GS_OK)
    server->currentGame = appId;

  http_free_data(data);
  return ret;
}

int gs_quit_app(PSERVER_DATA server) {
  char url[4096];
  PHTTP_DATA data = http_create_data();
  if (data == NULL)
    return GS_OUT_OF_MEMORY;

  sprintf(url, "https://%s:47984/cancel?uniqueid=%s", server->address, unique_id);
  int ret = http_request(url, data);

  http_free_data(data);
  return ret;
}

int gs_init(PSERVER_DATA server, const char *keyDirectory) {
  mkdirtree(keyDirectory);
  if (load_unique_id(keyDirectory) != GS_OK)
    return GS_FAILED;

  if (load_cert(keyDirectory))
    return GS_FAILED;

  http_init(keyDirectory);
  return load_server_status(server);
}
                                                                                                                                                                                                                                                                                                                                                                     moonlight-embedded-2.1.1/libgamestream/client.h                                                     0000664 0000000 0000000 00000002374 12563604362 0021522 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

#include "xml.h"

#include "limelight-common/Limelight.h"

#include <stdbool.h>

typedef struct _SERVER_DATA {
  const char* address;
  bool paired;
  int currentGame;
  int serverMajorVersion;
} SERVER_DATA, *PSERVER_DATA;

int gs_init(PSERVER_DATA server, const char *keyDirectory);
int gs_start_app(PSERVER_DATA server, PSTREAM_CONFIGURATION config, int appId, bool sops, bool localaudio);
int gs_applist(PSERVER_DATA server, PAPP_LIST *app_list);
int gs_pair(PSERVER_DATA server, char* pin);
int gs_quit_app(PSERVER_DATA server);
                                                                                                                                                                                                                                                                    moonlight-embedded-2.1.1/libgamestream/discover.c                                                   0000664 0000000 0000000 00000006726 12563604362 0022062 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Based on Avahi example client-browse-services
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#include "errors.h"

#include <avahi-client/client.h>
#include <avahi-client/lookup.h>

#include <avahi-common/simple-watch.h>
#include <avahi-common/malloc.h>
#include <avahi-common/error.h>

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <time.h>

static AvahiSimplePoll *simple_poll = NULL;

static void client_callback(AvahiClient *c, AvahiClientState state, void *userdata) {
  if (state == AVAHI_CLIENT_FAILURE) {
    gs_error = "Server connection failure";
    avahi_simple_poll_quit(simple_poll);
  }
}

static void resolve_callback(AvahiServiceResolver *r, AvahiIfIndex interface, AvahiProtocol protocol, AvahiResolverEvent event, const char *name, const char *type, const char *domain, const char *host_name, const AvahiAddress *address, uint16_t port, AvahiStringList *txt, AvahiLookupResultFlags flags, void *userdata) {
  if (event == AVAHI_RESOLVER_FOUND) {
    if (userdata != NULL) {
      avahi_address_snprint(userdata, AVAHI_ADDRESS_STR_MAX, address);
      avahi_simple_poll_quit(simple_poll);
    } else {
      char strAddress[AVAHI_ADDRESS_STR_MAX];
      avahi_address_snprint(strAddress, sizeof(strAddress), address);
      printf(" %s (%s)\n", host_name, strAddress);
    }
  }

  avahi_service_resolver_free(r);
}

static void browse_callback(AvahiServiceBrowser *b, AvahiIfIndex interface, AvahiProtocol protocol, AvahiBrowserEvent event, const char *name, const char *type, const char *domain, AvahiLookupResultFlags flags, void* userdata) {
  AvahiClient *c = avahi_service_browser_get_client(b);

  switch (event) {
  case AVAHI_BROWSER_FAILURE:
    gs_error = "Server browser failure";
    avahi_simple_poll_quit(simple_poll);
    break;
  case AVAHI_BROWSER_NEW:
    if (!(avahi_service_resolver_new(c, interface, protocol, name, type, domain, AVAHI_PROTO_UNSPEC, 0, resolve_callback, userdata)))
      gs_error = "Failed to resolve service";

    break;
  case AVAHI_BROWSER_REMOVE:
    break;
  }
}

void gs_discover_server(char* dest) {
  AvahiClient *client = NULL;
  AvahiServiceBrowser *sb = NULL;

  if (!(simple_poll = avahi_simple_poll_new())) {
    gs_error = "Failed to create simple poll object";
    goto cleanup;
  }

  int error;
  client = avahi_client_new(avahi_simple_poll_get(simple_poll), 0, client_callback, NULL, &error);
  if (!client) {
    gs_error = "Failed to create client";
    goto cleanup;
  }

  if (!(sb = avahi_service_browser_new(client, AVAHI_IF_UNSPEC, AVAHI_PROTO_UNSPEC, "_nvstream._tcp", NULL, 0, browse_callback, dest))) {
    gs_error = "Failed to create service browser";
    goto cleanup;
  }

  avahi_simple_poll_loop(simple_poll);

  cleanup:
  if (sb)
    avahi_service_browser_free(sb);

  if (client)
    avahi_client_free(client);

  if (simple_poll)
    avahi_simple_poll_free(simple_poll);
}
                                          moonlight-embedded-2.1.1/libgamestream/discover.h                                                   0000664 0000000 0000000 00000001430 12563604362 0022052 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

#include "errors.h"

#define MAX_ADDRESS_SIZE 40

void gs_discover_server(char* dest);
                                                                                                                                                                                                                                        moonlight-embedded-2.1.1/libgamestream/errors.h                                                     0000664 0000000 0000000 00000001605 12563604362 0021554 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

#define GS_OK 0
#define GS_FAILED -1
#define GS_OUT_OF_MEMORY -2
#define GS_INVALID -3
#define GS_WRONG_STATE -4
#define GS_IO_ERROR -5

const char* gs_error;
                                                                                                                           moonlight-embedded-2.1.1/libgamestream/http.c                                                       0000664 0000000 0000000 00000006065 12563604362 0021217 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#include "http.h"
#include "errors.h"

#include <string.h>
#include <curl/curl.h>

static CURL *curl;

static const char *pCertFile = "./client.pem";
static const char *pKeyFile = "./key.pem";

static size_t _write_curl(void *contents, size_t size, size_t nmemb, void *userp)
{
  size_t realsize = size * nmemb;
  PHTTP_DATA mem = (PHTTP_DATA)userp;
 
  mem->memory = realloc(mem->memory, mem->size + realsize + 1);
  if(mem->memory == NULL)
    return 0;
 
  memcpy(&(mem->memory[mem->size]), contents, realsize);
  mem->size += realsize;
  mem->memory[mem->size] = 0;
 
  return realsize;
}

int http_init(const char* keyDirectory) {
  curl = curl_easy_init();
  if (!curl)
    return GS_FAILED;

  char certificateFilePath[4096];
  sprintf(certificateFilePath, "%s/%s", keyDirectory, CERTIFICATE_FILE_NAME);

  char keyFilePath[4096];
  sprintf(&keyFilePath[0], "%s/%s", keyDirectory, KEY_FILE_NAME);

  curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);
  curl_easy_setopt(curl, CURLOPT_SSLENGINE_DEFAULT, 1L);
  curl_easy_setopt(curl, CURLOPT_SSLCERTTYPE,"PEM");
  curl_easy_setopt(curl, CURLOPT_SSLCERT, certificateFilePath);
  curl_easy_setopt(curl, CURLOPT_SSLKEYTYPE, "PEM");
  curl_easy_setopt(curl, CURLOPT_SSLKEY, keyFilePath);
  curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
  curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, _write_curl);
  curl_easy_setopt(curl, CURLOPT_FAILONERROR, 1L);

  return GS_OK;
}

int http_request(char* url, PHTTP_DATA data) {
  curl_easy_setopt(curl, CURLOPT_WRITEDATA, data);
  curl_easy_setopt(curl, CURLOPT_URL, url);

  if (data->size > 0) {
    free(data->memory);
    data->memory = malloc(1);
    if(data->memory == NULL)
      return GS_OUT_OF_MEMORY;

    data->size = 0;
  }
  CURLcode res = curl_easy_perform(curl);
  
  if(res != CURLE_OK) {
    gs_error = curl_easy_strerror(res);
    return GS_FAILED;
  } else if (data->memory == NULL) {
    return GS_OUT_OF_MEMORY;
  }
  
  return GS_OK;
}

void http_cleanup() {
  curl_easy_cleanup(curl);
}

PHTTP_DATA http_create_data() {
  PHTTP_DATA data = malloc(sizeof(HTTP_DATA));
  if (data == NULL)
    return NULL;

  data->memory = malloc(1);
  if(data->memory == NULL) {
    free(data);
    return NULL;
  }
  data->size = 0;

  return data;
}

void http_free_data(PHTTP_DATA data) {
  if (data != NULL) {
    if (data->memory != NULL)
      free(data->memory);

    free(data);
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           moonlight-embedded-2.1.1/libgamestream/http.h                                                       0000664 0000000 0000000 00000002071 12563604362 0021215 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

#include <stdlib.h>

#define CERTIFICATE_FILE_NAME "client.pem"
#define KEY_FILE_NAME "key.pem"

typedef struct _HTTP_DATA {
  char *memory;
  size_t size;
} HTTP_DATA, *PHTTP_DATA;

int http_init(const char* keyDirectory);
PHTTP_DATA http_create_data();
int http_request(char* url, PHTTP_DATA data);
void http_free_data(PHTTP_DATA data);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       moonlight-embedded-2.1.1/libgamestream/mkcert.c                                                     0000664 0000000 0000000 00000011205 12563604362 0021515 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#include "mkcert.h"

#include <stdio.h>
#include <stdlib.h>

#include <openssl/pem.h>
#include <openssl/conf.h>
#include <openssl/pkcs12.h>

#ifndef OPENSSL_NO_ENGINE
#include <openssl/engine.h>
#endif

static const int NUM_BITS = 2048;
static const int SERIAL = 0;
static const int NUM_YEARS = 10;

int mkcert(X509 **x509p, EVP_PKEY **pkeyp, int bits, int serial, int years);
int add_ext(X509 *cert, int nid, char *value);

CERT_KEY_PAIR mkcert_generate() {
    BIO *bio_err;
    X509 *x509 = NULL;
    EVP_PKEY *pkey = NULL;
    PKCS12 *p12 = NULL;
   
    CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);
    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);
    
    SSLeay_add_all_algorithms();
    ERR_load_crypto_strings();
    
    mkcert(&x509, &pkey, NUM_BITS, SERIAL, NUM_YEARS);

    p12 = PKCS12_create("limelight", "GameStream", pkey, x509, NULL, 0, 0, 0, 0, 0);

#ifndef OPENSSL_NO_ENGINE
    ENGINE_cleanup();
#endif
    CRYPTO_cleanup_all_ex_data();
    
    CRYPTO_mem_leaks(bio_err);
    BIO_free(bio_err);
    
    return (CERT_KEY_PAIR) {x509, pkey, p12};
}

void mkcert_free(CERT_KEY_PAIR certKeyPair) {
    X509_free(certKeyPair.x509);
    EVP_PKEY_free(certKeyPair.pkey);
    PKCS12_free(certKeyPair.p12);
}

void mkcert_save(const char* certFile, const char* p12File, const char* keyPairFile, CERT_KEY_PAIR certKeyPair) {
    FILE* certFilePtr = fopen(certFile, "w");
    FILE* keyPairFilePtr = fopen(keyPairFile, "w");
    FILE* p12FilePtr = fopen(p12File, "wb");
    
    //TODO: error check
    PEM_write_PrivateKey(keyPairFilePtr, certKeyPair.pkey, NULL, NULL, 0, NULL, NULL);
    PEM_write_X509(certFilePtr, certKeyPair.x509);
    i2d_PKCS12_fp(p12FilePtr, certKeyPair.p12);
    
    fclose(p12FilePtr);
    fclose(certFilePtr);
    fclose(keyPairFilePtr);
}

int mkcert(X509 **x509p, EVP_PKEY **pkeyp, int bits, int serial, int years) {
    X509 *x;
    EVP_PKEY *pk;
    RSA *rsa;
    X509_NAME *name = NULL;
    
    if (*pkeyp == NULL) {
        if ((pk=EVP_PKEY_new()) == NULL) {
            abort();
            return(0);
        }
    } else {
        pk = *pkeyp;
    }
    
    if (*x509p == NULL) {
        if ((x = X509_new()) == NULL) {
            goto err;
        }
    } else {
        x = *x509p;
    }
    
    rsa = RSA_generate_key(bits, RSA_F4, NULL, NULL);
    if (!EVP_PKEY_assign_RSA(pk, rsa)) {
        abort();
        goto err;
    }
    
    X509_set_version(x, 2);
    ASN1_INTEGER_set(X509_get_serialNumber(x), serial);
    X509_gmtime_adj(X509_get_notBefore(x), 0);
    X509_gmtime_adj(X509_get_notAfter(x), (long)60*60*24*365*years);
    X509_set_pubkey(x, pk);
    
    name = X509_get_subject_name(x);
    
    /* This function creates and adds the entry, working out the
     * correct string type and performing checks on its length.
     */
    X509_NAME_add_entry_by_txt(name,"CN", MBSTRING_ASC, (unsigned char*)"NVIDIA GameStream Client", -1, -1, 0);
    
    /* Its self signed so set the issuer name to be the same as the
     * subject.
     */
    X509_set_issuer_name(x, name);
    
    /* Add various extensions: standard extensions */
    add_ext(x, NID_basic_constraints, "critical,CA:TRUE");
    add_ext(x, NID_key_usage, "critical,keyCertSign,cRLSign");
    
    add_ext(x, NID_subject_key_identifier, "hash");
    
    if (!X509_sign(x, pk, EVP_sha1())) {
        goto err;
    }
    
    *x509p = x;
    *pkeyp = pk;
    
    return(1);
err:
    return(0);
}

/* Add extension using V3 code: we can set the config file as NULL
 * because we wont reference any other sections.
 */

int add_ext(X509 *cert, int nid, char *value)
{
    X509_EXTENSION *ex;
    X509V3_CTX ctx;
    /* This sets the 'context' of the extensions. */
    /* No configuration database */
    X509V3_set_ctx_nodb(&ctx);
    /* Issuer and subject certs: both the target since it is self signed,
     * no request and no CRL
     */
    X509V3_set_ctx(&ctx, cert, cert, NULL, NULL, 0);
    ex = X509V3_EXT_conf_nid(NULL, &ctx, nid, value);
    if (!ex) {
        return 0;
    }
    
    X509_add_ext(cert, ex, -1);
    X509_EXTENSION_free(ex);
    return 1;
}

                                                                                                                                                                                                                                                                                                                                                                                           moonlight-embedded-2.1.1/libgamestream/mkcert.h                                                     0000664 0000000 0000000 00000002141 12563604362 0021521 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * Created by Diego Waxemberg on 10/16/14.
 * Copyright (c) 2014 Limelight Stream. All rights reserved.
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

#include <openssl/x509v3.h>
#include <openssl/pkcs12.h>

typedef struct _CERT_KEY_PAIR {
    X509 *x509;
    EVP_PKEY *pkey;
    PKCS12 *p12;
} CERT_KEY_PAIR, *PCERT_KEY_PAIR;

CERT_KEY_PAIR mkcert_generate();
void mkcert_free(CERT_KEY_PAIR);
void mkcert_save(const char* certFile, const char* p12File, const char* keyPairFile, CERT_KEY_PAIR certKeyPair);
                                                                                                                                                                                                                                                                                                                                                                                                                               moonlight-embedded-2.1.1/libgamestream/sps.c                                                        0000664 0000000 0000000 00000011370 12563604362 0021040 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#include "sps.h"

#include "h264_stream.h"

static h264_stream_t* h264_stream;
static int initial_width, initial_height;

static int replay_sps;

void gs_sps_init(int width, int height) {
  h264_stream = h264_new();
  initial_width = width;
  initial_height = height;
}

PLENTRY gs_sps_fix(PLENTRY *head, int flags) {
  PLENTRY entry = *head;
  const char naluHeader[] = {0x00, 0x00, 0x00, 0x01};

  if (replay_sps == 1) {
    PLENTRY replay_entry = (PLENTRY) malloc(sizeof(*replay_entry) + 128);
    if (replay_entry == NULL)
      return NULL;

    replay_entry->data = (char *) (entry + 1);
    memcpy(replay_entry->data, naluHeader, sizeof(naluHeader));
    h264_stream->sps->profile_idc = H264_PROFILE_HIGH;
    replay_entry->length = write_nal_unit(h264_stream, replay_entry->data+4, 124) + 4;

    replay_entry->next = entry;
    entry = replay_entry;
    replay_sps = 2;
  } else if ((entry->data[4] & 0x1F) == NAL_UNIT_TYPE_SPS) {
    read_nal_unit(h264_stream, entry->data+4, entry->length-4);

    // Some decoders rely on H264 level to decide how many buffers are needed
    // Since we only need one frame buffered, we'll set level as low as we can
    // for known resolution combinations. Otherwise leave the profile alone (currently 5.0)
    if (initial_width == 1280 && initial_height == 720)
      h264_stream->sps->level_idc = 32; // Max 5 buffered frames at 1280x720x60
    else if (initial_width = 1920 && initial_height == 1080)
      h264_stream->sps->level_idc = 42; // Max 4 buffered frames at 1920x1080x60

    // Some decoders requires a reference frame count of 1 to decode successfully.
    h264_stream->sps->num_ref_frames = 1;

    // GFE 2.5.11 changed the SPS to add additional extensions
    // Some devices don't like these so we remove them here.
    h264_stream->sps->vui.video_signal_type_present_flag = 0;
    h264_stream->sps->vui.chroma_loc_info_present_flag = 0;

    if ((flags & GS_SPS_BITSTREAM_FIXUP) == GS_SPS_BITSTREAM_FIXUP) {
      // The SPS that comes in the current H264 bytestream doesn't set the bitstream_restriction_flag
      // or the max_dec_frame_buffering which increases decoding latency on some devices
      // log2_max_mv_length_horizontal and log2_max_mv_length_vertical are set to more
      // conservite values by GFE 25.11. We'll let those values stand.
      if (!h264_stream->sps->vui.bitstream_restriction_flag) {
        h264_stream->sps->vui.bitstream_restriction_flag = 1;
        h264_stream->sps->vui.motion_vectors_over_pic_boundaries_flag = 1;
        h264_stream->sps->vui.max_bits_per_mb_denom = 1;
        h264_stream->sps->vui.log2_max_mv_length_horizontal = 16;
        h264_stream->sps->vui.log2_max_mv_length_vertical = 16;
        h264_stream->sps->vui.num_reorder_frames = 0;
      }

      // Some devices throw errors if max_dec_frame_buffering < num_ref_frames
      h264_stream->sps->vui.max_dec_frame_buffering = 1;

      // These values are the default for the fields, but they are more aggressive
      // than what GFE sends in 2.5.11, but it doesn't seem to cause picture problems.
      h264_stream->sps->vui.max_bytes_per_pic_denom = 2;
      h264_stream->sps->vui.max_bits_per_mb_denom = 1;
    } else // Devices that didn't/couldn't get bitstream restrictions before GFE 2.5.11 will continue to not receive them now
      h264_stream->sps->vui.bitstream_restriction_flag = 0;

    if ((flags & GS_SPS_BASELINE_HACK) == GS_SPS_BASELINE_HACK && !replay_sps)
      h264_stream->sps->profile_idc = H264_PROFILE_BASELINE;

    PLENTRY sps_entry = (PLENTRY) malloc(sizeof(*sps_entry) + 128);
    if (sps_entry == NULL)
      return NULL;

    PLENTRY next = entry->next;
    free(entry);
    sps_entry->data = (char*) (sps_entry + 1);
    memcpy(sps_entry->data, naluHeader, sizeof(naluHeader));
    sps_entry->length = write_nal_unit(h264_stream, sps_entry->data+4, 124) + 4;
    sps_entry->next = next;
    entry = sps_entry;
  } else if ((entry->data[4] & 0x1F) == NAL_UNIT_TYPE_PPS) {
    if ((flags & GS_SPS_BASELINE_HACK) == GS_SPS_BASELINE_HACK && !replay_sps)
      replay_sps = 1;

  }
  *head = entry;
  return entry;
}
                                                                                                                                                                                                                                                                        moonlight-embedded-2.1.1/libgamestream/sps.h                                                        0000664 0000000 0000000 00000001613 12563604362 0021044 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#include "limelight-common/Limelight.h"

#define GS_SPS_BITSTREAM_FIXUP 0x01
#define GS_SPS_BASELINE_HACK 0x02

void gs_sps_init();
PLENTRY gs_sps_fix(PLENTRY *entry, int flags);
                                                                                                                     moonlight-embedded-2.1.1/libgamestream/xml.c                                                        0000664 0000000 0000000 00000010132 12563604362 0021026 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#include "xml.h"
#include "errors.h"

#include <expat.h>
#include <string.h>

static XML_Parser parser;

struct xml_query {
  char *memory;
  size_t size;
  int start;
  void* data;
};

static void XMLCALL _xml_start_element(void *userData, const char *name, const char **atts) {
  struct xml_query *search = (struct xml_query*) userData;
  if (strcmp(search->data, name) == 0)
    search->start++;
}

static void XMLCALL _xml_end_element(void *userData, const char *name) {
  struct xml_query *search = (struct xml_query*) userData;
  if (strcmp(search->data, name) == 0)
    search->start--;
}

static void XMLCALL _xml_start_applist_element(void *userData, const char *name, const char **atts) {
  struct xml_query *search = (struct xml_query*) userData;
  if (strcmp("App", name) == 0) {
    PAPP_LIST app = malloc(sizeof(APP_LIST));
    if (app == NULL)
      return;

    app->id = 0;
    app->name = NULL;
    app->next = (PAPP_LIST) search->data;
    search->data = app;
  } else if (strcmp("ID", name) == 0 || strcmp("AppTitle", name) == 0) {
    search->memory = malloc(1);
    search->size = 0;
    search->start = 1;
  }
}

static void XMLCALL _xml_end_applist_element(void *userData, const char *name) {
  struct xml_query *search = (struct xml_query*) userData;
  if (search->start) {
    PAPP_LIST list = (PAPP_LIST) search->data;
    if (list == NULL)
      return;

    if (strcmp("ID", name) == 0) {
        list->id = atoi(search->memory);
        free(search->memory);
    } else if (strcmp("AppTitle", name) == 0) {
        list->name = search->memory;
    }
    search->start = 0;
  }
}

static void XMLCALL _xml_write_data(void *userData, const XML_Char *s, int len) {
  struct xml_query *search = (struct xml_query*) userData;
  if (search->start > 0) {
    search->memory = realloc(search->memory, search->size + len + 1);
    if(search->memory == NULL)
      return;
  
    memcpy(&(search->memory[search->size]), s, len);
    search->size += len;
    search->memory[search->size] = 0;
  }
}

int xml_search(char* data, size_t len, char* node, char** result) {
  struct xml_query search;
  search.data = node;
  search.start = 0;
  search.memory = calloc(1, 1);
  search.size = 0;
  XML_Parser parser = XML_ParserCreate("UTF-8");
  XML_SetUserData(parser, &search);
  XML_SetElementHandler(parser, _xml_start_element, _xml_end_element);
  XML_SetCharacterDataHandler(parser, _xml_write_data);
  if (! XML_Parse(parser, data, len, 1)) {
    int code = XML_GetErrorCode(parser);
    gs_error = XML_ErrorString(code);
    XML_ParserFree(parser);
    free(search.memory);
    return GS_INVALID;
  } else if (search.memory == NULL) {
    XML_ParserFree(parser);
    return GS_OUT_OF_MEMORY;
  }

  XML_ParserFree(parser);
  *result = search.memory;
  
  return GS_OK;
}

int xml_applist(char* data, size_t len, PAPP_LIST *app_list) {
  struct xml_query query;
  query.memory = calloc(1, 1);
  query.size = 0;
  query.start = 0;
  query.data = NULL;
  XML_Parser parser = XML_ParserCreate("UTF-8");
  XML_SetUserData(parser, &query);
  XML_SetElementHandler(parser, _xml_start_applist_element, _xml_end_applist_element);
  XML_SetCharacterDataHandler(parser, _xml_write_data);
  if (! XML_Parse(parser, data, len, 1)) {
    int code = XML_GetErrorCode(parser);
    gs_error = XML_ErrorString(code);
    XML_ParserFree(parser);
    return GS_INVALID;
  }

  XML_ParserFree(parser);
  *app_list = (PAPP_LIST) query.data;

  return GS_OK;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                      moonlight-embedded-2.1.1/libgamestream/xml.h                                                        0000664 0000000 0000000 00000001740 12563604362 0021040 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */
#pragma once

#include <stdio.h>

typedef struct _APP_LIST {
  char* name;
  int id;
  struct _APP_LIST *next;
} APP_LIST, *PAPP_LIST;

int xml_search(char* data, size_t len, char* node, char** result);
int xml_applist(char* data, size_t len, PAPP_LIST *app_list);
                                moonlight-embedded-2.1.1/mappings/                                                                  0000775 0000000 0000000 00000000000 12563604362 0017067 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        moonlight-embedded-2.1.1/mappings/default.conf                                                      0000664 0000000 0000000 00000001040 12563604362 0021355 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        abs_x = 0
abs_y = 1
abs_z = 2
abs_rx = 3
abs_ry = 4
abs_rz = 5
abs_deadzone = 0
abs_dpad_y = 16
abs_dpad_x = 17
reverse_x = false
reverse_y = true
reverse_rx = false
reverse_ry = true
reverse_dpad_y = false
reverse_dpad_x = false
reverse_z = false
reverse_rz = false
btn_south = 304
btn_east = 305
btn_north = 307
btn_west = 308
btn_select = 314
btn_start = 315
btn_mode = 316
btn_thumbl = 317
btn_thumbr = 318
btn_tl = 310
btn_tr = 311
btn_tl2 = 312
btn_tr2 = 313
btn_dpad_up = 544
btn_dpad_down = 545
btn_dpad_left = 546
btn_dpad_right = 547
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                moonlight-embedded-2.1.1/mappings/dualshock4.conf                                                   0000664 0000000 0000000 00000001040 12563604362 0021772 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        abs_x = 0
abs_y = 1
abs_z = 3
abs_rx = 2
abs_ry = 5
abs_rz = 4
abs_deadzone = 32544
abs_dpad_x = 16
abs_dpad_y = 17
reverse_x = false
reverse_y = true
reverse_rx = false
reverse_ry = true
reverse_dpad_x = false
reverse_dpad_y = false
reverse_z = false
reverse_rz = false
btn_west = 304
btn_south = 305
btn_north = 307
btn_east = 306
btn_select = 312
btn_start = 313
btn_mode = 316
btn_thumbl = 314
btn_thumbr = 315
btn_tl = 308
btn_tr = 309
btn_tl2 = 310
btn_tr2 = 311
btn_dpad_up = -1
btn_dpad_down = -1
btn_dpad_left = -1
btn_dpad_right = -1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                moonlight-embedded-2.1.1/mappings/rumblepad2.conf                                                   0000664 0000000 0000000 00000000774 12563604362 0022003 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        abs_x = 0
abs_y = 1
abs_z = -1
reverse_x = false
reverse_y = true
abs_rx = 2
abs_ry = 5
abs_rz = -1
reverse_rx = false
reverse_ry = true
abs_deadzone = -27744
abs_dpad_x = 16
abs_dpad_y = 17
reverse_dpad_x = false
reverse_dpad_y = false
btn_north = 291
btn_east = 290
btn_south = 289
btn_west = 288
btn_select = 297
btn_start = 296
btn_mode = 0
btn_thumbl = 298
btn_thumbr = 299
btn_tl = 292
btn_tr = 293
btn_tl2 = 294
btn_tr2 = 295
btn_dpad_up = -1
btn_dpad_down = -1
btn_dpad_left = -1
btn_dpad_right = -1
    moonlight-embedded-2.1.1/mappings/xbox360.conf                                                      0000664 0000000 0000000 00000001033 12563604362 0021144 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        abs_x = 0
abs_y = 1
abs_z = 10
abs_rx = 3
abs_ry = 4
abs_rz = 9
abs_deadzone = 0
abs_dpad_x = 16
abs_dpad_y = 17
reverse_x = false
reverse_y = true
reverse_rx = false
reverse_ry = true
reverse_dpad_x = false
reverse_dpad_y = false
reverse_z = false
reverse_rz = false
btn_east = 305
btn_south = 304
btn_north = 308
btn_west = 307
btn_select = 314
btn_start = 315
btn_mode = 316
btn_thumbl = 317
btn_thumbr = 318
btn_tl = 310
btn_tr = 311
btn_tl2 = -1
btn_tr2 = -1
btn_dpad_up = -1
btn_dpad_down = -1
btn_dpad_left = -1
btn_dpad_right = -1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     moonlight-embedded-2.1.1/moonlight.conf                                                             0000664 0000000 0000000 00000003365 12563604362 0020127 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        ## Hostname or IP-address of host to connect to
## By default host is autodiscovered using mDNS
#address = 1.2.3.4

## Video streaming configuration
#width = 1280
#height = 720
#fps = 60

## Bitrate depends by default on resolution and fps
## Set to -1 to enable default
## 20Mbps (20000) for 1080p (60 fps)
## 10Mbps (10000) for 1080p or 60 fps
## 5Mbps (5000) for lower resolution or fps
#bitrate = -1

## Size of network packets should be lower than MTU
#packetsize = 1024

## Default started application on host
#app = Steam

## Default used mapping for streaming
## Searched for in $XDG_DATA_DIRS/moonlight or /usr/share/moonlight and /usr/local/share/moonlight
## Mapping can also be user overrided in $XDG_CONFIG_DIR/moonlight or ~/.config/moonlight or current directory
#mapping = mappings/default.conf

## Enable selected input devices
## By default all available input devices should be used
## Only evdev devices /dev/input/event* are allowed
## To use a different mapping then default another mapping should be declared above the input
#input = /dev/input/event1

## Let GFE change graphical game settings for optimal performance and quality
#sops = true

## Play audio on host instead of streaming to client
#localaudio = false

## Select audio device to play sound on
#audio = sysdefault

## Select the audio and video decoder to use
## default - autodetect
## omx - hardware video decoder for Raspberry Pi
## imx - hardware video decoder for i.MX6 devices
## sdl - software decoder
## fake - save to file (only available in debug builds)
#platform = default

## Directory to store encryption keys
## By default keys are stored in $XDG_CACHE_DIR/moonlight or ~/.cache/moonlight
#keydir = /dir/to/keys

## Load additional configuration files
#config = /path/to/config
                                                                                                                                                                                                                                                                           moonlight-embedded-2.1.1/src/                                                                       0000775 0000000 0000000 00000000000 12563604362 0016040 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        moonlight-embedded-2.1.1/src/a.out                                                                  0000775 0000000 0000000 00000013660 12563604362 0017022 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        ELF               4          4    (      4   44               4  44                     	  	           	    $           	                 H  HHD   D         Ptdt  tt4   4         Qtd                          /lib/ld-linux.so.2           GNU                        GNU C>1
?R/-S                       K                              3               !                 L      libc.so.6 _IO_stdin_used printf __libc_start_main __gmon_start__ GLIBC_2.0                      ii
   B               S     t.   [         5%    %h    %h   %h   1^PTRh0hQVhKfffffff$ffffff-v    tUht& -t    tUPht& '    = uU|fuv     tUPuUSEfEU)1)   9}
      E  9~t
         E 9}t
         tZ  U9}	       )E))   )       )f ZUM9~	       ) ))   )       )f []L$qUQ     )j kPj h\,PEj RPhe P h PRhe  P  h  PRhe P PRh\m  P}  PRh\1j HPj h\	P"j RPhe P h  PRhe  P  h PRhe P PRh\J  PZ  PRh\MafUWVSW  l$ )t%1    t$,t$,U9u[^_]v   S[  [           %d > %d
 %d > %d (%d)
  ;0      LL   p      \            zR |         @    FJtx ?;*2$"$   @   P   AB
DGA   ,   h   7   D Gu Cu|p AC   H      ]    AAAAN i$D(D,A0M GAAAA                                
   4                  o      
   L                                  |   t            oTo   oH                                                                    GCC: (GNU) 5.1.0  .symtab .strtab .shstrtab .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame_hdr .eh_frame .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss .comment                      4          H          h                                        H          T          t     	     |     
                               
     4          H          t                                                                                                                                                   @     
 5   p     
 H        
 ^        m                 
                                                                                              
        #  0    
 3       ;              W  0   
 m         x               P   
           4        P       T               X                            L                    ]    
                 
   H     $       *        6  K   
 ;       ?              S       _              y         init.c crtstuff.c __JCR_LIST__ deregister_tm_clones register_tm_clones __do_global_dtors_aux completed.6859 __do_global_dtors_aux_fini_array_entry frame_dummy __frame_dummy_init_array_entry test.c __FRAME_END__ __JCR_END__ __init_array_end _DYNAMIC __init_array_start _GLOBAL_OFFSET_TABLE_ __libc_csu_fini reverse _ITM_deregisterTMCloneTable __x86.get_pc_thunk.bx data_start printf@@GLIBC_2.0 convert _edata _fini min max __data_start flat __gmon_start__ __dso_handle _IO_stdin_used __libc_start_main@@GLIBC_2.0 __libc_csu_init _end _start _fp_hw range __bss_start main avg _Jv_RegisterClasses __TMC_END__ _ITM_registerTMCloneTable _init                                                   44                    #         HH                     1         hh  $                  D   o                      N           P               V           L                  ^   o   HH  
                k   o   TT                   z   	      tt                     	   B   ||                            #                             @                              2                          44                             HH  +                           tt  4                                                        	                             	                             	                             	                           
                            
                            
                             
                          0       
                                 
                                        .         	                                                                                                                 moonlight-embedded-2.1.1/src/audio.h                                                                0000664 0000000 0000000 00000001644 12563604362 0017317 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#include "limelight-common/Limelight.h"

extern const char* audio_device;

extern AUDIO_RENDERER_CALLBACKS audio_callbacks_alsa;
#ifdef HAVE_SDL
extern AUDIO_RENDERER_CALLBACKS audio_callbacks_sdl;
#endif                                                                                            moonlight-embedded-2.1.1/src/audio/                                                                 0000775 0000000 0000000 00000000000 12563604362 0017141 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        moonlight-embedded-2.1.1/src/audio/alsa.c                                                           0000664 0000000 0000000 00000007302 12563604362 0020227 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#include "../audio.h"

#include <stdio.h>
#include <opus.h>
#include <alsa/asoundlib.h>

#define CHECK_RETURN(f) if ((rc = f) < 0) { printf("Alsa error code %d\n", rc); exit(-1); }

#define SAMPLE_RATE 48000
#define CHANNEL_COUNT 2
#define FRAME_SIZE 240

const char* audio_device = "sysdefault";

static snd_pcm_t *handle;
static OpusDecoder* decoder;
static short pcmBuffer[FRAME_SIZE * CHANNEL_COUNT];

static void alsa_renderer_init() {
  int rc;
  decoder = opus_decoder_create(SAMPLE_RATE, CHANNEL_COUNT, &rc);

  snd_pcm_hw_params_t *hw_params;
  snd_pcm_sw_params_t *sw_params;
  snd_pcm_uframes_t period_size = FRAME_SIZE * CHANNEL_COUNT * 2;
  snd_pcm_uframes_t buffer_size = 12 * period_size;
  unsigned int sampleRate = SAMPLE_RATE;

  /* Open PCM device for playback. */
  CHECK_RETURN(snd_pcm_open(&handle, audio_device, SND_PCM_STREAM_PLAYBACK, SND_PCM_NONBLOCK))

  /* Set hardware parameters */
  CHECK_RETURN(snd_pcm_hw_params_malloc(&hw_params));
  CHECK_RETURN(snd_pcm_hw_params_any(handle, hw_params));
  CHECK_RETURN(snd_pcm_hw_params_set_access(handle, hw_params, SND_PCM_ACCESS_RW_INTERLEAVED));
  CHECK_RETURN(snd_pcm_hw_params_set_format(handle, hw_params, SND_PCM_FORMAT_S16_LE));
  CHECK_RETURN(snd_pcm_hw_params_set_rate_near(handle, hw_params, &sampleRate, NULL));
  CHECK_RETURN(snd_pcm_hw_params_set_channels(handle, hw_params, CHANNEL_COUNT));
  CHECK_RETURN(snd_pcm_hw_params_set_buffer_size_near(handle, hw_params, &buffer_size));
  CHECK_RETURN(snd_pcm_hw_params_set_period_size_near(handle, hw_params, &period_size, NULL));
  CHECK_RETURN(snd_pcm_hw_params(handle, hw_params));
  snd_pcm_hw_params_free(hw_params);

  /* Set software parameters */
  CHECK_RETURN(snd_pcm_sw_params_malloc(&sw_params));
  CHECK_RETURN(snd_pcm_sw_params_current(handle, sw_params));
  CHECK_RETURN(snd_pcm_sw_params_set_start_threshold(handle, sw_params, buffer_size - period_size));
  CHECK_RETURN(snd_pcm_sw_params_set_avail_min(handle, sw_params, period_size));
  CHECK_RETURN(snd_pcm_sw_params(handle, sw_params));
  snd_pcm_sw_params_free(sw_params);

  CHECK_RETURN(snd_pcm_prepare(handle));
}

static void alsa_renderer_cleanup() {
  if (decoder != NULL)
    opus_decoder_destroy(decoder);

  if (handle != NULL) {
    snd_pcm_drain(handle);
    snd_pcm_close(handle);
  }
}

static void alsa_renderer_decode_and_play_sample(char* data, int length) {
  int decodeLen = opus_decode(decoder, data, length, pcmBuffer, FRAME_SIZE, 0);
  if (decodeLen > 0) {
    int rc = snd_pcm_writei(handle, pcmBuffer, decodeLen);
    if (rc == -EPIPE)
      snd_pcm_recover(handle, rc, 1);

    if (rc<0)
      printf("Alsa error from writei: %d\n", rc);
    else if (decodeLen != rc)
      printf("Alsa shortm write, write %d frames\n", rc);
  } else {
    printf("Opus error from decode: %d\n", decodeLen);
  }
}

AUDIO_RENDERER_CALLBACKS audio_callbacks_alsa = {
  .init = alsa_renderer_init,
  .cleanup = alsa_renderer_cleanup,
  .decodeAndPlaySample = alsa_renderer_decode_and_play_sample,
  .capabilities = CAPABILITY_DIRECT_SUBMIT,
};
                                                                                                                                                                                                                                                                                                                              moonlight-embedded-2.1.1/src/audio/sdl.c                                                            0000664 0000000 0000000 00000004477 12563604362 0020103 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#include "../audio.h"

#include <SDL.h>
#include <SDL_audio.h>

#include <stdio.h>
#include <opus.h>

#define SAMPLE_RATE 48000
#define CHANNEL_COUNT 2
#define FRAME_SIZE 240

static OpusDecoder* decoder;
static short pcmBuffer[FRAME_SIZE * CHANNEL_COUNT];
static SDL_AudioDeviceID dev;

static void sdl_renderer_init() {
  int rc;
  decoder = opus_decoder_create(SAMPLE_RATE, CHANNEL_COUNT, &rc);

  SDL_InitSubSystem(SDL_INIT_AUDIO);

  SDL_AudioSpec want, have;
  SDL_zero(want);
  want.freq = SAMPLE_RATE;
  want.format = AUDIO_S16LSB;
  want.channels = CHANNEL_COUNT;
  want.samples = 4096;

  dev = SDL_OpenAudioDevice(NULL, 0, &want, &have, SDL_AUDIO_ALLOW_FORMAT_CHANGE);
  if (dev == 0) {
    printf("Failed to open audio: %s\n", SDL_GetError());
  } else {
    if (have.format != want.format)  // we let this one thing change.
      printf("We didn't get requested audio format.\n");
    SDL_PauseAudioDevice(dev, 0);  // start audio playing.
  }
}

static void sdl_renderer_cleanup() {
  if (decoder != NULL)
    opus_decoder_destroy(decoder);

  SDL_CloseAudioDevice(dev);
}

static void sdl_renderer_decode_and_play_sample(char* data, int length) {
  int decodeLen = opus_decode(decoder, data, length, pcmBuffer, FRAME_SIZE, 0);
  if (decodeLen > 0) {
    SDL_QueueAudio(dev, pcmBuffer, decodeLen * CHANNEL_COUNT * sizeof(short));
  } else {
    printf("Opus error from decode: %d\n", decodeLen);
  }
}

AUDIO_RENDERER_CALLBACKS audio_callbacks_sdl = {
  .init = sdl_renderer_init,
  .cleanup = sdl_renderer_cleanup,
  .decodeAndPlaySample = sdl_renderer_decode_and_play_sample,
  .capabilities = CAPABILITY_DIRECT_SUBMIT,
};
                                                                                                                                                                                                 moonlight-embedded-2.1.1/src/config.c                                                               0000664 0000000 0000000 00000022024 12563604362 0017451 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#include "input/evdev.h"
#include "config.h"
#include "audio.h"

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <getopt.h>

#define MOONLIGHT_PATH "/moonlight"
#define USER_PATHS "."
#define DEFAULT_CONFIG_DIR "/.config"
#define DEFAULT_CACHE_DIR "/.cache"

#define write_config_string(fd, key, value) fprintf(fd, "%s = %s\n", key, value)
#define write_config_int(fd, key, value) fprintf(fd, "%s = %d\n", key, value)
#define write_config_bool(fd, key, value) fprintf(fd, "%s = %s\n", key, value?"true":"false");

bool inputAdded = false;
static bool mapped = true;

static struct option long_options[] = {
  {"720", no_argument, NULL, 'a'},
  {"1080", no_argument, NULL, 'b'},
  {"width", required_argument, NULL, 'c'},
  {"height", required_argument, NULL, 'd'},
  {"30fps", no_argument, NULL, 'e'},
  {"60fps", no_argument, NULL, 'f'},
  {"bitrate", required_argument, NULL, 'g'},
  {"packetsize", required_argument, NULL, 'h'},
  {"app", required_argument, NULL, 'i'},
  {"input", required_argument, NULL, 'j'},
  {"mapping", required_argument, NULL, 'k'},
  {"nosops", no_argument, NULL, 'l'},
  {"audio", required_argument, NULL, 'm'},
  {"localaudio", no_argument, NULL, 'n'},
  {"config", required_argument, NULL, 'o'},
  {"platform", required_argument, 0, 'p'},
  {"save", required_argument, NULL, 'q'},
  {"keydir", required_argument, NULL, 'r'},
  {"remote", no_argument, NULL, 's'},
  {0, 0, 0, 0},
};

char* get_path(char* name, char* extra_data_dirs) {
  const char *xdg_config_dir = getenv("XDG_CONFIG_DIR");
  const char *home_dir = getenv("HOME");

  if (access(name, R_OK) != -1) {
      return name;
  }

  if (!extra_data_dirs)
    extra_data_dirs = "/usr/share:/usr/local/share";
  if (!xdg_config_dir)
    xdg_config_dir = home_dir;

  char *data_dirs = malloc(strlen(USER_PATHS) + 1 + strlen(xdg_config_dir) + 1 + strlen(home_dir) + 1 + strlen(DEFAULT_CONFIG_DIR) + 1 + strlen(extra_data_dirs) + 2);
  sprintf(data_dirs, USER_PATHS ":%s:%s/" DEFAULT_CONFIG_DIR ":%s/", xdg_config_dir, home_dir, extra_data_dirs);

  char *path = malloc(strlen(data_dirs)+strlen(MOONLIGHT_PATH)+strlen(name)+2);
  if (path == NULL) {
    fprintf(stderr, "Not enough memory\n");
    exit(-1);
  }

  char* data_dir = data_dirs;
  char* end;
  do {
    end = strstr(data_dir, ":");
    int length = end != NULL?end - data_dir:strlen(data_dir);
    memcpy(path, data_dir, length);
    if (path[0] == '/')
      sprintf(path+length, MOONLIGHT_PATH "/%s", name);
    else
      sprintf(path+length, "/%s", name);

    if(access(path, R_OK) != -1) {
      free(data_dirs);
      return path;
    }

    data_dir = end + 1;
  } while (end != NULL);

  free(data_dirs);
  free(path);
  return NULL;
}

static void parse_argument(int c, char* value, PCONFIGURATION config) {
  switch (c) {
  case 'a':
    config->stream.width = 1280;
    config->stream.height = 720;
    break;
  case 'b':
    config->stream.width = 1920;
    config->stream.height = 1080;
    break;
  case 'c':
    config->stream.width = atoi(value);
    break;
  case 'd':
    config->stream.height = atoi(value);
    break;
  case 'e':
    config->stream.fps = 30;
    break;
  case 'f':
    config->stream.fps = 60;
    break;
  case 'g':
    config->stream.bitrate = atoi(value);
    break;
  case 'h':
    config->stream.packetSize = atoi(value);
    break;
  case 'i':
    config->app = value;
    break;
  case 'j':
    if (config->inputsCount >= MAX_INPUTS) {
      perror("Too many inputs specified");
      exit(-1);
    }
    config->inputs[config->inputsCount].path = value;
    config->inputs[config->inputsCount].mapping = value;
    config->inputsCount++;
    inputAdded = true;
    mapped = true;
    break;
  case 'k':
    config->mapping = get_path(value, getenv("XDG_DATA_DIRS"));
    if (config->mapping == NULL) {
      fprintf(stderr, "Unable to open custom mapping file: %s\n", value);
      exit(-1);
    }
    mapped = false;
    break;
  case 'l':
    config->sops = false;
    break;
  case 'm':
    audio_device = value;
    break;
  case 'n':
    config->localaudio = true;
    break;
  case 'o':
    if (!config_file_parse(value, config))
      exit(EXIT_FAILURE);

    break;
  case 'p':
    config->platform = value;
    break;
  case 'q':
    config->config_file = value;
    break;
  case 'r':
    strcpy(config->key_dir, value);
    break;
  case 's':
    config->stream.remote = 1;
    break;
  case 1:
    if (config->action == NULL)
      config->action = value;
    else if (config->address == NULL)
      config->address = value;
    else {
      perror("Too many options");
      exit(-1);
    }
  }
}

bool config_file_parse(char* filename, PCONFIGURATION config) {
  FILE* fd = fopen(filename, "r");
  if (fd == NULL) {
    fprintf(stderr, "Can't open configuration file: %s\n", filename);
    return false;
  }

  char *line = NULL;
  size_t len = 0;

  while (getline(&line, &len, fd) != -1) {
    char *key = NULL, *value = NULL;
    if (sscanf(line, "%ms = %ms", &key, &value) == 2) {
      if (strcmp(key, "address") == 0) {
        config->address = value;
      } else if (strcmp(key, "sops") == 0) {
        config->sops = strcmp("true", value) == 0;
      } else if (strcmp(key, "localaudio") == 0) {
        config->localaudio = strcmp("true", value) == 0;
      } else {
        for (int i=0;long_options[i].name != NULL;i++) {
          if (long_options[i].has_arg == required_argument && strcmp(long_options[i].name, key) == 0) {
            parse_argument(long_options[i].val, value, config);
          }
        }
      }
    }
  }
  return true;
}

void config_save(char* filename, PCONFIGURATION config) {
  FILE* fd = fopen(filename, "w");
  if (fd == NULL) {
    fprintf(stderr, "Can't open configuration file: %s\n", filename);
    exit(EXIT_FAILURE);
  }

  if (config->stream.width != 1280)
    write_config_int(fd, "width", config->stream.width);
  if (config->stream.height != 720)
    write_config_int(fd, "height", config->stream.height);
  if (config->stream.fps != 60)
    write_config_int(fd, "fps", config->stream.fps);
  if (config->stream.bitrate != -1)
    write_config_int(fd, "bitrate", config->stream.bitrate);
  if (config->stream.packetSize != 1024)
    write_config_int(fd, "packetsize", config->stream.packetSize);
  if (!config->sops)
    write_config_bool(fd, "sops", config->sops);
  if (config->localaudio)
    write_config_bool(fd, "localaudio", config->localaudio);

  if (strcmp(config->app, "Steam") != 0)
    write_config_string(fd, "app", config->app);

  fclose(fd);
}

void config_parse(int argc, char* argv[], PCONFIGURATION config) {
  config->stream.width = 1280;
  config->stream.height = 720;
  config->stream.fps = 60;
  config->stream.bitrate = -1;
  config->stream.packetSize = 1024;
  config->stream.remote = 0;

  config->platform = "default";
  config->app = "Steam";
  config->action = NULL;
  config->address = NULL;
  config->config_file = NULL;
  config->sops = true;
  config->localaudio = false;

  config->inputsCount = 0;
  config->mapping = get_path("mappings/default.conf", getenv("XDG_DATA_DIRS"));
  config->key_dir[0] = 0;

  char* config_file = get_path("moonlight.conf", "/etc");
  if (config_file)
    config_file_parse(config_file, config);
  
  if (argc == 2 && access(argv[1], F_OK) == 0) {
    config->action = "stream";
    if (!config_file_parse(argv[1], config))
      exit(EXIT_FAILURE);

  } else {
    int option_index = 0;
    int c;
    while ((c = getopt_long_only(argc, argv, "-abc:d:efg:h:i:j:k:lm:no:p:q:r:s", long_options, &option_index)) != -1) {
      parse_argument(c, optarg, config);
    }
  }

  if (config->config_file != NULL)
    config_save(config->config_file, config);

  if (config->key_dir[0] == 0x0) {
    const char *xdg_cache_dir = getenv("XDG_CACHE_DIR");
    if (xdg_cache_dir != NULL)
      sprintf(config->key_dir, "%s" MOONLIGHT_PATH, xdg_cache_dir);
    else {
      const char *home_dir = getenv("HOME");
      sprintf(config->key_dir, "%s" DEFAULT_CACHE_DIR MOONLIGHT_PATH, home_dir);
    }
  }

  if (config->stream.bitrate == -1) {
    if (config->stream.height >= 1080 && config->stream.fps >= 60)
      config->stream.bitrate = 20000;
    else if (config->stream.height >= 1080 || config->stream.fps >= 60)
      config->stream.bitrate = 10000;
    else
      config->stream.bitrate = 5000;
  }

  if (inputAdded && !mapped) {
    fprintf(stderr, "Mapping option should be followed by the input to be mapped.\n");
    exit(-1);
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            moonlight-embedded-2.1.1/src/config.h                                                               0000664 0000000 0000000 00000002464 12563604362 0017464 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#include "limelight-common/Limelight.h"

#include <stdbool.h>

#define MAX_INPUTS 6

struct input_config {
  char* path;
  char* mapping;
};

typedef struct _CONFIGURATION {
  STREAM_CONFIGURATION stream;
  char* app;
  char* action;
  char* address;
  char* mapping;
  char* platform;
  char* config_file;
  char key_dir[4096];
  bool sops;
  bool localaudio;
  struct input_config inputs[MAX_INPUTS];
  int inputsCount;
} CONFIGURATION, *PCONFIGURATION;

bool inputAdded;

bool config_file_parse(char* filename, PCONFIGURATION config);
void config_parse(int argc, char* argv[], PCONFIGURATION config);
                                                                                                                                                                                                            moonlight-embedded-2.1.1/src/connection.c                                                           0000664 0000000 0000000 00000002467 12563604362 0020354 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#include "connection.h"
#include "global.h"

#include <stdio.h>

void connection_connection_terminated()
{
  quit();
}

void connection_display_message(char *msg)
{
  printf("%s\n", msg);
}

void connection_display_transient_message(char *msg)
{
  printf("%s\n", msg);
}

CONNECTION_LISTENER_CALLBACKS connection_callbacks = {
  .stageStarting = NULL,
  .stageComplete = NULL,
  .stageFailed = NULL,
  .connectionStarted = NULL,
  .connectionTerminated = connection_connection_terminated,
  .displayMessage = connection_display_message,
  .displayTransientMessage = connection_display_transient_message,
};
                                                                                                                                                                                                         moonlight-embedded-2.1.1/src/connection.h                                                           0000664 0000000 0000000 00000001474 12563604362 0020356 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#include "limelight-common/Limelight.h"

extern CONNECTION_LISTENER_CALLBACKS connection_callbacks;
                                                                                                                                                                                                    moonlight-embedded-2.1.1/src/global.c                                                               0000664 0000000 0000000 00000001526 12563604362 0017450 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#include <signal.h>
#include <pthread.h>

pthread_t main_thread_id;

void quit() {
  pthread_kill(main_thread_id, SIGTERM);
}
                                                                                                                                                                          moonlight-embedded-2.1.1/src/global.h                                                               0000664 0000000 0000000 00000001435 12563604362 0017454 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#include <pthread.h>

extern pthread_t main_thread_id;

void quit();
                                                                                                                                                                                                                                   moonlight-embedded-2.1.1/src/input/                                                                 0000775 0000000 0000000 00000000000 12563604362 0017177 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        moonlight-embedded-2.1.1/src/input/cec.c                                                            0000664 0000000 0000000 00000006367 12563604362 0020111 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#ifdef HAVE_LIBCEC

#include "limelight-common/Limelight.h"

#include <ceccloader.h>

#define KEY_LEFT 0x25
#define KEY_UP 0x26
#define KEY_RIGHT 0x27
#define KEY_DOWN 0x28
#define KEY_ENTER 0x0D
#define KEY_TAB 0x09
#define KEY_ESC 0x1B

static libcec_configuration g_config;
static char                 g_strPort[50] = { 0 };
static libcec_interface_t   g_iface;
static ICECCallbacks        g_callbacks;

static int on_cec_keypress(void* userdata, const cec_keypress key) {
  char value;
  switch (key.keycode) {
    case CEC_USER_CONTROL_CODE_UP:
      value = KEY_UP;
      break;
    case CEC_USER_CONTROL_CODE_DOWN:
      value = KEY_DOWN;
      break;
    case CEC_USER_CONTROL_CODE_LEFT:
      value = KEY_LEFT;
      break;
    case CEC_USER_CONTROL_CODE_RIGHT:
      value = KEY_RIGHT;
      break;
    case CEC_USER_CONTROL_CODE_ENTER:
    case CEC_USER_CONTROL_CODE_SELECT:
      value = KEY_ENTER;
      break;
    case CEC_USER_CONTROL_CODE_ROOT_MENU:
      value = KEY_TAB;
      break;
    case CEC_USER_CONTROL_CODE_AN_RETURN:
    case CEC_USER_CONTROL_CODE_EXIT:
      value = KEY_ESC;
      break;
    default:
      value = 0;
      break;
  }
  
  if (value != 0) {
    short code = 0x80 << 8 | value;
    LiSendKeyboardEvent(code, (key.duration > 0)?KEY_ACTION_UP:KEY_ACTION_DOWN, 0);
  }
}

void cec_init() {
  libcecc_reset_configuration(&g_config);
  g_config.clientVersion = LIBCEC_VERSION_CURRENT;
  g_config.bActivateSource = 0;
  g_callbacks.CBCecKeyPress = &on_cec_keypress;
  g_config.callbacks = &g_callbacks;
  snprintf(g_config.strDeviceName, sizeof(g_config.strDeviceName), "Moonlight");
  g_config.callbacks = &g_callbacks;
  g_config.deviceTypes.types[0] = CEC_DEVICE_TYPE_PLAYBACK_DEVICE;
  
  if (libcecc_initialise(&g_config, &g_iface, NULL) != 1) {
    fprintf(stderr, "Failed to initialize libcec interface\n");
    fflush(stderr);
    return;
  }
  
  g_iface.init_video_standalone(g_iface.connection);
  
  cec_adapter devices[10];
  int8_t iDevicesFound = g_iface.find_adapters(g_iface.connection, devices, sizeof(devices) / sizeof(devices), NULL);
  
  if (iDevicesFound <= 0) {
    fprintf(stderr, "No CEC devices found\n");
    fflush(stderr);
    libcecc_destroy(&g_iface);
    return;
  }
  
  strcpy(g_strPort, devices[0].comm);
  if (!g_iface.open(g_iface.connection, g_strPort, 5000)) {
    fprintf(stderr, "Unable to open the device on port %s\n", g_strPort);
    fflush(stderr);
    libcecc_destroy(&g_iface);
    return;
  }
  
  g_iface.set_active_source(g_iface.connection, g_config.deviceTypes.types[0]);
}
#endif /* HAVE_LIBCEC */
                                                                                                                                                                                                                                                                         moonlight-embedded-2.1.1/src/input/cec.h                                                            0000664 0000000 0000000 00000001351 12563604362 0020102 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

void cec_init();
                                                                                                                                                                                                                                                                                       moonlight-embedded-2.1.1/src/input/evdev.c                                                          0000664 0000000 0000000 00000040753 12563604362 0020465 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#include "../loop.h"
#include "../global.h"

#include "keyboard.h"
#include "mapping.h"

#include "libevdev/libevdev.h"
#include "limelight-common/Limelight.h"

#include <libudev.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <fcntl.h>
#include <poll.h>
#include <limits.h>
#include <unistd.h>
#include <pthread.h>

struct input_abs_parms {
  int min, max;
  int flat;
  int avg;
  int range, diff;
};

struct input_device {
  struct libevdev *dev;
  struct mapping map;
  int fd;
  char modifiers;
  __s32 mouseDeltaX, mouseDeltaY, mouseScroll;
  short controllerId;
  int buttonFlags;
  char leftTrigger, rightTrigger;
  short leftStickX, leftStickY;
  short rightStickX, rightStickY;
  bool gamepadModified;
  struct input_abs_parms xParms, yParms, rxParms, ryParms, zParms, rzParms;
  struct input_abs_parms dpadxParms, dpadyParms;
};

static struct input_device* devices = NULL;
static int numDevices = 0;
static int assignedControllerIds = 0;

static short* currentKey;
static short* currentAbs;
static bool* currentReverse;

static bool grabbingDevices;

#define QUIT_MODIFIERS (MODIFIER_SHIFT|MODIFIER_ALT|MODIFIER_CTRL)
#define QUIT_KEY KEY_Q

static bool (*handler) (struct input_event*, struct input_device*);

static void evdev_init_parms(struct input_device *dev, struct input_abs_parms *parms, int code) {
  parms->flat = libevdev_get_abs_flat(dev->dev, code);
  parms->min = libevdev_get_abs_minimum(dev->dev, code);
  parms->max = libevdev_get_abs_maximum(dev->dev, code);
  parms->avg = (parms->min+parms->max)/2;
  parms->range = parms->max - parms->avg;
  parms->diff = parms->max - parms->min;
}

static void evdev_remove(int devindex) {
  numDevices--;

  if (devices[devindex].controllerId >= 0)
    assignedControllerIds &= ~(1 << devices[devindex].controllerId);

  if (devindex != numDevices && numDevices > 0)
    memcpy(&devices[devindex], &devices[numDevices], sizeof(struct input_device));

  fprintf(stderr, "Removed input device\n");
}

static short evdev_convert_value(struct input_event *ev, struct input_device *dev, struct input_abs_parms *parms, bool reverse) {
  if (abs(ev->value - parms->avg) < parms->flat)
    return 0;
  else if (ev->value > parms->max)
    return reverse?SHRT_MIN:SHRT_MAX;
  else if (ev->value < parms->min)
    return reverse?SHRT_MAX:SHRT_MIN;
  else if (reverse)
    return (parms->max - (ev->value<parms->avg?parms->flat*2:0) - ev->value) * (SHRT_MAX-SHRT_MIN) / (parms->max-parms->min-parms->flat*2) - SHRT_MIN;
  else
    return (ev->value - (ev->value>parms->avg?parms->flat*2:0) - parms->min) * (SHRT_MAX-SHRT_MIN) / (parms->max-parms->min-parms->flat*2) - SHRT_MIN;
}

static char evdev_convert_value_byte(struct input_event *ev, struct input_device *dev, struct input_abs_parms *parms) {
  if (abs(ev->value-parms->min)<parms->flat)
    return 0;
  else if (ev->value>parms->max)
    return UCHAR_MAX;
  else {
    int value = ev->value - parms->flat;
    return (value-parms->min) * UCHAR_MAX / (parms->diff-parms->flat);
  }
}

static int evdev_convert_value_direction(struct input_event *ev, struct input_device *dev, struct input_abs_parms *parms, bool reverse) {
  if (ev->value > (parms->avg+parms->range/4))
    return reverse?-1:1;
  else if (ev->value < (parms->avg-parms->range/4))
    return reverse?1:-1;
  else
    return 0;
}

static bool evdev_handle_event(struct input_event *ev, struct input_device *dev) {
  bool gamepadModified = false;

  switch (ev->type) {
  case EV_SYN:
    if (dev->mouseDeltaX != 0 || dev->mouseDeltaY != 0) {
      LiSendMouseMoveEvent(dev->mouseDeltaX, dev->mouseDeltaY);
      dev->mouseDeltaX = 0;
      dev->mouseDeltaY = 0;
    }
    if (dev->mouseScroll != 0) {
      LiSendScrollEvent(dev->mouseScroll);
      dev->mouseScroll = 0;
    }
    if (dev->gamepadModified) {
      if (dev->controllerId < 0) {
        for (int i = 0; i < 4; i++) {
          if ((assignedControllerIds & (1 << i)) == 0) {
            assignedControllerIds |= (1 << i);
            dev->controllerId = i;
            break;
          }
        }
        //Use id 0 when too many gamepads are connected
        if (dev->controllerId < 0)
          dev->controllerId = 0;
      }
      LiSendMultiControllerEvent(dev->controllerId, dev->buttonFlags, dev->leftTrigger, dev->rightTrigger, dev->leftStickX, dev->leftStickY, dev->rightStickX, dev->rightStickY);
      dev->gamepadModified = false;
    }
    break;
  case EV_KEY:
    if (ev->code < sizeof(keyCodes)/sizeof(keyCodes[0])) {
      char modifier = 0;
      switch (ev->code) {
      case KEY_LEFTSHIFT:
      case KEY_RIGHTSHIFT:
        modifier = MODIFIER_SHIFT;
        break;
      case KEY_LEFTALT:
      case KEY_RIGHTALT:
        modifier = MODIFIER_ALT;
        break;
      case KEY_LEFTCTRL:
      case KEY_RIGHTCTRL:
        modifier = MODIFIER_CTRL;
        break;
      }
      if (modifier != 0) {
        if (ev->value)
          dev->modifiers |= modifier;
        else
          dev->modifiers &= ~modifier;
      }

      // Quit the stream if all the required quit keys are down
      if ((dev->modifiers & QUIT_MODIFIERS) == QUIT_MODIFIERS &&
          ev->code == QUIT_KEY && ev->value != 0) {
        return false;
      }

      short code = 0x80 << 8 | keyCodes[ev->code];
      LiSendKeyboardEvent(code, ev->value?KEY_ACTION_DOWN:KEY_ACTION_UP, dev->modifiers);
    } else {
      int mouseCode = 0;
      short gamepadCode = 0;
      switch (ev->code) {
      case BTN_LEFT:
        mouseCode = BUTTON_LEFT;
        break;
      case BTN_MIDDLE:
        mouseCode = BUTTON_MIDDLE;
        break;
      case BTN_RIGHT:
        mouseCode = BUTTON_RIGHT;
        break;
      default:
        if (ev->code == dev->map.btn_south)
          gamepadCode = A_FLAG;
        else if (ev->code == dev->map.btn_west)
          gamepadCode = X_FLAG;
        else if (ev->code == dev->map.btn_north)
          gamepadCode = Y_FLAG;
        else if (ev->code == dev->map.btn_east)
          gamepadCode = B_FLAG;
        else if (ev->code == dev->map.btn_dpad_up)
          gamepadCode = UP_FLAG;
        else if (ev->code == dev->map.btn_dpad_down)
          gamepadCode = DOWN_FLAG;
        else if (ev->code == dev->map.btn_dpad_right)
          gamepadCode = RIGHT_FLAG;
        else if (ev->code == dev->map.btn_dpad_left)
          gamepadCode = LEFT_FLAG;
        else if (ev->code == dev->map.btn_thumbl)
          gamepadCode = LS_CLK_FLAG;
        else if (ev->code == dev->map.btn_thumbr)
          gamepadCode = RS_CLK_FLAG;
        else if (ev->code == dev->map.btn_tl)
          gamepadCode = LB_FLAG;
        else if (ev->code == dev->map.btn_tr)
          gamepadCode = RB_FLAG;
        else if (ev->code == dev->map.btn_start)
          gamepadCode = PLAY_FLAG;
        else if (ev->code == dev->map.btn_select)
          gamepadCode = BACK_FLAG;
        else if (ev->code == dev->map.btn_mode)
          gamepadCode = SPECIAL_FLAG;
      }

      if (mouseCode != 0) {
        LiSendMouseButtonEvent(ev->value?BUTTON_ACTION_PRESS:BUTTON_ACTION_RELEASE, mouseCode);
      } else {
        gamepadModified = true;

        if (gamepadCode != 0) {
          if (ev->value)
            dev->buttonFlags |= gamepadCode;
          else
            dev->buttonFlags &= ~gamepadCode;
        } else if (ev->code == dev->map.btn_tl2)
          dev->leftTrigger = ev->value?UCHAR_MAX:0;
        else if (ev->code == dev->map.btn_tr2)
          dev->rightTrigger = ev->value?UCHAR_MAX:0;
        else {
          fprintf(stderr, "Unmapped button: %d\n", ev->code);
          gamepadModified = false;
        }
      }
    }
    break;
  case EV_REL:
    switch (ev->code) {
      case REL_X:
        dev->mouseDeltaX = ev->value;
        break;
      case REL_Y:
        dev->mouseDeltaY = ev->value;
        break;
      case REL_WHEEL:
        dev->mouseScroll = ev->value;
        break;
    }
    break;
  case EV_ABS:
    gamepadModified = true;
    if (ev->code == dev->map.abs_x)
      dev->leftStickX = evdev_convert_value(ev, dev, &dev->xParms, dev->map.reverse_x);
    else if (ev->code == dev->map.abs_y)
      dev->leftStickY = evdev_convert_value(ev, dev, &dev->yParms, dev->map.reverse_y);
    else if (ev->code == dev->map.abs_rx)
      dev->rightStickX = evdev_convert_value(ev, dev, &dev->rxParms, dev->map.reverse_rx);
    else if (ev->code == dev->map.abs_ry)
      dev->rightStickY = evdev_convert_value(ev, dev, &dev->ryParms, dev->map.reverse_ry);
    else if (ev->code == dev->map.abs_z)
      dev->leftTrigger = evdev_convert_value_byte(ev, dev, &dev->zParms);
    else if (ev->code == dev->map.abs_rz)
      dev->rightTrigger = evdev_convert_value_byte(ev, dev, &dev->rzParms);
    else if (ev->code == dev->map.abs_dpad_x) {
      int dir = evdev_convert_value_direction(ev, dev, &dev->dpadxParms, dev->map.reverse_dpad_x);
      if (dir == 1) {
        dev->buttonFlags |= RIGHT_FLAG;
        dev->buttonFlags &= ~LEFT_FLAG;
      } else if (dir == 0) {
        dev->buttonFlags &= ~RIGHT_FLAG;
        dev->buttonFlags &= ~LEFT_FLAG;
      } else {
        dev->buttonFlags &= ~RIGHT_FLAG;
        dev->buttonFlags |= LEFT_FLAG;
      }
    } else if (ev->code == dev->map.abs_dpad_y) {
      int dir = evdev_convert_value_direction(ev, dev, &dev->dpadyParms, dev->map.reverse_dpad_y);
      if (dir == 1) {
        dev->buttonFlags |= DOWN_FLAG;
        dev->buttonFlags &= ~UP_FLAG;
      } else if (dir == 0) {
        dev->buttonFlags &= ~DOWN_FLAG;
        dev->buttonFlags &= ~UP_FLAG;
      } else {
        dev->buttonFlags &= ~DOWN_FLAG;
        dev->buttonFlags |= UP_FLAG;
      }
    } else
      gamepadModified = false;

    break;
  }

  dev->gamepadModified |= gamepadModified;
  return true;
}

static bool evdev_handle_mapping_event(struct input_event *ev, struct input_device *dev) {
  switch (ev->type) {
  case EV_KEY:
    if (currentKey != NULL) {
      if (ev->value)
        *currentKey = ev->code;
      else if (ev->code == *currentKey)
        return false;
    }
    break;
  case EV_ABS:
    if (currentAbs != NULL) {
      struct input_abs_parms parms;
      evdev_init_parms(dev, &parms, ev->code);

      if (ev->value > parms.avg + parms.range/2) {
        *currentAbs = ev->code;
        *currentReverse = false;
      } else if (ev->value < parms.avg - parms.range/2) {
        *currentAbs = ev->code;
        *currentReverse = true;
      } else if (ev->code == *currentAbs)
        return false;
    }
    break;
  }
  return true;
}

static void evdev_drain(void) {
  for (int i = 0; i < numDevices; i++) {
    struct input_event ev;
    while (libevdev_next_event(devices[i].dev, LIBEVDEV_READ_FLAG_NORMAL, &ev) >= 0);
  }
}

static int evdev_handle(int fd) {
  for (int i=0;i<numDevices;i++) {
    if (devices[i].fd = fd) {
      int rc;
      struct input_event ev;
      while ((rc = libevdev_next_event(devices[i].dev, LIBEVDEV_READ_FLAG_NORMAL, &ev)) >= 0) {
        if (rc == LIBEVDEV_READ_STATUS_SYNC)
          fprintf(stderr, "Error: cannot keep up\n");
        else if (rc == LIBEVDEV_READ_STATUS_SUCCESS) {
          if (!handler(&ev, &devices[i]))
            return LOOP_RETURN;
        }
      }
      if (rc == -ENODEV) {
        evdev_remove(i);
      } else if (rc != -EAGAIN && rc < 0) {
        fprintf(stderr, "Error: %s\n", strerror(-rc));
        exit(EXIT_FAILURE);
      }
    }
  }
  return LOOP_OK;
}

void evdev_create(const char* device, char* mapFile) {
  int fd = open(device, O_RDONLY|O_NONBLOCK);
  if (fd <= 0) {
    fprintf(stderr, "Failed to open device %s\n", device);
    fflush(stderr);
    return;
  }

  int dev = numDevices;
  numDevices++;

  if (devices == NULL) {
    devices = malloc(sizeof(struct input_device));
  } else {
    devices = realloc(devices, sizeof(struct input_device)*numDevices);
  }

  if (devices == NULL) {
    fprintf(stderr, "Not enough memory\n");
    exit(EXIT_FAILURE);
  }

  memset(&devices[dev], 0, sizeof(devices[0]));
  devices[dev].fd = fd;
  devices[dev].dev = libevdev_new();
  libevdev_set_fd(devices[dev].dev, devices[dev].fd);

  if (mapFile != NULL)
    mapping_load(mapFile, &(devices[dev].map));

  devices[dev].controllerId = -1;
  evdev_init_parms(&devices[dev], &(devices[dev].xParms), devices[dev].map.abs_x);
  evdev_init_parms(&devices[dev], &(devices[dev].yParms), devices[dev].map.abs_y);
  evdev_init_parms(&devices[dev], &(devices[dev].zParms), devices[dev].map.abs_z);
  evdev_init_parms(&devices[dev], &(devices[dev].rxParms), devices[dev].map.abs_rx);
  evdev_init_parms(&devices[dev], &(devices[dev].ryParms), devices[dev].map.abs_ry);
  evdev_init_parms(&devices[dev], &(devices[dev].rzParms), devices[dev].map.abs_rz);
  evdev_init_parms(&devices[dev], &(devices[dev].dpadxParms), devices[dev].map.abs_dpad_x);
  evdev_init_parms(&devices[dev], &(devices[dev].dpadyParms), devices[dev].map.abs_dpad_y);

  if (grabbingDevices) {
    if (ioctl(fd, EVIOCGRAB, 1) < 0) {
      fprintf(stderr, "EVIOCGRAB failed with error %d\n", errno);
    }
  }

  loop_add_fd(devices[dev].fd, &evdev_handle, POLLIN);
}

static void evdev_map_key(char* keyName, short* key) {
  printf("Press %s\n", keyName);
  currentKey = key;
  currentAbs = NULL;
  *key = -1;
  loop_main();

  usleep(250000);
  evdev_drain();
}

static void evdev_map_abs(char* keyName, short* abs, bool* reverse) {
  printf("Move %s\n", keyName);
  currentKey = NULL;
  currentAbs = abs;
  currentReverse = reverse;
  *abs = -1;
  loop_main();

  usleep(250000);
  evdev_drain();
}

static void evdev_map_abskey(char* keyName, short* key, short* abs, bool* reverse) {
  printf("Press %s\n", keyName);
  currentKey = key;
  currentAbs = abs;
  currentReverse = reverse;
  *key = -1;
  *abs = -1;
  *currentReverse = false;
  loop_main();

  usleep(250000);
  evdev_drain();
}

void evdev_map(char* fileName) {
  struct mapping map;

  handler = evdev_handle_mapping_event;

  evdev_map_abs("Left Stick Right", &(map.abs_x), &(map.reverse_x));
  evdev_map_abs("Left Stick Up", &(map.abs_y), &(map.reverse_y));
  evdev_map_key("Left Stick Button", &(map.btn_thumbl));

  evdev_map_abs("Right Stick Right", &(map.abs_rx), &(map.reverse_rx));
  evdev_map_abs("Right Stick Up", &(map.abs_ry), &(map.reverse_ry));
  evdev_map_key("Right Stick Button", &(map.btn_thumbr));

  evdev_map_abskey("D-Pad Right", &(map.btn_dpad_right), &(map.abs_dpad_x), &(map.reverse_dpad_x));
  if (map.btn_dpad_right >= 0)
    evdev_map_key("D-Pad Left", &(map.btn_dpad_left));
  else
    map.btn_dpad_left = -1;

  evdev_map_abskey("D-Pad Down", &(map.btn_dpad_down), &(map.abs_dpad_y), &(map.reverse_dpad_y));
  if (map.btn_dpad_down >= 0)
    evdev_map_key("D-Pad Up", &(map.btn_dpad_up));
  else
    map.btn_dpad_up = -1;

  evdev_map_key("Button X (1)", &(map.btn_west));
  evdev_map_key("Button A (2)", &(map.btn_south));
  evdev_map_key("Button B (3)", &(map.btn_east));
  evdev_map_key("Button Y (4)", &(map.btn_north));
  evdev_map_key("Back Button", &(map.btn_select));
  evdev_map_key("Start Button", &(map.btn_start));
  evdev_map_key("Special Button", &(map.btn_mode));

  bool ignored;
  evdev_map_abskey("Left Trigger", &(map.btn_tl2), &(map.abs_z), &ignored);
  evdev_map_abskey("Right Trigger", &(map.btn_tr2), &(map.abs_rz), &ignored);

  evdev_map_key("Left Bumper", &(map.btn_tl));
  evdev_map_key("Right Bumper", &(map.btn_tr));
  mapping_save(fileName, &map);
}

void evdev_start() {
  // After grabbing, the only way to quit via the keyboard
  // is via the special key combo that the input handling
  // code looks for. For this reason, we wait to grab until
  // we're ready to take input events. Ctrl+C works up until
  // this point.
  for (int i = 0; i < numDevices; i++) {
    if (ioctl(devices[i].fd, EVIOCGRAB, 1) < 0) {
      fprintf(stderr, "EVIOCGRAB failed with error %d\n", errno);
    }
  }

  // Any new input devices detected after this point will be grabbed immediately
  grabbingDevices = true;

  // Handle input events until the quit combo is pressed
}

void evdev_stop() {
  evdev_drain();
}

void evdev_init() {
  handler = evdev_handle_event;
}
                     moonlight-embedded-2.1.1/src/input/evdev.h                                                          0000664 0000000 0000000 00000001574 12563604362 0020470 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

void evdev_create(const char* device, char* mapFile);
void evdev_loop();
void evdev_map(char* fileName);

void evdev_init();
void evdev_start();
void evdev_stop();
                                                                                                                                    moonlight-embedded-2.1.1/src/input/keyboard.h                                                       0000664 0000000 0000000 00000006026 12563604362 0021154 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

static const short keyCodes[] = {
  0, //VK_RESERVED
  0x1B, //VK_ESCAPE
  0x31, //VK_1
  0x32, //VK_2
  0x33, //VK_3
  0x34, //VK_4
  0x35, //VK_5
  0x36, //VK_6
  0x37, //VK_7
  0x38, //VK_8
  0x39, //VK_9
  0x30, //VK_0
  0xBD, //VK_MINUS
  0xBB, //VK_EQUALS
  0x08, //VK_BACK_SPACE
  0x09, //VK_TAB
  0x51, //VK_Q
  0x57, //VK_W
  0x45, //VK_E
  0x52, //VK_R
  0x54, //VK_T
  0x59, //VK_Y
  0x55, //VK_U
  0x49, //VK_I
  0x4F, //VK_O
  0x50, //VK_P
  0xDB, //VK_BRACELEFT
  0xDD, //VK_BRACERIGHT
  0x0D, //VK_ENTER
  0x11, //VK_CONTROL Left control
  0x41, //VK_A
  0x53, //VK_S
  0x44, //VK_D
  0x46, //VK_F
  0x47, //VK_G
  0x48, //VK_H
  0x4A, //VK_J
  0x4B, //VK_K
  0x4C, //VK_L
  0xBA, //VK_SEMICOLON
  0xDE, //VK_APOSTROPHE
  0xC0, //VK_GRAVE
  0x10, //VK_SHIFT Left shift
  0xDC, //VK_BACK_SLASH
  0x5A, //VK_Z
  0x58, //VK_X
  0x43, //VK_C
  0x56, //VK_V
  0x42, //VK_B
  0x4E, //VK_N
  0x4D, //VK_M
  0xBC, //VK_COMMA
  0xBE, //VK_DOT
  0xBF, //VK_SLASH
  0x10, //VK_SHIFT Right shift
  0, //VK_KPASTERISK
  0x11, //VK_ALT Left alt
  0x20, //VK_SPACE
  0x14, //VK_CAPS_LOCK
  0x70, //VK_F1
  0x71, //VK_F2
  0x72, //VK_F3
  0x73, //VK_F4
  0x74, //VK_F5
  0x75, //VK_F6
  0x76, //VK_F7
  0x77, //VK_F8
  0x78, //VK_F9
  0x79, //VK_F10
  0x90, //VK_NUM_LOCK
  0x91, //VK_SCROLL_LOCK
  0x67, //VK_NUMPAD7
  0x68, //VK_NUMPAD8
  0x69, //VK_NUMPAD9
  0, //VK_NUMPAD_MINUS
  0x64, //VK_NUMPAD4
  0x65, //VK_NUMPAD5
  0x66, //VK_NUMPAD6
  0, //VK_NUMPADPLUS
  0x61, //VK_NUMPAD1
  0x62, //VK_NUMPAD2
  0x63, //VK_NUMPAD3
  0x60, //VK_NUMPAD0
  0, //KeyEvent.VK_NUMPADDOT
  0,
  0, //KeyEvent.VK_ZENKAKUHANKAKU
  0, //KeyEvent.VK_102ND
  0x7A, //VK_F11
  0x7B, //VK_F12
  0, //KeyEvent.VK_RO
  0xF1, //VK_KATAKANA
  0xF2, //VK_HIRAGANA
  0, //VK_HENKAN
  0, //VK_KATAKANAHIRAGANA
  0, //VK_MUHENKAN
  0, //VK_KPJPCOMMA
  0, //VK_KPENTER
  0x11, //VK_CONTROL Right ctrl
  0, //VK_KPSLASH
  0, //VK_SYSRQ
  0x11, //VK_ALT Right alt
  0, //KeyEvent.VK_LINEFEED
  0x24, //VK_HOME
  0x26, //VK_UP
  0x21, //VK_PAGE_UP
  0x25, //VK_LEFT
  0x27, //VK_RIGHT
  0x23, //VK_END
  0x28, //VK_DOWN
  0x22, //VK_PAGE_DOWN
  0x9B, //VK_INSERT
  0x2E, //VK_DELETE
  0, //VK_MACRO
  0, //VK_MUTE
  0, //VK_VOLUMEDOWN
  0, //VK_VOLUMEUP
  0, //VK_POWER SC System Power Down
  0, //VK_KPEQUAL
  0, //VK_KPPLUSMINUS
  0x13, //VK_PAUSE
  0, //VK_SCALE AL Compiz Scale (Expose)
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          moonlight-embedded-2.1.1/src/input/mapping.c                                                        0000664 0000000 0000000 00000013766 12563604362 0021013 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#include "mapping.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define write_config(fd, key, value) fprintf(fd, "%s = %hd\n", key, value)
#define write_config_bool(fd, key, value) fprintf(fd, "%s = %s\n", key, value?"true":"false");

void mapping_load(char* fileName, struct mapping* map) {
  FILE* fd = fopen(fileName, "r");
  if (fd == NULL) {
    fprintf(stderr, "Can't open mapping file: %s\n", fileName);
    exit(EXIT_FAILURE);
  }

  char *line = NULL;
  size_t len = 0;
  while (getline(&line, &len, fd) != -1) {
    char *key = NULL, *value = NULL;
    if (sscanf(line, "%ms = %ms", &key, &value) == 2) {
      long int_value = strtol(value, NULL, 10);
      if (strcmp("abs_x", key) == 0)
        map->abs_x = int_value;
      else if (strcmp("abs_y", key) == 0)
        map->abs_y = int_value;
      else if (strcmp("abs_z", key) == 0)
        map->abs_z = int_value;
      else if (strcmp("abs_rx", key) == 0)
        map->abs_rx = int_value;
      else if (strcmp("abs_ry", key) == 0)
        map->abs_ry = int_value;
      else if (strcmp("abs_rz", key) == 0)
        map->abs_rz = int_value;
      else if (strcmp("abs_deadzone", key) == 0)
        map->abs_deadzone = int_value;
      else if (strcmp("abs_dpad_x", key) == 0)
        map->abs_dpad_x = int_value;
      else if (strcmp("abs_dpad_y", key) == 0)
        map->abs_dpad_y = int_value;
      else if (strcmp("btn_south", key) == 0)
        map->btn_south = int_value;
      else if (strcmp("btn_north", key) == 0)
        map->btn_north = int_value;
      else if (strcmp("btn_east", key) == 0)
        map->btn_east = int_value;
      else if (strcmp("btn_west", key) == 0)
        map->btn_west = int_value;
      else if (strcmp("btn_select", key) == 0)
        map->btn_select = int_value;
      else if (strcmp("btn_start", key) == 0)
        map->btn_start = int_value;
      else if (strcmp("btn_mode", key) == 0)
        map->btn_mode = int_value;
      else if (strcmp("btn_thumbl", key) == 0)
        map->btn_thumbl = int_value;
      else if (strcmp("btn_thumbr", key) == 0)
        map->btn_thumbr = int_value;
      else if (strcmp("btn_tl", key) == 0)
        map->btn_tl = int_value;
      else if (strcmp("btn_tr", key) == 0)
        map->btn_tr = int_value;
      else if (strcmp("btn_tl2", key) == 0)
        map->btn_tl2 = int_value;
      else if (strcmp("btn_tr2", key) == 0)
        map->btn_tr2 = int_value;
      else if (strcmp("btn_dpad_up", key) == 0)
        map->btn_dpad_up = int_value;
      else if (strcmp("btn_dpad_down", key) == 0)
        map->btn_dpad_down = int_value;
      else if (strcmp("btn_dpad_left", key) == 0)
        map->btn_dpad_left = int_value;
      else if (strcmp("btn_dpad_right", key) == 0)
        map->btn_dpad_right = int_value;
      else if (strcmp("reverse_x", key) == 0)
        map->reverse_x = strcmp("true", value) == 0;
      else if (strcmp("reverse_y", key) == 0)
        map->reverse_y = strcmp("true", value) == 0;
      else if (strcmp("reverse_rx", key) == 0)
        map->reverse_rx = strcmp("true", value) == 0;
      else if (strcmp("reverse_ry", key) == 0)
        map->reverse_ry = strcmp("true", value) == 0;
      else if (strcmp("reverse_dpad_x", key) == 0)
        map->reverse_dpad_x = strcmp("true", value) == 0;
      else if (strcmp("reverse_dpad_y", key) == 0)
        map->reverse_dpad_y = strcmp("true", value) == 0;
      else
        fprintf(stderr, "Can't map (%s)\n", key);
    }
    if (key != NULL)
      free(key);

    if (value != NULL)
      free(value);
  }
  free(line);
}

void mapping_save(char* fileName, struct mapping* map) {
  FILE* fd = fopen(fileName, "w");
  if (fd == NULL) {
    fprintf(stderr, "Can't open mapping file: %s\n", fileName);
    exit(EXIT_FAILURE);
  }

  write_config(fd, "abs_x", map->abs_x);
  write_config(fd, "abs_y", map->abs_y);
  write_config(fd, "abs_z", map->abs_z);

  write_config_bool(fd, "reverse_x", map->reverse_x);
  write_config_bool(fd, "reverse_y", map->reverse_y);

  write_config(fd, "abs_rx", map->abs_rx);
  write_config(fd, "abs_ry", map->abs_ry);
  write_config(fd, "abs_rz", map->abs_rz);

  write_config_bool(fd, "reverse_rx", map->reverse_rx);
  write_config_bool(fd, "reverse_ry", map->reverse_ry);

  write_config(fd, "abs_deadzone", map->abs_deadzone);

  write_config(fd, "abs_dpad_x", map->abs_dpad_x);
  write_config(fd, "abs_dpad_y", map->abs_dpad_y);

  write_config_bool(fd, "reverse_dpad_x", map->reverse_dpad_x);
  write_config_bool(fd, "reverse_dpad_y", map->reverse_dpad_y);

  write_config(fd, "btn_north", map->btn_north);
  write_config(fd, "btn_east", map->btn_east);
  write_config(fd, "btn_south", map->btn_south);
  write_config(fd, "btn_west", map->btn_west);

  write_config(fd, "btn_select", map->btn_select);
  write_config(fd, "btn_start", map->btn_start);
  write_config(fd, "btn_mode", map->btn_mode);

  write_config(fd, "btn_thumbl", map->btn_thumbl);
  write_config(fd, "btn_thumbr", map->btn_thumbr);

  write_config(fd, "btn_tl", map->btn_tl);
  write_config(fd, "btn_tr", map->btn_tr);
  write_config(fd, "btn_tl2", map->btn_tl2);
  write_config(fd, "btn_tr2", map->btn_tr2);

  write_config(fd, "btn_dpad_up", map->btn_dpad_up);
  write_config(fd, "btn_dpad_down", map->btn_dpad_down);
  write_config(fd, "btn_dpad_left", map->btn_dpad_left);
  write_config(fd, "btn_dpad_right", map->btn_dpad_right);

  fclose(fd);
}
          moonlight-embedded-2.1.1/src/input/mapping.h                                                        0000664 0000000 0000000 00000002466 12563604362 0021013 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#include <stdbool.h>

struct mapping {
  short abs_x, abs_y, abs_z;
  short abs_rx, abs_ry, abs_rz;

  bool reverse_x, reverse_y;
  bool reverse_rx, reverse_ry;

  short abs_deadzone;

  short abs_dpad_x, abs_dpad_y;
  bool reverse_dpad_x, reverse_dpad_y;

  short btn_south, btn_east, btn_north, btn_west;
  short btn_select, btn_start, btn_mode;
  short btn_thumbl, btn_thumbr;
  short btn_tl, btn_tr, btn_tl2, btn_tr2;

  short btn_dpad_up, btn_dpad_down, btn_dpad_left, btn_dpad_right;
};

void mapping_load(char* fileName, struct mapping* map);
void mapping_save(char* fileName, struct mapping* map);
                                                                                                                                                                                                          moonlight-embedded-2.1.1/src/input/sdlinput.c                                                       0000664 0000000 0000000 00000015410 12563604362 0021206 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#ifdef HAVE_SDL

#include "sdlinput.h"
#include "../sdl.h"

#include "limelight-common/Limelight.h"

#define ACTION_MODIFIERS (MODIFIER_SHIFT|MODIFIER_ALT|MODIFIER_CTRL)
#define QUIT_KEY SDLK_q
#define FULLSCREEN_KEY SDLK_f

typedef struct _GAMEPAD_STATE {
  char leftTrigger, rightTrigger;
  short leftStickX, leftStickY;
  short rightStickX, rightStickY;
  int buttons;
  SDL_JoystickID sdl_id;
  short id;
  bool initialized;
} GAMEPAD_STATE, *PGAMEPAD_STATE;

static GAMEPAD_STATE gamepads[4];

static int keyboard_modifiers;

void sdlinput_init() {
  memset(gamepads, 0, sizeof(gamepads));

  SDL_InitSubSystem(SDL_INIT_GAMECONTROLLER);
  SDL_GameControllerAddMappingsFromFile("gamecontrollerdb.txt");

  for (int i = 0; i < SDL_NumJoysticks(); ++i) {
    if (SDL_IsGameController(i)) {
      if (!SDL_GameControllerOpen(i)) {
        fprintf(stderr, "Could not open gamecontroller %i: %s\n", i, SDL_GetError());
      }
    }
  }
}

static PGAMEPAD_STATE get_gamepad(SDL_JoystickID sdl_id) {
  for (int i = 0;i<4;i++) {
    if (gamepads[i].sdl_id == sdl_id)
      return &gamepads[0];
    else if (!gamepads[i].initialized) {
      gamepads[i].sdl_id = sdl_id;
      gamepads[i].id = i;
      gamepads[i].initialized = true;
      return &gamepads[0];
    }
  }
  return &gamepads[0];
}

int sdlinput_handle_event(SDL_Event* event) {
  int button = 0;
  PGAMEPAD_STATE gamepad;
  switch (event->type) {
  case SDL_MOUSEMOTION:
    LiSendMouseMoveEvent(event->motion.xrel, event->motion.yrel);
    break;
  case SDL_MOUSEWHEEL:
    LiSendScrollEvent(event->wheel.y);
    break;
  case SDL_MOUSEBUTTONUP:
  case SDL_MOUSEBUTTONDOWN:
    switch (event->button.button) {
    case SDL_BUTTON_LEFT:
      button = BUTTON_LEFT;
      break;
    case SDL_BUTTON_MIDDLE:
      button = BUTTON_MIDDLE;
      break;
    case SDL_BUTTON_RIGHT:
      button = BUTTON_RIGHT;
      break;
    }

    if (button != 0)
      LiSendMouseButtonEvent(event->type==SDL_MOUSEBUTTONDOWN?BUTTON_ACTION_PRESS:BUTTON_ACTION_RELEASE, button);

    return SDL_MOUSE_GRAB;
  case SDL_KEYDOWN:
  case SDL_KEYUP:
    button = event->key.keysym.sym;
    if (button >= (0x40000000 + 0x39) && button < (0x40000000 + 0x39 + sizeof(keyCodes)))
      button = keyCodes[button - 0x40000039];
    else if (button >= 0x61)
      button -= 0x20;

    int modifier = 0;
    switch (event->key.keysym.sym) {
    case SDLK_RSHIFT:
    case SDLK_LSHIFT:
      modifier = MODIFIER_SHIFT;
      break;
    case SDLK_RALT:
    case SDLK_LALT:
      modifier = MODIFIER_ALT;
      break;
    case SDLK_RCTRL:
    case SDLK_LCTRL:
      modifier = MODIFIER_CTRL;
      break;
    }

    if (modifier != 0) {
      if (event->type==SDL_KEYDOWN)
        keyboard_modifiers |= modifier;
      else
        keyboard_modifiers &= ~modifier;
    }

    // Quit the stream if all the required quit keys are down
    if ((keyboard_modifiers & ACTION_MODIFIERS) == ACTION_MODIFIERS && event->key.keysym.sym == QUIT_KEY && event->type==SDL_KEYUP)
      return SDL_QUIT_APPLICATION;
    else if ((keyboard_modifiers & ACTION_MODIFIERS) == ACTION_MODIFIERS && event->key.keysym.sym == FULLSCREEN_KEY && event->type==SDL_KEYUP)
      return SDL_TOGGLE_FULLSCREEN;
    else if ((keyboard_modifiers & ACTION_MODIFIERS) == ACTION_MODIFIERS)
      return SDL_MOUSE_UNGRAB;

    LiSendKeyboardEvent(0x80 << 8 | button, event->type==SDL_KEYDOWN?KEY_ACTION_DOWN:KEY_ACTION_UP, keyboard_modifiers);
    break;
  case SDL_CONTROLLERAXISMOTION:
    gamepad = get_gamepad(event->caxis.which);
    switch (event->caxis.axis) {
    case SDL_CONTROLLER_AXIS_LEFTX:
      gamepad->leftStickX = event->caxis.value;
      break;
    case SDL_CONTROLLER_AXIS_LEFTY:
      gamepad->leftStickY = -event->caxis.value - 1;
      break;
    case SDL_CONTROLLER_AXIS_RIGHTX:
      gamepad->rightStickX = event->caxis.value;
      break;
    case SDL_CONTROLLER_AXIS_RIGHTY:
      gamepad->rightStickY = -event->caxis.value - 1;
      break;
    case SDL_CONTROLLER_AXIS_TRIGGERLEFT:
      gamepad->leftTrigger = (event->caxis.value >> 8) + 127;
      break;
    case SDL_CONTROLLER_AXIS_TRIGGERRIGHT:
      gamepad->rightTrigger = (event->caxis.value >> 8) + 127;
      break;
    default:
      return SDL_NOTHING;
    }
    LiSendMultiControllerEvent(gamepad->id, gamepad->buttons, gamepad->leftTrigger, gamepad->rightTrigger, gamepad->leftStickX, gamepad->leftStickY, gamepad->rightStickX, gamepad->rightStickY);
    break;
  case SDL_CONTROLLERBUTTONDOWN:
  case SDL_CONTROLLERBUTTONUP:
    gamepad = get_gamepad(event->cbutton.which);
    switch (event->cbutton.button) {
    case SDL_CONTROLLER_BUTTON_A:
      button = A_FLAG;
      break;
    case SDL_CONTROLLER_BUTTON_B:
      button = B_FLAG;
      break;
    case SDL_CONTROLLER_BUTTON_Y:
      button = Y_FLAG;
      break;
    case SDL_CONTROLLER_BUTTON_X:
      button = X_FLAG;
      break;
    case SDL_CONTROLLER_BUTTON_DPAD_UP:
      button = UP_FLAG;
      break;
    case SDL_CONTROLLER_BUTTON_DPAD_DOWN:
      button = DOWN_FLAG;
      break;
    case SDL_CONTROLLER_BUTTON_DPAD_RIGHT:
      button = RIGHT_FLAG;
      break;
    case SDL_CONTROLLER_BUTTON_DPAD_LEFT:
      button = LEFT_FLAG;
      break;
    case SDL_CONTROLLER_BUTTON_BACK:
      button = BACK_FLAG;
      break;
    case SDL_CONTROLLER_BUTTON_START:
      button = PLAY_FLAG;
      break;
    case SDL_CONTROLLER_BUTTON_GUIDE:
      button = SPECIAL_FLAG;
      break;
    case SDL_CONTROLLER_BUTTON_LEFTSTICK:
      button = LS_CLK_FLAG;
      break;
    case SDL_CONTROLLER_BUTTON_RIGHTSTICK:
      button = RS_CLK_FLAG;
      break;
    case SDL_CONTROLLER_BUTTON_LEFTSHOULDER:
      button = LB_FLAG;
      break;
    case SDL_CONTROLLER_BUTTON_RIGHTSHOULDER:
      button = RB_FLAG;
      break;
    default:
      return SDL_NOTHING;
    }
    if (event->type == SDL_CONTROLLERBUTTONDOWN)
      gamepad->buttons |= button;
    else
      gamepad->buttons &= ~button;

    LiSendMultiControllerEvent(gamepad->id, gamepad->buttons, gamepad->leftTrigger, gamepad->rightTrigger, gamepad->leftStickX, gamepad->leftStickY, gamepad->rightStickX, gamepad->rightStickY);
    break;
  }
  return SDL_NOTHING;
}

#endif /* HAVE_SDL */
                                                                                                                                                                                                                                                        moonlight-embedded-2.1.1/src/input/sdlinput.h                                                       0000664 0000000 0000000 00000002624 12563604362 0021216 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#ifdef HAVE_SDL

#include <stdbool.h>
#include <SDL.h>

static const short keyCodes[] = {
  0x14, //SDLK_CAPSLOCK
  0x70, //SDLK_F1
  0x71, //SDLK_F2
  0x72, //SDLK_F3
  0x73, //SDLK_F4
  0x74, //SDLK_F5
  0x75, //SDLK_F6
  0x76, //SDLK_F7
  0x77, //SDLK_F8
  0x78, //SDLK_F9
  0x79, //SDLK_F10
  0x7A, //SDLK_F11
  0x7B, //SDLK_F12
  0, //SDLK_PRINTSCREEN
  0x91, //SDLK_SCROLLLOCK
  0x13, //SDLK_PAUSE
  0x9B, //SDLK_INSERT
  0x24, //SDLK_HOME
  0x21, //SDLK_PAGEUP
  0, //Not used
  0x23, //SDLK_END
  0x22, //SDLK_PAGEDOWN
  0x27, //SDLK_RIGHT
  0x25, //SDLK_LEFT
  0x28, //SDLK_DOWN
  0x26, //SDLK_UP
};

void sdlinput_init();
int sdlinput_handle_event(SDL_Event* event);

#endif /* HAVE_SDL */
                                                                                                            moonlight-embedded-2.1.1/src/input/udev.c                                                           0000664 0000000 0000000 00000005430 12563604362 0020310 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#include "../loop.h"

#include "evdev.h"

#include <libudev.h>

#include <stdbool.h>
#include <stddef.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <poll.h>

static bool autoadd;
static char* defaultMapfile;

static struct udev *udev;
static struct udev_monitor *udev_mon;
static int udev_fd;

static int udev_handle(int fd) {
  struct udev_device *dev = udev_monitor_receive_device(udev_mon);
  const char *action = udev_device_get_action(dev);
  if (action != NULL) {
    if (autoadd && strcmp("add", action) == 0) {
      const char *devnode = udev_device_get_devnode(dev);
      int id;
      if (devnode != NULL && sscanf(devnode, "/dev/input/event%d", &id) == 1) {
        evdev_create(devnode, defaultMapfile);
      }
    }
    udev_device_unref(dev);
  }
  return LOOP_OK;
}

void udev_init(bool autoload, char* mapfile) {
  udev = udev_new();
  if (!udev) {
    fprintf(stderr, "Can't create udev\n");
    exit(1);
  }

  autoadd = autoload;
  if (autoload) {
    struct udev_enumerate *enumerate = udev_enumerate_new(udev);
    udev_enumerate_add_match_subsystem(enumerate, "input");
    udev_enumerate_scan_devices(enumerate);
    struct udev_list_entry *devices = udev_enumerate_get_list_entry(enumerate);

    struct udev_list_entry *dev_list_entry;
    udev_list_entry_foreach(dev_list_entry, devices) {
      const char *path = udev_list_entry_get_name(dev_list_entry);
      struct udev_device *dev = udev_device_new_from_syspath(udev, path);
      const char *devnode = udev_device_get_devnode(dev);
      int id;
      if (devnode != NULL && sscanf(devnode, "/dev/input/event%d", &id) == 1) {
        evdev_create(devnode, mapfile);
      }
      udev_device_unref(dev);
    }

    udev_enumerate_unref(enumerate);
  }

  udev_mon = udev_monitor_new_from_netlink(udev, "udev");
  udev_monitor_filter_add_match_subsystem_devtype(udev_mon, "input", NULL);
  udev_monitor_enable_receiving(udev_mon);

  defaultMapfile = mapfile;

  int udev_fd = udev_monitor_get_fd(udev_mon);
  loop_add_fd(udev_fd, &udev_handle, POLLIN);
}

void evdev_destroy() {
  udev_unref(udev);
}
                                                                                                                                                                                                                                        moonlight-embedded-2.1.1/src/input/udev.h                                                           0000664 0000000 0000000 00000001434 12563604362 0020315 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

void udev_init(bool autoload, char* mapfile);
void evdev_destroy();
                                                                                                                                                                                                                                    moonlight-embedded-2.1.1/src/loop.c                                                                 0000664 0000000 0000000 00000005460 12563604362 0017162 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#include "loop.h"

#include "global.h"

#include <sys/stat.h>
#include <sys/signalfd.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <poll.h>
#include <signal.h>
#include <string.h>

static struct pollfd* fds = NULL;
static FdHandler* fdHandlers = NULL;
static int numFds = 0;

static int sigFd;

static int loop_sig_handler(int fd) {
  struct signalfd_siginfo info;
  read(fd, &info, sizeof(info));
  switch (info.ssi_signo) {
    case SIGINT:
    case SIGTERM:
    case SIGQUIT:
    case SIGHUP:
      return LOOP_RETURN;
  }
  return LOOP_OK;
}

void loop_add_fd(int fd, FdHandler handler, int events) {
  int fdindex = numFds;
  numFds++;

  if (fds == NULL) {
    fds = malloc(sizeof(struct pollfd));
    fdHandlers = malloc(sizeof(FdHandler*));
  } else {
    fds = realloc(fds, sizeof(struct pollfd)*numFds);
    fdHandlers = realloc(fdHandlers, sizeof(FdHandler*)*numFds);
  }

  if (fds == NULL || fdHandlers == NULL) {
    fprintf(stderr, "Not enough memory\n");
    exit(EXIT_FAILURE);
  }

  fds[fdindex].fd = fd;
  fds[fdindex].events = events;
  fdHandlers[fdindex] = handler;
}

void loop_remove_fd(int fd) {
  numFds--;
  int fdindex;
  
  for (int i=0;i<numFds;i++) {
    if (fds[i].fd = fd)
      fdindex = i;
      break;
  }
  
  if (fdindex != numFds && numFds > 0) {
    memcpy(&fds[fdindex], &fds[numFds], sizeof(struct pollfd));
    memcpy(&fdHandlers[fdindex], &fdHandlers[numFds], sizeof(FdHandler*));
  }
}

void loop_main() {
  main_thread_id = pthread_self();
  sigset_t sigset;
  sigemptyset(&sigset);
  sigaddset(&sigset, SIGHUP);
  sigaddset(&sigset, SIGTERM);
  sigaddset(&sigset, SIGINT);
  sigaddset(&sigset, SIGQUIT);
  sigprocmask(SIG_BLOCK, &sigset, NULL);
  sigFd = signalfd(-1, &sigset, 0);
  loop_add_fd(sigFd, loop_sig_handler, POLLIN | POLLERR | POLLHUP);

//static bool evdev_poll(bool (*handler) (struct input_event*, struct input_device*)) {
  while (poll(fds, numFds, -1)) {
    for (int i=0;i<numFds;i++) {
      if (fds[i].revents > 0) {
        int ret = fdHandlers[i](fds[i].fd);
        if (ret == LOOP_RETURN) {
          return;
        }
      }
    }
  }
}
                                                                                                                                                                                                                moonlight-embedded-2.1.1/src/loop.h                                                                 0000664 0000000 0000000 00000001613 12563604362 0017163 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#define LOOP_RETURN 1
#define LOOP_OK 0

typedef int(*FdHandler)(int fd);

void loop_add_fd(int fd, FdHandler handler, int events);
void loop_remove_fd(int fd);

void loop_main();                                                                                                                     moonlight-embedded-2.1.1/src/main.c                                                                 0000664 0000000 0000000 00000016660 12563604362 0017141 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#include "loop.h"
#include "client.h"
#include "connection.h"
#include "audio.h"
#include "discover.h"
#include "config.h"
#include "platform.h"
#include "sdl.h"

#include "input/evdev.h"
#include "input/udev.h"
#include "input/cec.h"
#include "input/sdlinput.h"

#include "limelight-common/Limelight.h"

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <openssl/rand.h>

static void applist(PSERVER_DATA server) {
  PAPP_LIST list = NULL;
  if (gs_applist(server, &list) != GS_OK) {
    fprintf(stderr, "Can't get app list\n");
    return;
  }

  for (int i = 1;list != NULL;i++) {
    printf("%d. %s\n", i, list->name);
    list = list->next;
  }
}

static int get_app_id(PSERVER_DATA server, const char *name) {
  PAPP_LIST list = NULL;
  if (gs_applist(server, &list) != GS_OK) {
    fprintf(stderr, "Can't get app list\n");
    return -1;
  }

  while (list != NULL) {
    if (strcmp(list->name, name) == 0)
      return list->id;

    list = list->next;
  }
  return -1;
}

static void stream(PSERVER_DATA server, PCONFIGURATION config, enum platform system) {
  int appId = get_app_id(server, config->app);
  if (appId<0) {
    fprintf(stderr, "Can't find app %s\n", config->app);
    exit(-1);
  }

  gs_start_app(server, &config->stream, appId, config->sops, config->localaudio);

  void *context = NULL;
  #ifdef HAVE_SDL
  if (system == SDL)
    context = sdl_window;
  #endif

  LiStartConnection(server->address, &config->stream, &connection_callbacks, platform_get_video(system), platform_get_audio(system), context, 0, server->serverMajorVersion);

  if (IS_EMBEDDED(system)) {
    evdev_start();
    loop_main();
    evdev_stop();
  }
  #ifdef HAVE_SDL
  else if (system == SDL)
    sdl_loop();
  #endif

  LiStopConnection();
}

static void help() {
  printf("Usage: moonlight [action] (options) [host]\n");
  printf("       moonlight [configfile]\n");
  printf("\n Actions\n\n");
  printf("\tmap\t\t\tCreate mapping file for gamepad\n");
  printf("\tpair\t\t\tPair device with computer\n");
  printf("\tstream\t\t\tStream computer to device\n");
  printf("\tlist\t\t\tList available games and applications\n");
  printf("\tquit\t\t\tQuit the application or game being streamed\n");
  printf("\thelp\t\t\tShow this help\n");
  printf("\n Global Options\n\n");
  printf("\t-config <config>\tLoad configuration file\n");
  printf("\t-save <config>\t\tSave configuration file\n");
  printf("\n Streaming options\n\n");
  printf("\t-720\t\t\tUse 1280x720 resolution [default]\n");
  printf("\t-1080\t\t\tUse 1920x1080 resolution\n");
  printf("\t-width <width>\t\tHorizontal resolution (default 1280)\n");
  printf("\t-height <height>\tVertical resolution (default 720)\n");
  printf("\t-30fps\t\t\tUse 30fps\n");
  printf("\t-60fps\t\t\tUse 60fps [default]\n");
  printf("\t-bitrate <bitrate>\tSpecify the bitrate in Kbps\n");
  printf("\t-packetsize <size>\tSpecify the maximum packetsize in bytes\n");
  printf("\t-remote\t\t\tEnable remote optimizations\n");
  printf("\t-app <app>\t\tName of app to stream\n");
  printf("\t-nosops\t\t\tDon't allow GFE to modify game settings\n");
  printf("\t-localaudio\t\tPlay audio locally\n");
  printf("\t-keydir <directory>\tLoad encryption keys from directory\n");
  #ifdef HAVE_EMBEDDED
  printf("\n I/O options\n\n");
  printf("\t-mapping <file>\t\tUse <file> as gamepad mapping configuration file (use before -input)\n");
  printf("\t-input <device>\t\tUse <device> as input. Can be used multiple times\n");
  printf("\t-audio <device>\t\tUse <device> as ALSA audio output device (default sysdefault)\n");
  #endif
  printf("\nUse Ctrl+Alt+Shift+Q to exit streaming session\n\n");
  exit(0);
}

static void pair_check(PSERVER_DATA server) {
  if (!server->paired) {
    fprintf(stderr, "You must pair with the PC first\n");
    exit(-1);
  }
}

int main(int argc, char* argv[]) {
  CONFIGURATION config;
  config_parse(argc, argv, &config);

  if (config.action == NULL || strcmp("help", config.action) == 0)
    help();
  
  enum platform system = platform_check(config.platform);
  if (system == 0) {
    fprintf(stderr, "Platform '%s' not found\n", config.platform);
    exit(-1);
  }
  
  if (strcmp("map", config.action) == 0) {
    if (config.address == NULL) {
      perror("No filename for mapping");
      exit(-1);
    }
    udev_init(!inputAdded, config.mapping);
    for (int i=0;i<config.inputsCount;i++)
      evdev_create(config.inputs[i].path, config.inputs[i].mapping);
    
    evdev_map(config.address);
    exit(0);
  }

  if (config.address == NULL) {
    config.address = malloc(MAX_ADDRESS_SIZE);
    if (config.address == NULL) {
      perror("Not enough memory");
      exit(-1);
    }
    config.address[0] = 0;
    gs_discover_server(config.address);
    if (config.address[0] == 0) {
      fprintf(stderr, "Autodiscovery failed. Specify an IP address next time.\n");
      exit(-1);
    }
  }
  
  char host_config_file[128];
  sprintf(host_config_file, "hosts/%s.conf", config.address);
  config_file_parse(host_config_file, &config);

  SERVER_DATA server;
  server.address = config.address;
  int ret;
  if ((ret = gs_init(&server, config.key_dir)) == GS_OUT_OF_MEMORY) {
    fprintf(stderr, "Not enough memory\n");
    exit(-1);
  } else if (ret == GS_INVALID) {
    fprintf(stderr, "Invalid data received from server: %s\n", config.address, gs_error);
    exit(-1);
  } else if (ret != GS_OK) {
    fprintf(stderr, "Can't connect to server %s\n", config.address);
    exit(-1);
  }

  if (strcmp("list", config.action) == 0) {
    pair_check(&server);
    applist(&server);
  } else if (strcmp("stream", config.action) == 0) {
    pair_check(&server);
    if (IS_EMBEDDED(system)) {
      for (int i=0;i<config.inputsCount;i++)
        evdev_create(config.inputs[i].path, config.inputs[i].mapping);

      udev_init(!inputAdded, config.mapping);
      evdev_init();
      #ifdef HAVE_LIBCEC
      cec_init();
      #endif /* HAVE_LIBCEC */
    }
    #ifdef HAVE_SDL
    else if (system == SDL)
      sdl_init(config.stream.width, config.stream.height);
    #endif

    stream(&server, &config, system);
  } else if (strcmp("pair", config.action) == 0) {
    char pin[5];
    sprintf(pin, "%d%d%d%d", (int)random() % 10, (int)random() % 10, (int)random() % 10, (int)random() % 10);
    printf("Please enter the following PIN on the target PC: %s\n", pin);
    if (gs_pair(&server, &pin[0]) != GS_OK) {
      fprintf(stderr, "Failed to pair to server: %s\n", gs_error);
    } else {
      printf("Succesfully paired\n");
    }
  } else if (strcmp("quit", config.action) == 0) {
    pair_check(&server);
    gs_quit_app(&server);
  } else
    fprintf(stderr, "%s is not a valid action\n", config.action);
}
                                                                                moonlight-embedded-2.1.1/src/platform.c                                                             0000664 0000000 0000000 00000004613 12563604362 0020034 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#define _GNU_SOURCE

#include "platform.h"
#include "audio.h"

#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <dlfcn.h>

typedef bool(*ImxInit)();

enum platform platform_check(char* name) {
  bool std = strcmp(name, "default") == 0;
  #ifdef HAVE_SDL
  if (std || strcmp(name, "sdl") == 0)
    return SDL;
  #endif
  #ifdef HAVE_IMX
  if (std || strcmp(name, "imx") == 0) {
    void *handle = dlopen("libmoonlight-imx.so", RTLD_NOW | RTLD_GLOBAL);
    ImxInit video_imx_init = (ImxInit) dlsym(RTLD_DEFAULT, "video_imx_init");
    if (handle != NULL) {
      if (video_imx_init())
        return IMX;
    }
  }
  #endif
  #ifdef HAVE_PI
  if (std || strcmp(name, "pi") == 0) {
    void *handle = dlopen("libmoonlight-pi.so", RTLD_NOW | RTLD_GLOBAL);
    if (handle != NULL && dlsym(RTLD_DEFAULT, "bcm_host_init") != NULL)
      return PI;
  }
  #endif
  #ifdef HAVE_FAKE
  if (std || strcmp(name, "fake") == 0)
    return FAKE;
  #endif
  return 0;
}

DECODER_RENDERER_CALLBACKS* platform_get_video(enum platform system) {
  switch (system) {
  #ifdef HAVE_SDL
  case SDL:
    return &decoder_callbacks_sdl;
  #endif
  #ifdef HAVE_IMX
  case IMX:
    return (PDECODER_RENDERER_CALLBACKS) dlsym(RTLD_DEFAULT, "decoder_callbacks_imx");
  #endif
  #ifdef HAVE_PI
  case PI:
    return (PDECODER_RENDERER_CALLBACKS) dlsym(RTLD_DEFAULT, "decoder_callbacks_pi");
  #endif
  #ifdef HAVE_FAKE
  case FAKE:
    return &decoder_callbacks_fake;
  #endif
  }
  return NULL;
}

AUDIO_RENDERER_CALLBACKS* platform_get_audio(enum platform system) {
  switch (system) {
  #ifdef HAVE_SDL
  case SDL:
    return &audio_callbacks_sdl;
  #endif
  default:
    return &audio_callbacks_alsa;
  }
  return NULL;
}
                                                                                                                     moonlight-embedded-2.1.1/src/platform.h                                                             0000664 0000000 0000000 00000002367 12563604362 0020045 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#include "limelight-common/Limelight.h"

#include <dlfcn.h>
#include <stdlib.h>
#include <stdio.h>

#define IS_EMBEDDED(SYSTEM) SYSTEM != SDL

enum platform { NONE, SDL, PI, IMX, FAKE };

enum platform platform_check(char*);
PDECODER_RENDERER_CALLBACKS platform_get_video(enum platform system);
PAUDIO_RENDERER_CALLBACKS platform_get_audio(enum platform system);

#ifdef HAVE_FAKE
extern DECODER_RENDERER_CALLBACKS decoder_callbacks_fake;
#endif
#ifdef HAVE_SDL
extern DECODER_RENDERER_CALLBACKS decoder_callbacks_sdl;
void sdl_loop();
#endif
                                                                                                                                                                                                                                                                         moonlight-embedded-2.1.1/src/sdl.c                                                                  0000664 0000000 0000000 00000003752 12563604362 0016775 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#ifdef HAVE_SDL

#include "sdl.h"
#include "input/sdlinput.h"

#include "limelight-common/Limelight.h"

#include <stdbool.h>

static bool done;
static int fullscreen_flags;

SDL_Window *sdl_window;

void sdl_init(int width, int height) {
  if(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_EVENTS)) {
    fprintf(stderr, "Could not initialize SDL - %s\n", SDL_GetError());
    exit(1);
  }

  sdl_window = SDL_CreateWindow("Moonlight", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, width, height, 0);
  if(!sdl_window) {
    fprintf(stderr, "SDL: could not create window - exiting\n");
    exit(1);
  }
  SDL_SetRelativeMouseMode(SDL_TRUE);
  sdlinput_init();
}

void sdl_loop() {
  SDL_Event event;
  while(!done && SDL_WaitEvent(&event)) {
    switch (sdlinput_handle_event(&event)) {
    case SDL_QUIT_APPLICATION:
      done = true;
      break;
    case SDL_TOGGLE_FULLSCREEN:
      fullscreen_flags ^= SDL_WINDOW_FULLSCREEN;
      SDL_SetWindowFullscreen(sdl_window, fullscreen_flags);
    case SDL_MOUSE_GRAB:
      SDL_SetRelativeMouseMode(SDL_TRUE);
      break;
    case SDL_MOUSE_UNGRAB:
      SDL_SetRelativeMouseMode(SDL_FALSE);
      break;
    default:
      if (event.type == SDL_QUIT)
        done = true;
    }
  }

  SDL_DestroyWindow(sdl_window);
  SDL_Quit();
}

#endif /* HAVE_SDL */
                      moonlight-embedded-2.1.1/src/sdl.h                                                                  0000664 0000000 0000000 00000001754 12563604362 0017002 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#ifdef HAVE_SDL

#include <SDL.h>

#define SDL_NOTHING 0
#define SDL_QUIT_APPLICATION 1
#define SDL_MOUSE_GRAB 2
#define SDL_MOUSE_UNGRAB 3
#define SDL_TOGGLE_FULLSCREEN 4

SDL_Window *sdl_window;

void sdl_init(int width, int height);
void sdl_loop();

#endif /* HAVE_SDL */
                    moonlight-embedded-2.1.1/src/sdl/                                                                   0000775 0000000 0000000 00000000000 12563604362 0016622 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        moonlight-embedded-2.1.1/src/sdl/input.h                                                            0000664 0000000 0000000 00000002554 12563604362 0020140 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#include <stdbool.h>
#include <SDL.h>

static const short keyCodes[] = {
  0x14, //SDLK_CAPSLOCK
  0x70, //SDLK_F1
  0x71, //SDLK_F2
  0x72, //SDLK_F3
  0x73, //SDLK_F4
  0x74, //SDLK_F5
  0x75, //SDLK_F6
  0x76, //SDLK_F7
  0x77, //SDLK_F8
  0x78, //SDLK_F9
  0x79, //SDLK_F10
  0x7A, //SDLK_F11
  0x7B, //SDLK_F12
  0, //SDLK_PRINTSCREEN
  0x91, //SDLK_SCROLLLOCK
  0x13, //SDLK_PAUSE
  0x9B, //SDLK_INSERT
  0x24, //SDLK_HOME
  0x21, //SDLK_PAGEUP
  0, //Not used
  0x23, //SDLK_END
  0x22, //SDLK_PAGEDOWN
  0x27, //SDLK_RIGHT
  0x25, //SDLK_LEFT
  0x28, //SDLK_DOWN
  0x26, //SDLK_UP
};

void sdlinput_init();
int sdlinput_handle_event(SDL_Event* event);
                                                                                                                                                    moonlight-embedded-2.1.1/src/sdl/platform.c                                                         0000664 0000000 0000000 00000003671 12563604362 0020621 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#include "sdl.h"
#include "input.h"

#include "limelight-common/Limelight.h"

#include <stdbool.h>

static bool done;
static int fullscreen_flags;

SDL_Window *sdl_window;

void sdl_init(int width, int height) {
  if(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_EVENTS)) {
    fprintf(stderr, "Could not initialize SDL - %s\n", SDL_GetError());
    exit(1);
  }

  sdl_window = SDL_CreateWindow("Moonlight", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, width, height, 0);
  if(!sdl_window) {
    fprintf(stderr, "SDL: could not create window - exiting\n");
    exit(1);
  }
  SDL_SetRelativeMouseMode(SDL_TRUE);
  sdlinput_init();
}

void sdl_loop() {
  SDL_Event event;
  while(!done && SDL_WaitEvent(&event)) {
    switch (sdlinput_handle_event(&event)) {
    case SDL_QUIT_APPLICATION:
      done = true;
      break;
    case SDL_TOGGLE_FULLSCREEN:
      fullscreen_flags ^= SDL_WINDOW_FULLSCREEN;
      SDL_SetWindowFullscreen(sdl_window, fullscreen_flags);
    case SDL_MOUSE_GRAB:
      SDL_SetRelativeMouseMode(SDL_TRUE);
      break;
    case SDL_MOUSE_UNGRAB:
      SDL_SetRelativeMouseMode(SDL_FALSE);
      break;
    default:
      if (event.type == SDL_QUIT)
        done = true;
    }
  }

  SDL_DestroyWindow(sdl_window);
  SDL_Quit();
}
                                                                       moonlight-embedded-2.1.1/src/sdl/sdl.h                                                              0000664 0000000 0000000 00000001704 12563604362 0017557 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#include <SDL.h>

#define SDL_NOTHING 0
#define SDL_QUIT_APPLICATION 1
#define SDL_MOUSE_GRAB 2
#define SDL_MOUSE_UNGRAB 3
#define SDL_TOGGLE_FULLSCREEN 4

SDL_Window *sdl_window;

void sdl_init(int width, int height);
void sdl_loop();
                                                            moonlight-embedded-2.1.1/src/sdl/video.c                                                            0000664 0000000 0000000 00000005553 12563604362 0020104 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#include "../video/ffmpeg.h"

#include "limelight-common/Limelight.h"

#include <SDL.h>
#include <SDL_thread.h>

#define DECODER_BUFFER_SIZE 92*1024

static SDL_Window *window;
static SDL_Renderer *renderer;
static SDL_Texture *bmp = NULL;
static int screen_width, screen_height;
static char* ffmpeg_buffer;

static void sdl_setup(int width, int height, int redrawRate, void* context, int drFlags) {
  int avc_flags = FAST_BILINEAR_FILTERING;
  if (ffmpeg_init(width, height, 2, avc_flags) < 0) {
    fprintf(stderr, "Couldn't initialize video decoding\n");
    exit(1);
  }
  
  ffmpeg_buffer = malloc(DECODER_BUFFER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);
  if (ffmpeg_buffer == NULL) {
    fprintf(stderr, "Not enough memory\n");
    exit(1);
  }

  SDL_Window *window = (SDL_Window*) context;
  renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
  if (!renderer) {
    fprintf(stderr, "SDL: could not create renderer - exiting\n");
    exit(1);
  }

  bmp = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_TARGET, width, height);
  if (!bmp) {
    fprintf(stderr, "SDL: could not create texture - exiting\n");
    exit(1);
  }
}

static void sdl_cleanup() {
  ffmpeg_destroy();
}

static int sdl_submit_decode_unit(PDECODE_UNIT decodeUnit) {
  if (decodeUnit->fullLength < DECODER_BUFFER_SIZE) {
    PLENTRY entry = decodeUnit->bufferList;
    int length = 0;
    while (entry != NULL) {
      memcpy(ffmpeg_buffer+length, entry->data, entry->length);
      length += entry->length;
      entry = entry->next;
    }

    int ret = ffmpeg_decode(ffmpeg_buffer, length);
    if (ret == 1) {
      AVFrame* frame = ffmpeg_get_frame();

      SDL_UpdateYUVTexture(bmp, NULL, frame->data[0], frame->linesize[0], frame->data[1], frame->linesize[1], frame->data[2], frame->linesize[2]);
      SDL_RenderClear(renderer);
      SDL_RenderCopy(renderer, bmp, NULL, NULL);
      SDL_RenderPresent(renderer);
    }
  } else {
    fprintf(stderr, "Video decode buffer too small");
    exit(1);
  }

  return DR_OK;
}

DECODER_RENDERER_CALLBACKS decoder_callbacks_sdl = {
  .setup = sdl_setup,
  .cleanup = sdl_cleanup,
  .submitDecodeUnit = sdl_submit_decode_unit,
};
                                                                                                                                                     moonlight-embedded-2.1.1/src/video/                                                                 0000775 0000000 0000000 00000000000 12563604362 0017146 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        moonlight-embedded-2.1.1/src/video/fake.c                                                           0000664 0000000 0000000 00000002726 12563604362 0020227 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#include "limelight-common/Limelight.h"

#include <stdio.h>

static FILE* fd;
static const char* fileName = "fake.h264";

void decoder_renderer_setup(int width, int height, int redrawRate, void* context, int drFlags) {
  fd = fopen(fileName, "w");
}

void decoder_renderer_cleanup() {
  fclose(fd);
}

int decoder_renderer_submit_decode_unit(PDECODE_UNIT decodeUnit) {
  PLENTRY entry = decodeUnit->bufferList;
  while (entry != NULL) {
    fwrite(entry->data, entry->length, 1, fd);
    entry = entry->next;
  }
  return DR_OK;
}

DECODER_RENDERER_CALLBACKS decoder_callbacks_fake = {
  .setup = decoder_renderer_setup,
  .cleanup = decoder_renderer_cleanup,
  .submitDecodeUnit = decoder_renderer_submit_decode_unit,
  .capabilities = CAPABILITY_DIRECT_SUBMIT,
};
                                          moonlight-embedded-2.1.1/src/video/ffmpeg.c                                                         0000664 0000000 0000000 00000010407 12563604362 0020560 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Based on Moonlight Pc implementation
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#include "ffmpeg.h"

#include <stdlib.h>
#include <libswscale/swscale.h>
#include <pthread.h>
#include <stdio.h>

// General decoder and renderer state
static AVPacket pkt;
static AVCodec* decoder;
static AVCodecContext* decoder_ctx;
static AVFrame* dec_frame;
static struct SwsContext* scaler_ctx;

#define BYTES_PER_PIXEL 4

// This function must be called before
// any other decoding functions
int ffmpeg_init(int width, int height, int perf_lvl, int thread_count) {
  // Initialize the avcodec library and register codecs
  av_log_set_level(AV_LOG_QUIET);
  avcodec_register_all();

  av_init_packet(&pkt);

  decoder = avcodec_find_decoder(AV_CODEC_ID_H264);
  if (decoder == NULL) {
    printf("Couldn't find H264 decoder");
    return -1;
  }

  decoder_ctx = avcodec_alloc_context3(decoder);
  if (decoder_ctx == NULL) {
    printf("Couldn't allocate context");
    return -1;
  }

  if (perf_lvl & DISABLE_LOOP_FILTER)
    // Skip the loop filter for performance reasons
    decoder_ctx->skip_loop_filter = AVDISCARD_ALL;

  if (perf_lvl & LOW_LATENCY_DECODE)
    // Use low delay single threaded encoding
    decoder_ctx->flags |= CODEC_FLAG_LOW_DELAY;

  if (perf_lvl & SLICE_THREADING)
    decoder_ctx->thread_type = FF_THREAD_SLICE;
  else
    decoder_ctx->thread_type = FF_THREAD_FRAME;

  decoder_ctx->thread_count = thread_count;

  decoder_ctx->width = width;
  decoder_ctx->height = height;
  decoder_ctx->pix_fmt = PIX_FMT_YUV420P;

  int err = avcodec_open2(decoder_ctx, decoder, NULL);
  if (err < 0) {
    printf("Couldn't open codec");
    return err;
  }

  dec_frame = av_frame_alloc();
  if (dec_frame == NULL) {
    printf("Couldn't allocate frame");
    return -1;
  }
  
  int filtering;
  if (perf_lvl & FAST_BILINEAR_FILTERING)
    filtering = SWS_FAST_BILINEAR;
  else if (perf_lvl & BILINEAR_FILTERING)
    filtering = SWS_BILINEAR;
  else
    filtering = SWS_BICUBIC;

  scaler_ctx = sws_getContext(decoder_ctx->width, decoder_ctx->height, decoder_ctx->pix_fmt, decoder_ctx->width, decoder_ctx->height, PIX_FMT_YUV420P, filtering, NULL, NULL, NULL);
  if (scaler_ctx == NULL) {
    printf("Couldn't get scaler context");
    return -1;
  }

  return 0;
}

// This function must be called after
// decoding is finished
void ffmpeg_destroy(void) {
  if (decoder_ctx) {
    avcodec_close(decoder_ctx);
    av_free(decoder_ctx);
    decoder_ctx = NULL;
  }
  if (scaler_ctx) {
    sws_freeContext(scaler_ctx);
    scaler_ctx = NULL;
  }
  if (dec_frame) {
    av_frame_free(&dec_frame);
    dec_frame = NULL;
  }
}

int ffmpeg_draw_frame(AVFrame *pict) {
  int err = sws_scale(scaler_ctx, (const uint8_t* const*) dec_frame->data, dec_frame->linesize, 0, decoder_ctx->height, pict->data, pict->linesize);

  if (err != decoder_ctx->height) {
    fprintf(stderr, "Scaling failed\n");
    return 0;
  }
  
  return 1;
}

AVFrame* ffmpeg_get_frame() {
  return dec_frame;
}

// packets must be decoded in order
// indata must be inlen + FF_INPUT_BUFFER_PADDING_SIZE in length
int ffmpeg_decode(unsigned char* indata, int inlen) {
  int err;
  int got_pic = 0;

  pkt.data = indata;
  pkt.size = inlen;

  while (pkt.size > 0) {
    got_pic = 0;
    err = avcodec_decode_video2(decoder_ctx, dec_frame, &got_pic, &pkt);
    if (err < 0) {
      fprintf(stderr, "Decode failed\n");
      got_pic = 0;
      break;
    }

    pkt.size -= err;
    pkt.data += err;
  }
  
  if (got_pic) {
    return 1;
  }

  return err < 0 ? err : 0;
}
                                                                                                                                                                                                                                                         moonlight-embedded-2.1.1/src/video/ffmpeg.h                                                         0000664 0000000 0000000 00000002726 12563604362 0020572 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 * 
 * Based on Moonlight Pc implementation
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#include <libavcodec/avcodec.h>

// Disables the deblocking filter at the cost of image quality
#define DISABLE_LOOP_FILTER 0x1
// Uses the low latency decode flag (disables multithreading)
#define LOW_LATENCY_DECODE 0x2
// Threads process each slice, rather than each frame
#define SLICE_THREADING 0x4
// Uses nonstandard speedup tricks
#define FAST_DECODE 0x8
// Uses bilinear filtering instead of bicubic
#define BILINEAR_FILTERING 0x10
// Uses a faster bilinear filtering with lower image quality
#define FAST_BILINEAR_FILTERING 0x20

int ffmpeg_init(int width, int height, int perf_lvl, int thread_count);
void ffmpeg_destroy(void);

int ffmpeg_draw_frame(AVFrame *pict);
AVFrame* ffmpeg_get_frame();
int ffmpeg_decode(unsigned char* indata, int inlen);
                                          moonlight-embedded-2.1.1/src/video/imx.c                                                            0000664 0000000 0000000 00000030237 12563604362 0020114 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#include "limelight-common/Limelight.h"

#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <libv4l2.h>
#include <fcntl.h>

#include <sys/stat.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/mman.h>
#include <sys/ioctl.h>

#include <linux/ioctl.h>
#include <linux/mxc_v4l2.h>
#include <linux/mxcfb.h>
#include <linux/v4l2-common.h>
#include <linux/v4l2-controls.h>
#include <linux/videodev2.h>

#include <vpu_io.h>
#include <vpu_lib.h>

#define STREAM_BUF_SIZE 0x200000
#define PS_SAVE_SIZE 0x080000

#define MODE420 1
#define MODE422 2
#define MODE224 3

struct v4l_buf {
  void *start;
  off_t offset;
  size_t length;
};

static vpu_mem_desc mem_desc = {0};
static vpu_mem_desc ps_mem_desc = {0};
static vpu_mem_desc slice_mem_desc = {0};

static DecHandle handle = {0};
static DecParam decparam = {0};
static int fd;

static bool initialized = false, decoding = false, displaying = false;

static int queued_count, threshold;
static int disp_clr_index = 0;

static FrameBuffer *fb;
static struct v4l2_buffer dbuf;

bool video_imx_init() {
  return vpu_Init(NULL) == RETCODE_SUCCESS;
}

static void decoder_renderer_setup(int width, int height, int redrawRate, void* context, int drFlags) {
  struct mxcfb_gbl_alpha alpha;

  dbuf.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
  dbuf.memory = V4L2_MEMORY_MMAP;
  
  int fd_fb = open("/dev/fb0", O_RDWR, 0);

  if (fd_fb < 0){
    fprintf(stderr, "Can't access framebuffer\n");
    exit(EXIT_FAILURE);
  }

  alpha.alpha = 0;
  alpha.enable = 1;
  if (ioctl(fd_fb, MXCFB_SET_GBL_ALPHA, &alpha) < 0){
    fprintf(stderr, "Can't set framebuffer output\n");
    exit(EXIT_FAILURE);
  }

  close(fd_fb);
  
  mem_desc.size = STREAM_BUF_SIZE;
  if (IOGetPhyMem(&mem_desc)){
    fprintf(stderr, "Can't get physical memory address\n");
    exit(EXIT_FAILURE);
  }

  if (IOGetVirtMem(&mem_desc) <= 0) {
    fprintf(stderr, "Can't get virtual memory address\n");
    exit(EXIT_FAILURE);
  }

  ps_mem_desc.size = PS_SAVE_SIZE;
  if (IOGetPhyMem(&ps_mem_desc)) {
    fprintf(stderr, "Can't get physical memory address\n");
    exit(EXIT_FAILURE);
  }

  DecOpenParam oparam = {0};
  oparam.bitstreamFormat = STD_AVC;
  oparam.bitstreamBuffer = mem_desc.phy_addr;
  oparam.bitstreamBufferSize = STREAM_BUF_SIZE;
  oparam.pBitStream = (Uint8 *) mem_desc.virt_uaddr;
  oparam.reorderEnable = 1;
  oparam.mp4DeblkEnable = 0;
  oparam.chromaInterleave = 0;
  oparam.avcExtension = oparam.mp4Class = 0;
  oparam.mjpg_thumbNailDecEnable = 0;
  oparam.mapType = LINEAR_FRAME_MAP;
  oparam.tiled2LinearEnable = 0;
  oparam.bitstreamMode = 1;

  oparam.psSaveBuffer = ps_mem_desc.phy_addr;
  oparam.psSaveBufferSize = PS_SAVE_SIZE;

  if (vpu_DecOpen(&handle, &oparam) != RETCODE_SUCCESS) {
    fprintf(stderr, "Can't open video decoder\n");
    exit(EXIT_FAILURE);
  }

  decparam.dispReorderBuf = 0;
  decparam.skipframeMode = 0;
  decparam.skipframeNum = 0;
  decparam.iframeSearchEnable = 0;
}

static int decoder_renderer_submit_decode_unit(PDECODE_UNIT decodeUnit) {
  PLENTRY entry = decodeUnit->bufferList;
  while (entry != NULL) {
    Uint32 space;
    PhysicalAddress pa_read_ptr, pa_write_ptr;
    if (vpu_DecGetBitstreamBuffer(handle, &pa_read_ptr, &pa_write_ptr, &space) != RETCODE_SUCCESS) {
      fprintf(stderr, "Can't get video decoder buffer\n");
      exit(EXIT_FAILURE);
    }

    Uint32 target_addr = mem_desc.virt_uaddr + (pa_write_ptr - mem_desc.phy_addr);

    if ( (target_addr + entry->length) > mem_desc.virt_uaddr + STREAM_BUF_SIZE) {
      int room = mem_desc.virt_uaddr + STREAM_BUF_SIZE - target_addr;
      memcpy((void *)target_addr, entry->data, room);
      memcpy((void *)mem_desc.virt_uaddr, entry->data + room, entry->length - room);
    } else {
      memcpy((void *)target_addr, entry->data, entry->length);
    }
    vpu_DecUpdateBitstreamBuffer(handle, entry->length);
  }

  if (!initialized) {
    initialized = true;
    
    vpu_DecSetEscSeqInit(handle, 1);
    DecInitialInfo initinfo = {0};
    if (vpu_DecGetInitialInfo(handle, &initinfo) != RETCODE_SUCCESS) {
      fprintf(stderr, "Can't get initial info\n");
      exit(EXIT_FAILURE);
    }
    vpu_DecSetEscSeqInit(handle, 0);
    
    int regfbcount = initinfo.minFrameBufferCount + 2;
    threshold = regfbcount - initinfo.minFrameBufferCount;
    int picWidth = ((initinfo.picWidth + 15) & ~15);
    int picHeight = ((initinfo.picHeight + 15) & ~15);
    int stride = picWidth;

    int phy_slicebuf_size = initinfo.worstSliceSize * 1024;
    
    slice_mem_desc.size = phy_slicebuf_size;
    if (IOGetPhyMem(&slice_mem_desc)){
      fprintf(stderr, "Can't get slice physical address\n");
      exit(EXIT_FAILURE);
    }

    fb = calloc(regfbcount, sizeof(FrameBuffer));
    if (fb == NULL) {
      fprintf(stderr, "Can't allocate framebuffers\n");
      exit(EXIT_FAILURE);
    }

    char v4l_device[16], node[8];
    sprintf(node, "%d", 17);
    strcpy(v4l_device, "/dev/video");
    strcat(v4l_device, node);
    fd = open(v4l_device, O_RDWR, 0);
    struct v4l2_format fmt = {0};
    fmt.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
    fmt.fmt.pix.width = picWidth;
    fmt.fmt.pix.height = picHeight;
    fmt.fmt.pix.bytesperline = picWidth;
    fmt.fmt.pix.field = V4L2_FIELD_ANY;
    fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUV420;
    if (ioctl(fd, VIDIOC_S_FMT, &fmt) < 0) {
      fprintf(stderr, "Can't set source video format\n");
      exit(EXIT_FAILURE);
    }

    if (ioctl(fd, VIDIOC_G_FMT, &fmt) < 0) {
      fprintf(stderr, "Can't set output video format\n");
      exit(EXIT_FAILURE);
    }

    struct v4l2_requestbuffers reqbuf = {0};
    reqbuf.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
    reqbuf.memory = V4L2_MEMORY_MMAP;
    reqbuf.count = regfbcount;

    struct v4l_buf* buffers[regfbcount];

    if (ioctl(fd, VIDIOC_REQBUFS, &reqbuf) < 0) {
      fprintf(stderr, "Can't get video buffers\n");
      exit(EXIT_FAILURE);
    }

    if (reqbuf.count < regfbcount) {
      fprintf(stderr, "Not enough video buffers\n");
      exit(EXIT_FAILURE);
    }
    
    for (int i = 0; i < regfbcount; i++) {
      struct v4l2_buffer buffer = {0};
      struct v4l_buf *buf;

      buf = calloc(1, sizeof(struct v4l_buf));
      if (buf == NULL) {
        return -9;
      }

      buffers[i] = buf;

      buffer.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
      buffer.memory = V4L2_MEMORY_MMAP;
      buffer.index = i;

      if (ioctl(fd, VIDIOC_QUERYBUF, &buffer) < 0) {
        fprintf(stderr, "Can't get video buffer\n");
        exit(EXIT_FAILURE);
      }
      buf->start = mmap(NULL, buffer.length, PROT_READ | PROT_WRITE, MAP_SHARED, fd, buffer.m.offset);

      /*
      * Workaround for new V4L interface change, this change
      * will be removed after V4L driver is updated for this.
      * Need to call QUERYBUF ioctl again after mmap.
      */
      if (ioctl(fd, VIDIOC_QUERYBUF, &buffer) < 0) {
        fprintf(stderr, "Can't set source video format\n");
        exit(EXIT_FAILURE);
      }

      buf->offset = buffer.m.offset;
      buf->length = buffer.length;

      if (buf->start == MAP_FAILED) {
        fprintf(stderr, "Failed to map video buffer\n");
        exit(EXIT_FAILURE);
      }
    }
    
    int img_size = stride * picHeight;
    vpu_mem_desc *mvcol_md = NULL;
    
    int mjpg_fmt = MODE420;
    int divX = (mjpg_fmt == MODE420 || mjpg_fmt == MODE422) ? 2 : 1;
    int divY = (mjpg_fmt == MODE420 || mjpg_fmt == MODE224) ? 2 : 1;

    mvcol_md = calloc(regfbcount, sizeof(vpu_mem_desc));

    for (int i = 0; i < regfbcount; i++) {
      fb[i].myIndex = i;
      fb[i].bufY = buffers[i]->offset;
      fb[i].bufCb = fb[i].bufY + img_size;
      fb[i].bufCr = fb[i].bufCb + (img_size / divX / divY);

      /* allocate MvCol buffer here */
      memset(&mvcol_md[i], 0, sizeof(vpu_mem_desc));
      mvcol_md[i].size = img_size / divX / divY;
      if (IOGetPhyMem(&mvcol_md[i])) {
        fprintf(stderr, "Can't get physical address of colomn buffer\n");
        exit(EXIT_FAILURE);
      }
      fb[i].bufMvCol = mvcol_md[i].phy_addr;
    }
    
    DecBufInfo bufinfo;
    bufinfo.avcSliceBufInfo.bufferBase = slice_mem_desc.phy_addr;
    bufinfo.avcSliceBufInfo.bufferSize = phy_slicebuf_size;
    
    bufinfo.maxDecFrmInfo.maxMbX = stride / 16;
    bufinfo.maxDecFrmInfo.maxMbY = picHeight / 16;
    bufinfo.maxDecFrmInfo.maxMbNum = stride * picHeight / 256;
    
    int delay = -1;
    vpu_DecGiveCommand(handle, DEC_SET_FRAME_DELAY, &delay);

    if (vpu_DecRegisterFrameBuffer(handle, fb, regfbcount, stride, &bufinfo) != RETCODE_SUCCESS) {
      fprintf(stderr, "Can't register decoder to framebuffer\n");
      exit(EXIT_FAILURE);
    }
    
    if (!decoding) {
      if (vpu_DecStartOneFrame(handle, &decparam) != RETCODE_SUCCESS) {
        fprintf(stderr, "Can't start decoding\n");
        exit(EXIT_FAILURE);
      }
      decoding = true;
    }
  }
  
  int loop_id = 0;
  while (vpu_IsBusy()) {
    if (loop_id > 50) {
      vpu_SWReset(handle, 0);
      fprintf(stderr, "VPU is too long busy\n");
      exit(EXIT_FAILURE);
    }
    vpu_WaitForInt(100);
    loop_id++;
  }
  loop_id = 0;

  if (decoding) {
    decoding = 0;

    DecOutputInfo outinfo = {0};
    if (vpu_DecGetOutputInfo(handle, &outinfo) != RETCODE_SUCCESS) {
      fprintf(stderr, "Can't get output info\n");
      exit(EXIT_FAILURE);
    }

    if (outinfo.decodingSuccess & 0x10) {
      return 0;
    } else if (outinfo.notSufficientPsBuffer) {
      fprintf(stderr, "Not enough space in stream buffer\n");
      exit(EXIT_FAILURE);
    } else if (outinfo.notSufficientSliceBuffer) {
      fprintf(stderr, "Not enough space in slice buffer\n");
      exit(EXIT_FAILURE);
    }

    if (outinfo.indexFrameDisplay >= 0) {
      struct timeval tv;
      gettimeofday(&tv, 0);
      dbuf.timestamp.tv_sec = tv.tv_sec;
      dbuf.timestamp.tv_usec = tv.tv_usec;
      dbuf.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
      dbuf.memory = V4L2_MEMORY_MMAP;

      dbuf.index = outinfo.indexFrameDisplay;
      if (ioctl(fd, VIDIOC_QUERYBUF, &dbuf) < 0) {
        fprintf(stderr, "Can't get output buffer\n");
        exit(EXIT_FAILURE);
      }

      dbuf.index = outinfo.indexFrameDisplay;
      dbuf.field =  V4L2_FIELD_NONE;
      if (ioctl(fd, VIDIOC_QBUF, &dbuf) < 0) {
        fprintf(stderr, "Can't get output buffer\n");
        exit(EXIT_FAILURE);
      }

      if (!displaying) {
        int type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
        if (ioctl(fd, VIDIOC_STREAMON, &type) < 0) {
          fprintf(stderr, "Failed to output video\n");
          exit(EXIT_FAILURE);
        }
        displaying = true;
      }

      queued_count++;

      if (queued_count > threshold) {
        dbuf.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
        dbuf.memory = V4L2_MEMORY_MMAP;
        if (ioctl(fd, VIDIOC_DQBUF, &dbuf) < 0) {
          fprintf(stderr, "Failed to dequeue buffer\n");
          exit(EXIT_FAILURE);
        } else
          queued_count--;
      } else
        dbuf.index = -1;
      
      if (disp_clr_index >= 0)
        vpu_DecClrDispFlag(handle, disp_clr_index);
      
      disp_clr_index = outinfo.indexFrameDisplay;
    } else if (outinfo.indexFrameDisplay == -1) {
      fprintf(stderr, "Failed to decode frame\n");
      exit(EXIT_FAILURE);
    }
  }

  return DR_OK;
}

static void decoder_renderer_cleanup() {
  IOFreePhyMem(&ps_mem_desc);
  IOFreePhyMem(&slice_mem_desc);
  
  IOFreeVirtMem(&mem_desc);
  IOFreePhyMem(&mem_desc);
  vpu_UnInit();
}

DECODER_RENDERER_CALLBACKS decoder_callbacks_imx = {
  .setup = decoder_renderer_setup,
  .cleanup = decoder_renderer_cleanup,
  .submitDecodeUnit = decoder_renderer_submit_decode_unit,
  .capabilities = CAPABILITY_DIRECT_SUBMIT,
};
                                                                                                                                                                                                                                                                                                                                                                 moonlight-embedded-2.1.1/src/video/pi.c                                                             0000664 0000000 0000000 00000015714 12563604362 0017732 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
  * Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.
  * Neither the name of the copyright holder nor the
  names of its contributors may be used to endorse or promote products
  derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// Video decode on Raspberry Pi using OpenMAX IL though the ilcient helper library
// Based upon video decode example from the Raspberry Pi firmware

#include "sps.h"

#include "limelight-common/Limelight.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <ilclient.h>
#include <bcm_host.h>

static TUNNEL_T tunnel[2];
static COMPONENT_T *list[3];
static ILCLIENT_T *client;

static COMPONENT_T *video_decode = NULL, *video_scheduler = NULL, *video_render = NULL;

static OMX_BUFFERHEADERTYPE *buf;
static unsigned char *dest;

static int port_settings_changed;
static int first_packet;

static void decoder_renderer_setup(int width, int height, int redrawRate, void* context, int drFlags) {
  bcm_host_init();
  gs_sps_init(width, height);

  OMX_VIDEO_PARAM_PORTFORMATTYPE format;
  OMX_TIME_CONFIG_CLOCKSTATETYPE cstate;
  COMPONENT_T *clock = NULL;
  unsigned int data_len = 0;
  int packet_size = 80<<10;

  memset(list, 0, sizeof(list));
  memset(tunnel, 0, sizeof(tunnel));

  if((client = ilclient_init()) == NULL) {
    fprintf(stderr, "Can't initialize video\n");
    exit(EXIT_FAILURE);
  }

  if(OMX_Init() != OMX_ErrorNone) {
    fprintf(stderr, "Can't initialize OMX\n");
    exit(EXIT_FAILURE);
  }

  // create video_decode
  if(ilclient_create_component(client, &video_decode, "video_decode", ILCLIENT_DISABLE_ALL_PORTS | ILCLIENT_ENABLE_INPUT_BUFFERS) != 0){
    fprintf(stderr, "Can't create video decode\n");
    exit(EXIT_FAILURE);
  }

  list[0] = video_decode;

  // create video_render
  if(ilclient_create_component(client, &video_render, "video_render", ILCLIENT_DISABLE_ALL_PORTS) != 0){
    fprintf(stderr, "Can't create video renderer\n");
    exit(EXIT_FAILURE);
  }

  list[1] = video_render;

  set_tunnel(tunnel, video_decode, 131, video_render, 90);

  ilclient_change_component_state(video_decode, OMX_StateIdle);

  memset(&format, 0, sizeof(OMX_VIDEO_PARAM_PORTFORMATTYPE));
  format.nSize = sizeof(OMX_VIDEO_PARAM_PORTFORMATTYPE);
  format.nVersion.nVersion = OMX_VERSION;
  format.nPortIndex = 130;
  format.eCompressionFormat = OMX_VIDEO_CodingAVC;

  OMX_PARAM_DATAUNITTYPE unit;

  memset(&unit, 0, sizeof(OMX_PARAM_DATAUNITTYPE));
  unit.nSize = sizeof(OMX_PARAM_DATAUNITTYPE);
  unit.nVersion.nVersion = OMX_VERSION;
  unit.nPortIndex = 130;
  unit.eUnitType = OMX_DataUnitCodedPicture;
  unit.eEncapsulationType = OMX_DataEncapsulationElementaryStream;

  if(OMX_SetParameter(ILC_GET_HANDLE(video_decode), OMX_IndexParamVideoPortFormat, &format) == OMX_ErrorNone &&
     OMX_SetParameter(ILC_GET_HANDLE(video_decode), OMX_IndexParamBrcmDataUnit, &unit) == OMX_ErrorNone &&
     ilclient_enable_port_buffers(video_decode, 130, NULL, NULL, NULL) == 0) {

    port_settings_changed = 0;
    first_packet = 1;

    ilclient_change_component_state(video_decode, OMX_StateExecuting);
  } else {
    fprintf(stderr, "Can't setup video\n");
    exit(EXIT_FAILURE);
  }
}

static void decoder_renderer_cleanup() {
  int status = 0;

  if((buf = ilclient_get_input_buffer(video_decode, 130, 1)) == NULL){
    fprintf(stderr, "Can't get video buffer\n");
    exit(EXIT_FAILURE);
  }

  buf->nFilledLen = 0;
  buf->nFlags = OMX_BUFFERFLAG_TIME_UNKNOWN | OMX_BUFFERFLAG_EOS;

  if(OMX_EmptyThisBuffer(ILC_GET_HANDLE(list[0]), buf) != OMX_ErrorNone){
    fprintf(stderr, "Can't empty video buffer\n");
    return;
  }

  // need to flush the renderer to allow video_decode to disable its input port
  ilclient_flush_tunnels(tunnel, 0);

  ilclient_disable_port_buffers(list[0], 130, NULL, NULL, NULL);

  ilclient_disable_tunnel(tunnel);
  ilclient_teardown_tunnels(tunnel);

  ilclient_state_transition(list, OMX_StateIdle);
  ilclient_state_transition(list, OMX_StateLoaded);

  ilclient_cleanup_components(list);

  OMX_Deinit();

  ilclient_destroy(client);
}

static int decoder_renderer_submit_decode_unit(PDECODE_UNIT decodeUnit) {
  if((buf = ilclient_get_input_buffer(video_decode, 130, 1)) == NULL){
    fprintf(stderr, "Can't get video buffer\n");
    exit(EXIT_FAILURE);
  }

  // feed data and wait until we get port settings changed
  dest = buf->pBuffer;

  buf->nFilledLen = 0;

  buf->nOffset = 0;

  buf->nFlags = OMX_BUFFERFLAG_ENDOFFRAME | OMX_BUFFERFLAG_EOS;

  if(first_packet) {
    buf->nFlags = OMX_BUFFERFLAG_STARTTIME;
    first_packet = 0;
  }

  PLENTRY entry = gs_sps_fix(&decodeUnit->bufferList, GS_SPS_BITSTREAM_FIXUP);
  decodeUnit->bufferList = entry;
  while (entry != NULL) {
    memcpy(dest, entry->data, entry->length);
    buf->nFilledLen += entry->length;
    dest += entry->length;
    entry = entry->next;
  }

  if(port_settings_changed == 0 &&
    ((buf->nFilledLen > 0 && ilclient_remove_event(video_decode, OMX_EventPortSettingsChanged, 131, 0, 0, 1) == 0) ||
    (buf->nFilledLen == 0 && ilclient_wait_for_event(video_decode, OMX_EventPortSettingsChanged, 131, 0, 0, 1,
                        ILCLIENT_EVENT_ERROR | ILCLIENT_PARAMETER_CHANGED, 10000) == 0))) {
    port_settings_changed = 1;

    if(ilclient_setup_tunnel(tunnel, 0, 0) != 0){
      fprintf(stderr, "Can't setup video\n");
      exit(EXIT_FAILURE);
    }

    ilclient_change_component_state(video_render, OMX_StateExecuting);
  }

  if(OMX_EmptyThisBuffer(ILC_GET_HANDLE(video_decode), buf) != OMX_ErrorNone){
    fprintf(stderr, "Can't empty video buffer\n");
    exit(EXIT_FAILURE);
  }

  return DR_OK;
}

DECODER_RENDERER_CALLBACKS decoder_callbacks_pi = {
  .setup = decoder_renderer_setup,
  .cleanup = decoder_renderer_cleanup,
  .submitDecodeUnit = decoder_renderer_submit_decode_unit,
  .capabilities = CAPABILITY_DIRECT_SUBMIT,
};
                                                    moonlight-embedded-2.1.1/src/video/sdl.c                                                            0000664 0000000 0000000 00000005616 12563604362 0020104 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#include "ffmpeg.h"

#include "limelight-common/Limelight.h"

#include <SDL.h>
#include <SDL_thread.h>

#define DECODER_BUFFER_SIZE 92*1024

static SDL_Window *window;
static SDL_Renderer *renderer;
static SDL_Texture *bmp = NULL;
static int screen_width, screen_height;
static char* ffmpeg_buffer;

static void sdl_setup(int width, int height, int redrawRate, void* context, int drFlags) {
  int avc_flags = FAST_BILINEAR_FILTERING;
  if (ffmpeg_init(width, height, 2, avc_flags) < 0) {
    fprintf(stderr, "Couldn't initialize video decoding\n");
    exit(1);
  }
  
  ffmpeg_buffer = malloc(DECODER_BUFFER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);
  if (ffmpeg_buffer == NULL) {
    fprintf(stderr, "Not enough memory\n");
    exit(1);
  }

  SDL_Window *window = (SDL_Window*) context;
  renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
  if (!renderer) {
    fprintf(stderr, "SDL: could not create renderer - exiting\n");
    exit(1);
  }

  bmp = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_TARGET, width, height);
  if (!bmp) {
    fprintf(stderr, "SDL: could not create texture - exiting\n");
    exit(1);
  }
}

static void sdl_cleanup() {
  ffmpeg_destroy();
}

static int sdl_submit_decode_unit(PDECODE_UNIT decodeUnit) {
  if (decodeUnit->fullLength < DECODER_BUFFER_SIZE) {
    PLENTRY entry = decodeUnit->bufferList;
    int length = 0;
    while (entry != NULL) {
      memcpy(ffmpeg_buffer+length, entry->data, entry->length);
      length += entry->length;
      entry = entry->next;
    }

    int ret = ffmpeg_decode(ffmpeg_buffer, length);
    if (ret == 1) {
      AVFrame* frame = ffmpeg_get_frame();

      SDL_UpdateYUVTexture(bmp, NULL, frame->data[0], frame->linesize[0], frame->data[1], frame->linesize[1], frame->data[2], frame->linesize[2]);
      SDL_RenderClear(renderer);
      SDL_RenderCopy(renderer, bmp, NULL, NULL);
      SDL_RenderPresent(renderer);
    }
  } else {
    fprintf(stderr, "Video decode buffer too small");
    exit(1);
  }

  return DR_OK;
}

DECODER_RENDERER_CALLBACKS decoder_callbacks_sdl = {
  .setup = sdl_setup,
  .cleanup = sdl_cleanup,
  .submitDecodeUnit = sdl_submit_decode_unit,
  .capabilities = CAPABILITY_DIRECT_SUBMIT,
};
                                                                                                                  moonlight-embedded-2.1.1/third_party/                                                               0000775 0000000 0000000 00000000000 12563604362 0017602 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        moonlight-embedded-2.1.1/third_party/h264bitstream/                                                 0000775 0000000 0000000 00000000000 12563604362 0022200 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        moonlight-embedded-2.1.1/third_party/h264bitstream/LICENSE                                          0000664 0000000 0000000 00000063500 12563604362 0023211 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        		  GNU LESSER GENERAL PUBLIC LICENSE
		       Version 2.1, February 1999

 Copyright (C) 1991, 1999 Free Software Foundation, Inc.
     51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

[This is the first released version of the Lesser GPL.  It also counts
 as the successor of the GNU Library Public License, version 2, hence
 the version number 2.1.]

			    Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
Licenses are intended to guarantee your freedom to share and change
free software--to make sure the software is free for all its users.

  This license, the Lesser General Public License, applies to some
specially designated software packages--typically libraries--of the
Free Software Foundation and other authors who decide to use it.  You
can use it too, but we suggest you first think carefully about whether
this license or the ordinary General Public License is the better
strategy to use in any particular case, based on the explanations below.

  When we speak of free software, we are referring to freedom of use,
not price.  Our General Public Licenses are designed to make sure that
you have the freedom to distribute copies of free software (and charge
for this service if you wish); that you receive source code or can get
it if you want it; that you can change the software and use pieces of
it in new free programs; and that you are informed that you can do
these things.

  To protect your rights, we need to make restrictions that forbid
distributors to deny you these rights or to ask you to surrender these
rights.  These restrictions translate to certain responsibilities for
you if you distribute copies of the library or if you modify it.

  For example, if you distribute copies of the library, whether gratis
or for a fee, you must give the recipients all the rights that we gave
you.  You must make sure that they, too, receive or can get the source
code.  If you link other code with the library, you must provide
complete object files to the recipients, so that they can relink them
with the library after making changes to the library and recompiling
it.  And you must show them these terms so they know their rights.

  We protect your rights with a two-step method: (1) we copyright the
library, and (2) we offer you this license, which gives you legal
permission to copy, distribute and/or modify the library.

  To protect each distributor, we want to make it very clear that
there is no warranty for the free library.  Also, if the library is
modified by someone else and passed on, the recipients should know
that what they have is not the original version, so that the original
author's reputation will not be affected by problems that might be
introduced by others.

  Finally, software patents pose a constant threat to the existence of
any free program.  We wish to make sure that a company cannot
effectively restrict the users of a free program by obtaining a
restrictive license from a patent holder.  Therefore, we insist that
any patent license obtained for a version of the library must be
consistent with the full freedom of use specified in this license.

  Most GNU software, including some libraries, is covered by the
ordinary GNU General Public License.  This license, the GNU Lesser
General Public License, applies to certain designated libraries, and
is quite different from the ordinary General Public License.  We use
this license for certain libraries in order to permit linking those
libraries into non-free programs.

  When a program is linked with a library, whether statically or using
a shared library, the combination of the two is legally speaking a
combined work, a derivative of the original library.  The ordinary
General Public License therefore permits such linking only if the
entire combination fits its criteria of freedom.  The Lesser General
Public License permits more lax criteria for linking other code with
the library.

  We call this license the "Lesser" General Public License because it
does Less to protect the user's freedom than the ordinary General
Public License.  It also provides other free software developers Less
of an advantage over competing non-free programs.  These disadvantages
are the reason we use the ordinary General Public License for many
libraries.  However, the Lesser license provides advantages in certain
special circumstances.

  For example, on rare occasions, there may be a special need to
encourage the widest possible use of a certain library, so that it becomes
a de-facto standard.  To achieve this, non-free programs must be
allowed to use the library.  A more frequent case is that a free
library does the same job as widely used non-free libraries.  In this
case, there is little to gain by limiting the free library to free
software only, so we use the Lesser General Public License.

  In other cases, permission to use a particular library in non-free
programs enables a greater number of people to use a large body of
free software.  For example, permission to use the GNU C Library in
non-free programs enables many more people to use the whole GNU
operating system, as well as its variant, the GNU/Linux operating
system.

  Although the Lesser General Public License is Less protective of the
users' freedom, it does ensure that the user of a program that is
linked with the Library has the freedom and the wherewithal to run
that program using a modified version of the Library.

  The precise terms and conditions for copying, distribution and
modification follow.  Pay close attention to the difference between a
"work based on the library" and a "work that uses the library".  The
former contains code derived from the library, whereas the latter must
be combined with the library in order to run.

		  GNU LESSER GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License Agreement applies to any software library or other
program which contains a notice placed by the copyright holder or
other authorized party saying it may be distributed under the terms of
this Lesser General Public License (also called "this License").
Each licensee is addressed as "you".

  A "library" means a collection of software functions and/or data
prepared so as to be conveniently linked with application programs
(which use some of those functions and data) to form executables.

  The "Library", below, refers to any such software library or work
which has been distributed under these terms.  A "work based on the
Library" means either the Library or any derivative work under
copyright law: that is to say, a work containing the Library or a
portion of it, either verbatim or with modifications and/or translated
straightforwardly into another language.  (Hereinafter, translation is
included without limitation in the term "modification".)

  "Source code" for a work means the preferred form of the work for
making modifications to it.  For a library, complete source code means
all the source code for all modules it contains, plus any associated
interface definition files, plus the scripts used to control compilation
and installation of the library.

  Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running a program using the Library is not restricted, and output from
such a program is covered only if its contents constitute a work based
on the Library (independent of the use of the Library in a tool for
writing it).  Whether that is true depends on what the Library does
and what the program that uses the Library does.
  
  1. You may copy and distribute verbatim copies of the Library's
complete source code as you receive it, in any medium, provided that
you conspicuously and appropriately publish on each copy an
appropriate copyright notice and disclaimer of warranty; keep intact
all the notices that refer to this License and to the absence of any
warranty; and distribute a copy of this License along with the
Library.

  You may charge a fee for the physical act of transferring a copy,
and you may at your option offer warranty protection in exchange for a
fee.

  2. You may modify your copy or copies of the Library or any portion
of it, thus forming a work based on the Library, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) The modified work must itself be a software library.

    b) You must cause the files modified to carry prominent notices
    stating that you changed the files and the date of any change.

    c) You must cause the whole of the work to be licensed at no
    charge to all third parties under the terms of this License.

    d) If a facility in the modified Library refers to a function or a
    table of data to be supplied by an application program that uses
    the facility, other than as an argument passed when the facility
    is invoked, then you must make a good faith effort to ensure that,
    in the event an application does not supply such function or
    table, the facility still operates, and performs whatever part of
    its purpose remains meaningful.

    (For example, a function in a library to compute square roots has
    a purpose that is entirely well-defined independent of the
    application.  Therefore, Subsection 2d requires that any
    application-supplied function or table used by this function must
    be optional: if the application does not supply it, the square
    root function must still compute square roots.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Library,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Library, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote
it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Library.

In addition, mere aggregation of another work not based on the Library
with the Library (or with a work based on the Library) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may opt to apply the terms of the ordinary GNU General Public
License instead of this License to a given copy of the Library.  To do
this, you must alter all the notices that refer to this License, so
that they refer to the ordinary GNU General Public License, version 2,
instead of to this License.  (If a newer version than version 2 of the
ordinary GNU General Public License has appeared, then you can specify
that version instead if you wish.)  Do not make any other change in
these notices.

  Once this change is made in a given copy, it is irreversible for
that copy, so the ordinary GNU General Public License applies to all
subsequent copies and derivative works made from that copy.

  This option is useful when you wish to copy part of the code of
the Library into a program that is not a library.

  4. You may copy and distribute the Library (or a portion or
derivative of it, under Section 2) in object code or executable form
under the terms of Sections 1 and 2 above provided that you accompany
it with the complete corresponding machine-readable source code, which
must be distributed under the terms of Sections 1 and 2 above on a
medium customarily used for software interchange.

  If distribution of object code is made by offering access to copy
from a designated place, then offering equivalent access to copy the
source code from the same place satisfies the requirement to
distribute the source code, even though third parties are not
compelled to copy the source along with the object code.

  5. A program that contains no derivative of any portion of the
Library, but is designed to work with the Library by being compiled or
linked with it, is called a "work that uses the Library".  Such a
work, in isolation, is not a derivative work of the Library, and
therefore falls outside the scope of this License.

  However, linking a "work that uses the Library" with the Library
creates an executable that is a derivative of the Library (because it
contains portions of the Library), rather than a "work that uses the
library".  The executable is therefore covered by this License.
Section 6 states terms for distribution of such executables.

  When a "work that uses the Library" uses material from a header file
that is part of the Library, the object code for the work may be a
derivative work of the Library even though the source code is not.
Whether this is true is especially significant if the work can be
linked without the Library, or if the work is itself a library.  The
threshold for this to be true is not precisely defined by law.

  If such an object file uses only numerical parameters, data
structure layouts and accessors, and small macros and small inline
functions (ten lines or less in length), then the use of the object
file is unrestricted, regardless of whether it is legally a derivative
work.  (Executables containing this object code plus portions of the
Library will still fall under Section 6.)

  Otherwise, if the work is a derivative of the Library, you may
distribute the object code for the work under the terms of Section 6.
Any executables containing that work also fall under Section 6,
whether or not they are linked directly with the Library itself.

  6. As an exception to the Sections above, you may also combine or
link a "work that uses the Library" with the Library to produce a
work containing portions of the Library, and distribute that work
under terms of your choice, provided that the terms permit
modification of the work for the customer's own use and reverse
engineering for debugging such modifications.

  You must give prominent notice with each copy of the work that the
Library is used in it and that the Library and its use are covered by
this License.  You must supply a copy of this License.  If the work
during execution displays copyright notices, you must include the
copyright notice for the Library among them, as well as a reference
directing the user to the copy of this License.  Also, you must do one
of these things:

    a) Accompany the work with the complete corresponding
    machine-readable source code for the Library including whatever
    changes were used in the work (which must be distributed under
    Sections 1 and 2 above); and, if the work is an executable linked
    with the Library, with the complete machine-readable "work that
    uses the Library", as object code and/or source code, so that the
    user can modify the Library and then relink to produce a modified
    executable containing the modified Library.  (It is understood
    that the user who changes the contents of definitions files in the
    Library will not necessarily be able to recompile the application
    to use the modified definitions.)

    b) Use a suitable shared library mechanism for linking with the
    Library.  A suitable mechanism is one that (1) uses at run time a
    copy of the library already present on the user's computer system,
    rather than copying library functions into the executable, and (2)
    will operate properly with a modified version of the library, if
    the user installs one, as long as the modified version is
    interface-compatible with the version that the work was made with.

    c) Accompany the work with a written offer, valid for at
    least three years, to give the same user the materials
    specified in Subsection 6a, above, for a charge no more
    than the cost of performing this distribution.

    d) If distribution of the work is made by offering access to copy
    from a designated place, offer equivalent access to copy the above
    specified materials from the same place.

    e) Verify that the user has already received a copy of these
    materials or that you have already sent this user a copy.

  For an executable, the required form of the "work that uses the
Library" must include any data and utility programs needed for
reproducing the executable from it.  However, as a special exception,
the materials to be distributed need not include anything that is
normally distributed (in either source or binary form) with the major
components (compiler, kernel, and so on) of the operating system on
which the executable runs, unless that component itself accompanies
the executable.

  It may happen that this requirement contradicts the license
restrictions of other proprietary libraries that do not normally
accompany the operating system.  Such a contradiction means you cannot
use both them and the Library together in an executable that you
distribute.

  7. You may place library facilities that are a work based on the
Library side-by-side in a single library together with other library
facilities not covered by this License, and distribute such a combined
library, provided that the separate distribution of the work based on
the Library and of the other library facilities is otherwise
permitted, and provided that you do these two things:

    a) Accompany the combined library with a copy of the same work
    based on the Library, uncombined with any other library
    facilities.  This must be distributed under the terms of the
    Sections above.

    b) Give prominent notice with the combined library of the fact
    that part of it is a work based on the Library, and explaining
    where to find the accompanying uncombined form of the same work.

  8. You may not copy, modify, sublicense, link with, or distribute
the Library except as expressly provided under this License.  Any
attempt otherwise to copy, modify, sublicense, link with, or
distribute the Library is void, and will automatically terminate your
rights under this License.  However, parties who have received copies,
or rights, from you under this License will not have their licenses
terminated so long as such parties remain in full compliance.

  9. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Library or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Library (or any work based on the
Library), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Library or works based on it.

  10. Each time you redistribute the Library (or any work based on the
Library), the recipient automatically receives a license from the
original licensor to copy, distribute, link with or modify the Library
subject to these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties with
this License.

  11. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Library at all.  For example, if a patent
license would not permit royalty-free redistribution of the Library by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Library.

If any portion of this section is held invalid or unenforceable under any
particular circumstance, the balance of the section is intended to apply,
and the section as a whole is intended to apply in other circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  12. If the distribution and/or use of the Library is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Library under this License may add
an explicit geographical distribution limitation excluding those countries,
so that distribution is permitted only in or among countries not thus
excluded.  In such case, this License incorporates the limitation as if
written in the body of this License.

  13. The Free Software Foundation may publish revised and/or new
versions of the Lesser General Public License from time to time.
Such new versions will be similar in spirit to the present version,
but may differ in detail to address new problems or concerns.

Each version is given a distinguishing version number.  If the Library
specifies a version number of this License which applies to it and
"any later version", you have the option of following the terms and
conditions either of that version or of any later version published by
the Free Software Foundation.  If the Library does not specify a
license version number, you may choose any version ever published by
the Free Software Foundation.

  14. If you wish to incorporate parts of the Library into other free
programs whose distribution conditions are incompatible with these,
write to the author to ask for permission.  For software which is
copyrighted by the Free Software Foundation, write to the Free
Software Foundation; we sometimes make exceptions for this.  Our
decision will be guided by the two goals of preserving the free status
of all derivatives of our free software and of promoting the sharing
and reuse of software generally.

			    NO WARRANTY

  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGES.

		     END OF TERMS AND CONDITIONS

           How to Apply These Terms to Your New Libraries

  If you develop a new library, and you want it to be of the greatest
possible use to the public, we recommend making it free software that
everyone can redistribute and change.  You can do so by permitting
redistribution under these terms (or, alternatively, under the terms of the
ordinary General Public License).

  To apply these terms, attach the following notices to the library.  It is
safest to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least the
"copyright" line and a pointer to where the full notice is found.

    <one line to give the library's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

Also add information on how to contact you by electronic and paper mail.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the library, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the
  library `Frob' (a library for tweaking knobs) written by James Random Hacker.

  <signature of Ty Coon>, 1 April 1990
  Ty Coon, President of Vice

That's all there is to it!


                                                                                                                                                                                                moonlight-embedded-2.1.1/third_party/h264bitstream/bs.h                                             0000664 0000000 0000000 00000021411 12563604362 0022754 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* 
 * h264bitstream - a library for reading and writing H.264 video
 * Copyright (C) 2005-2007 Auroras Entertainment, LLC
 * Copyright (C) 2008-2011 Avail-TVN
 * 
 * Written by Alex Izvorski <aizvorski@gmail.com> and Alex Giladi <alex.giladi@gmail.com>
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

#ifndef _H264_BS_H
#define _H264_BS_H        1

#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct
{
	uint8_t* start;
	uint8_t* p;
	uint8_t* end;
	int bits_left;
} bs_t;

#define _OPTIMIZE_BS_ 1

#if ( _OPTIMIZE_BS_ > 0 )
#ifndef FAST_U8
#define FAST_U8
#endif
#endif


static bs_t* bs_new(uint8_t* buf, size_t size);
static void bs_free(bs_t* b);
static bs_t* bs_clone( bs_t* dest, const bs_t* src );
static bs_t*  bs_init(bs_t* b, uint8_t* buf, size_t size);
static uint32_t bs_byte_aligned(bs_t* b);
static int bs_eof(bs_t* b);
static int bs_overrun(bs_t* b);
static int bs_pos(bs_t* b);

static uint32_t bs_peek_u1(bs_t* b);
static uint32_t bs_read_u1(bs_t* b);
static uint32_t bs_read_u(bs_t* b, int n);
static uint32_t bs_read_f(bs_t* b, int n);
static uint32_t bs_read_u8(bs_t* b);
static uint32_t bs_read_ue(bs_t* b);
static int32_t  bs_read_se(bs_t* b);

static void bs_write_u1(bs_t* b, uint32_t v);
static void bs_write_u(bs_t* b, int n, uint32_t v);
static void bs_write_f(bs_t* b, int n, uint32_t v);
static void bs_write_u8(bs_t* b, uint32_t v);
static void bs_write_ue(bs_t* b, uint32_t v);
static void bs_write_se(bs_t* b, int32_t v);

static int bs_read_bytes(bs_t* b, uint8_t* buf, int len);
static int bs_write_bytes(bs_t* b, uint8_t* buf, int len);
static int bs_skip_bytes(bs_t* b, int len);
static uint32_t bs_next_bits(bs_t* b, int nbits);
// IMPLEMENTATION

static inline bs_t* bs_init(bs_t* b, uint8_t* buf, size_t size)
{
    b->start = buf;
    b->p = buf;
    b->end = buf + size;
    b->bits_left = 8;
    return b;
}

static inline bs_t* bs_new(uint8_t* buf, size_t size)
{
    bs_t* b = (bs_t*)malloc(sizeof(bs_t));
    bs_init(b, buf, size);
    return b;
}

static inline void bs_free(bs_t* b)
{
    free(b);
}

static inline bs_t* bs_clone(bs_t* dest, const bs_t* src)
{
    dest->start = src->p;
    dest->p = src->p;
    dest->end = src->end;
    dest->bits_left = src->bits_left;
    return dest;
}

static inline uint32_t bs_byte_aligned(bs_t* b) 
{ 
    return (b->bits_left == 8);
}

static inline int bs_eof(bs_t* b) { if (b->p >= b->end) { return 1; } else { return 0; } }

static inline int bs_overrun(bs_t* b) { if (b->p > b->end) { return 1; } else { return 0; } }

static inline int bs_pos(bs_t* b) { if (b->p > b->end) { return (b->end - b->start); } else { return (b->p - b->start); } }

static inline int bs_bytes_left(bs_t* b) { return (b->end - b->p); }

static inline uint32_t bs_read_u1(bs_t* b)
{
    uint32_t r = 0;
    
    b->bits_left--;

    if (! bs_eof(b))
    {
        r = ((*(b->p)) >> b->bits_left) & 0x01;
    }

    if (b->bits_left == 0) { b->p ++; b->bits_left = 8; }

    return r;
}

static inline void bs_skip_u1(bs_t* b)
{    
    b->bits_left--;
    if (b->bits_left == 0) { b->p ++; b->bits_left = 8; }
}

static inline uint32_t bs_peek_u1(bs_t* b)
{
    uint32_t r = 0;

    if (! bs_eof(b))
    {
        r = ((*(b->p)) >> ( b->bits_left - 1 )) & 0x01;
    }
    return r;
}


static inline uint32_t bs_read_u(bs_t* b, int n)
{
    uint32_t r = 0;
    int i;
    for (i = 0; i < n; i++)
    {
        r |= ( bs_read_u1(b) << ( n - i - 1 ) );
    }
    return r;
}

static inline void bs_skip_u(bs_t* b, int n)
{
    int i;
    for ( i = 0; i < n; i++ ) 
    {
        bs_skip_u1( b );
    }
}

static inline uint32_t bs_read_f(bs_t* b, int n) { return bs_read_u(b, n); }

static inline uint32_t bs_read_u8(bs_t* b)
{
#ifdef FAST_U8
    if (b->bits_left == 8 && ! bs_eof(b)) // can do fast read
    {
        uint32_t r = b->p[0];
        b->p++;
        return r;
    }
#endif
    return bs_read_u(b, 8);
}

static inline uint32_t bs_read_ue(bs_t* b)
{
    int32_t r = 0;
    int i = 0;

    while( (bs_read_u1(b) == 0) && (i < 32) && (!bs_eof(b)) )
    {
        i++;
    }
    r = bs_read_u(b, i);
    r += (1 << i) - 1;
    return r;
}

static inline int32_t bs_read_se(bs_t* b) 
{
    int32_t r = bs_read_ue(b);
    if (r & 0x01)
    {
        r = (r+1)/2;
    }
    else
    {
        r = -(r/2);
    }
    return r;
}


static inline void bs_write_u1(bs_t* b, uint32_t v)
{
    b->bits_left--;

    if (! bs_eof(b))
    {
        // FIXME this is slow, but we must clear bit first
        // is it better to memset(0) the whole buffer during bs_init() instead? 
        // if we don't do either, we introduce pretty nasty bugs
        (*(b->p)) &= ~(0x01 << b->bits_left);
        (*(b->p)) |= ((v & 0x01) << b->bits_left);
    }

    if (b->bits_left == 0) { b->p ++; b->bits_left = 8; }
}

static inline void bs_write_u(bs_t* b, int n, uint32_t v)
{
    int i;
    for (i = 0; i < n; i++)
    {
        bs_write_u1(b, (v >> ( n - i - 1 ))&0x01 );
    }
}

static inline void bs_write_f(bs_t* b, int n, uint32_t v) { bs_write_u(b, n, v); }

static inline void bs_write_u8(bs_t* b, uint32_t v)
{
#ifdef FAST_U8
    if (b->bits_left == 8 && ! bs_eof(b)) // can do fast write
    {
        b->p[0] = v;
        b->p++;
        return;
    }
#endif
    bs_write_u(b, 8, v);
}

static inline void bs_write_ue(bs_t* b, uint32_t v)
{
    static const int len_table[256] =
    {
        1,
        1,
        2,2,
        3,3,3,3,
        4,4,4,4,4,4,4,4,
        5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
        6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
        6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
        7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
        7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
        7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
        7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
        8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
    };

    int len;

    if (v == 0)
    {
        bs_write_u1(b, 1);
    }
    else
    {
        v++;

        if (v >= 0x01000000)
        {
            len = 24 + len_table[ v >> 24 ];
        }
        else if(v >= 0x00010000)
        {
            len = 16 + len_table[ v >> 16 ];
        }
        else if(v >= 0x00000100)
        {
            len =  8 + len_table[ v >>  8 ];
        }
        else 
        {
            len = len_table[ v ];
        }

        bs_write_u(b, 2*len-1, v);
    }
}

static inline void bs_write_se(bs_t* b, int32_t v)
{
    if (v <= 0)
    {
        bs_write_ue(b, -v*2);
    }
    else
    {
        bs_write_ue(b, v*2 - 1);
    }
}

static inline int bs_read_bytes(bs_t* b, uint8_t* buf, int len)
{
    int actual_len = len;
    if (b->end - b->p < actual_len) { actual_len = b->end - b->p; }
    if (actual_len < 0) { actual_len = 0; }
    memcpy(buf, b->p, actual_len);
    if (len < 0) { len = 0; }
    b->p += len;
    return actual_len;
}

static inline int bs_write_bytes(bs_t* b, uint8_t* buf, int len)
{
    int actual_len = len;
    if (b->end - b->p < actual_len) { actual_len = b->end - b->p; }
    if (actual_len < 0) { actual_len = 0; }
    memcpy(b->p, buf, actual_len);
    if (len < 0) { len = 0; }
    b->p += len;
    return actual_len;
}

static inline int bs_skip_bytes(bs_t* b, int len)
{
    int actual_len = len;
    if (b->end - b->p < actual_len) { actual_len = b->end - b->p; }
    if (actual_len < 0) { actual_len = 0; }
    if (len < 0) { len = 0; }
    b->p += len;
    return actual_len;
}

static inline uint32_t bs_next_bits(bs_t* bs, int nbits)
{
   bs_t b;
   bs_clone(&b,bs);
   return bs_read_u(&b, nbits);
}

static inline uint64_t bs_next_bytes(bs_t* bs, int nbytes)
{
   int i = 0;
   uint64_t val = 0;

   if ( (nbytes > 8) || (nbytes < 1) ) { return 0; }
   if (bs->p + nbytes > bs->end) { return 0; }

   for ( i = 0; i < nbytes; i++ ) { val = ( val << 8 ) | bs->p[i]; }
   return val;
}

#define bs_print_state(b) fprintf( stderr,  "%s:%d@%s: b->p=0x%02hhX, b->left = %d\n", __FILE__, __LINE__, __FUNCTION__, *b->p, b->bits_left )

#ifdef __cplusplus
}
#endif

#endif
                                                                                                                                                                                                                                                       moonlight-embedded-2.1.1/third_party/h264bitstream/h264_nal.c                                       0000664 0000000 0000000 00000022056 12563604362 0023666 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* 
 * h264bitstream - a library for reading and writing H.264 video
 * Copyright (C) 2005-2007 Auroras Entertainment, LLC
 * Copyright (C) 2008-2011 Avail-TVN
 * 
 * Written by Alex Izvorski <aizvorski@gmail.com> and Alex Giladi <alex.giladi@gmail.com>
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

#include "bs.h"
#include "h264_stream.h"
#include "h264_sei.h"

/**
 Create a new H264 stream object.  Allocates all structures contained within it.
 @return    the stream object
 */
h264_stream_t* h264_new()
{
    h264_stream_t* h = (h264_stream_t*)calloc(1, sizeof(h264_stream_t));

    h->nal = (nal_t*)calloc(1, sizeof(nal_t));

    // initialize tables
    for ( int i = 0; i < 32; i++ ) { h->sps_table[i] = (sps_t*)calloc(1, sizeof(sps_t)); }
    for ( int i = 0; i < 256; i++ ) { h->pps_table[i] = (pps_t*)calloc(1, sizeof(pps_t)); }

    h->sps = h->sps_table[0];
    h->pps = h->pps_table[0];
    h->aud = (aud_t*)calloc(1, sizeof(aud_t));
    h->num_seis = 0;
    h->seis = NULL;
    h->sei = NULL;  //This is a TEMP pointer at whats in h->seis...
    h->sh = (slice_header_t*)calloc(1, sizeof(slice_header_t));
    h->slice_data = (slice_data_rbsp_t*)calloc(1, sizeof(slice_data_rbsp_t));

    return h;   
}


/**
 Free an existing H264 stream object.  Frees all contained structures.
 @param[in,out] h   the stream object
 */
void h264_free(h264_stream_t* h)
{
    free(h->nal);

    for ( int i = 0; i < 32; i++ ) { free( h->sps_table[i] ); }
    for ( int i = 0; i < 256; i++ ) { free( h->pps_table[i] ); }

    free(h->aud);
    if(h->seis != NULL)
    {
        for( int i = 0; i < h->num_seis; i++ )
        {
            sei_t* sei = h->seis[i];
            sei_free(sei);
        }
        free(h->seis);
    }
    free(h->sh);
    free(h);
}

/**
 Find the beginning and end of a NAL (Network Abstraction Layer) unit in a byte buffer containing H264 bitstream data.
 @param[in]   buf        the buffer
 @param[in]   size       the size of the buffer
 @param[out]  nal_start  the beginning offset of the nal
 @param[out]  nal_end    the end offset of the nal
 @return                 the length of the nal, or 0 if did not find start of nal, or -1 if did not find end of nal
 */
// DEPRECATED - this will be replaced by a similar function with a slightly different API
int find_nal_unit(uint8_t* buf, int size, int* nal_start, int* nal_end)
{
    int i;
    // find start
    *nal_start = 0;
    *nal_end = 0;
    
    i = 0;
    while (   //( next_bits( 24 ) != 0x000001 && next_bits( 32 ) != 0x00000001 )
        (buf[i] != 0 || buf[i+1] != 0 || buf[i+2] != 0x01) && 
        (buf[i] != 0 || buf[i+1] != 0 || buf[i+2] != 0 || buf[i+3] != 0x01) 
        )
    {
        i++; // skip leading zero
        if (i+4 >= size) { return 0; } // did not find nal start
    }

    if  (buf[i] != 0 || buf[i+1] != 0 || buf[i+2] != 0x01) // ( next_bits( 24 ) != 0x000001 )
    {
        i++;
    }

    if  (buf[i] != 0 || buf[i+1] != 0 || buf[i+2] != 0x01) { /* error, should never happen */ return 0; }
    i+= 3;
    *nal_start = i;
    
    while (   //( next_bits( 24 ) != 0x000000 && next_bits( 24 ) != 0x000001 )
        (buf[i] != 0 || buf[i+1] != 0 || buf[i+2] != 0) && 
        (buf[i] != 0 || buf[i+1] != 0 || buf[i+2] != 0x01) 
        )
    {
        i++;
        // FIXME the next line fails when reading a nal that ends exactly at the end of the data
        if (i+3 >= size) { *nal_end = size; return -1; } // did not find nal end, stream ended first
    }
    
    *nal_end = i;
    return (*nal_end - *nal_start);
}


/**
   Convert RBSP data to NAL data (Annex B format).
   The size of nal_buf must be 4/3 * the size of the rbsp_buf (rounded up) to guarantee the output will fit.
   If that is not true, output may be truncated and an error will be returned.
   If that is true, there is no possible error during this conversion.
   @param[in] rbsp_buf   the rbsp data
   @param[in] rbsp_size  pointer to the size of the rbsp data
   @param[in,out] nal_buf   allocated memory in which to put the nal data
   @param[in,out] nal_size  as input, pointer to the maximum size of the nal data; as output, filled in with the actual size of the nal data
   @return  actual size of nal data, or -1 on error
 */
// 7.3.1 NAL unit syntax
// 7.4.1.1 Encapsulation of an SODB within an RBSP
int rbsp_to_nal(const uint8_t* rbsp_buf, const int* rbsp_size, uint8_t* nal_buf, int* nal_size)
{
    int i;
    int j     = 0;
    int count = 0;

    for ( i = 0; i < *rbsp_size ; i++ )
    {
        if ( j >= *nal_size ) 
        {
            // error, not enough space
            return -1;
        }

        if ( ( count == 2 ) && !(rbsp_buf[i] & 0xFC) ) // HACK 0xFC
        {
            nal_buf[j] = 0x03;
            j++;
            count = 0;
        }
        nal_buf[j] = rbsp_buf[i];
        if ( rbsp_buf[i] == 0x00 )
        {
            count++;
        }
        else
        {
            count = 0;
        }
        j++;
    }

    *nal_size = j;
    return j;
}

/**
   Convert NAL data (Annex B format) to RBSP data.
   The size of rbsp_buf must be the same as size of the nal_buf to guarantee the output will fit.
   If that is not true, output may be truncated and an error will be returned. 
   Additionally, certain byte sequences in the input nal_buf are not allowed in the spec and also cause the conversion to fail and an error to be returned.
   @param[in] nal_buf   the nal data
   @param[in,out] nal_size  as input, pointer to the size of the nal data; as output, filled in with the actual size of the nal data
   @param[in,out] rbsp_buf   allocated memory in which to put the rbsp data
   @param[in,out] rbsp_size  as input, pointer to the maximum size of the rbsp data; as output, filled in with the actual size of rbsp data
   @return  actual size of rbsp data, or -1 on error
 */
// 7.3.1 NAL unit syntax
// 7.4.1.1 Encapsulation of an SODB within an RBSP
int nal_to_rbsp(const uint8_t* nal_buf, int* nal_size, uint8_t* rbsp_buf, int* rbsp_size)
{
    int i;
    int j     = 0;
    int count = 0;
  
    for( i = 0; i < *nal_size; i++ )
    { 
        // in NAL unit, 0x000000, 0x000001 or 0x000002 shall not occur at any byte-aligned position
        if( ( count == 2 ) && ( nal_buf[i] < 0x03) ) 
        {
            return -1;
        }

        if( ( count == 2 ) && ( nal_buf[i] == 0x03) )
        {
            // check the 4th byte after 0x000003, except when cabac_zero_word is used, in which case the last three bytes of this NAL unit must be 0x000003
            if((i < *nal_size - 1) && (nal_buf[i+1] > 0x03))
            {
                return -1;
            }

            // if cabac_zero_word is used, the final byte of this NAL unit(0x03) is discarded, and the last two bytes of RBSP must be 0x0000
            if(i == *nal_size - 1)
            {
                break;
            }

            i++;
            count = 0;
        }

        if ( j >= *rbsp_size ) 
        {
            // error, not enough space
            return -1;
        }

        rbsp_buf[j] = nal_buf[i];
        if(nal_buf[i] == 0x00)
        {
            count++;
        }
        else
        {
            count = 0;
        }
        j++;
    }

    *nal_size = i;
    *rbsp_size = j;
    return j;
}


/**
 Read only the NAL headers (enough to determine unit type) from a byte buffer.
 @return unit type if read successfully, or -1 if this doesn't look like a nal
*/
int peek_nal_unit(h264_stream_t* h, uint8_t* buf, int size)
{
    nal_t* nal = h->nal;

    bs_t* b = bs_new(buf, size);

    nal->forbidden_zero_bit = bs_read_f(b,1);
    nal->nal_ref_idc = bs_read_u(b,2);
    nal->nal_unit_type = bs_read_u(b,5);

    bs_free(b);

    // basic verification, per 7.4.1
    if ( nal->forbidden_zero_bit ) { return -1; }
    if ( nal->nal_unit_type <= 0 || nal->nal_unit_type > 20 ) { return -1; }
    if ( nal->nal_unit_type > 15 && nal->nal_unit_type < 19 ) { return -1; }

    if ( nal->nal_ref_idc == 0 )
    {
        if ( nal->nal_unit_type == NAL_UNIT_TYPE_CODED_SLICE_IDR )
        {
            return -1;
        }
    }
    else 
    {
        if ( nal->nal_unit_type ==  NAL_UNIT_TYPE_SEI || 
             nal->nal_unit_type == NAL_UNIT_TYPE_AUD || 
             nal->nal_unit_type == NAL_UNIT_TYPE_END_OF_SEQUENCE || 
             nal->nal_unit_type == NAL_UNIT_TYPE_END_OF_STREAM || 
             nal->nal_unit_type == NAL_UNIT_TYPE_FILLER ) 
        {
            return -1;
        }
    }

    return nal->nal_unit_type;
}


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  moonlight-embedded-2.1.1/third_party/h264bitstream/h264_sei.c                                       0000664 0000000 0000000 00000004471 12563604362 0023675 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* 
 * h264bitstream - a library for reading and writing H.264 video
 * Copyright (C) 2005-2007 Auroras Entertainment, LLC
 * Copyright (C) 2008-2011 Avail-TVN
 * 
 * Written by Alex Izvorski <aizvorski@gmail.com> and Alex Giladi <alex.giladi@gmail.com>
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

#include "bs.h"
#include "h264_stream.h"
#include "h264_sei.h"

#include <stdio.h>
#include <stdlib.h> // malloc
#include <string.h> // memset

sei_t* sei_new()
{
    sei_t* s = (sei_t*)malloc(sizeof(sei_t));
    memset(s, 0, sizeof(sei_t));
    s->payload = NULL;
    return s;
}

void sei_free(sei_t* s)
{
    if ( s->payload != NULL ) free(s->payload);
    free(s);
}

void read_sei_end_bits(h264_stream_t* h, bs_t* b )
{
    // if the message doesn't end at a byte border
    if ( !bs_byte_aligned( b ) )
    {
        if ( !bs_read_u1( b ) ) fprintf(stderr, "WARNING: bit_equal_to_one is 0!!!!\n");
        while ( ! bs_byte_aligned( b ) )
        {
            if ( bs_read_u1( b ) ) fprintf(stderr, "WARNING: bit_equal_to_zero is 1!!!!\n");
        }
    }

    read_rbsp_trailing_bits(h, b);
}

// D.1 SEI payload syntax
void read_sei_payload(h264_stream_t* h, bs_t* b, int payloadType, int payloadSize)
{
    sei_t* s = h->sei;

    s->payload = (uint8_t*)malloc(payloadSize);

    int i;

    for ( i = 0; i < payloadSize; i++ )
        s->payload[i] = bs_read_u(b, 8);
        
    //read_sei_end_bits(h, b);
}

// D.1 SEI payload syntax
void write_sei_payload(h264_stream_t* h, bs_t* b, int payloadType, int payloadSize)
{
    sei_t* s = h->sei;

    int i;
    for ( i = 0; i < s->payloadSize; i++ )
        bs_write_u(b, 8, s->payload[i]);
}



                                                                                                                                                                                                       moonlight-embedded-2.1.1/third_party/h264bitstream/h264_sei.h                                       0000664 0000000 0000000 00000004416 12563604362 0023701 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* 
 * h264bitstream - a library for reading and writing H.264 video
 * Copyright (C) 2005-2007 Auroras Entertainment, LLC
 * Copyright (C) 2008-2011 Avail-TVN
 * 
 * Written by Alex Izvorski <aizvorski@gmail.com> and Alex Giladi <alex.giladi@gmail.com>
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

#include <stdint.h>

#ifndef _H264_SEI_H
#define _H264_SEI_H        1

#include <stdint.h>

#include "bs.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct
{
    int payloadType;
    int payloadSize;
    uint8_t* payload;
} sei_t;

sei_t* sei_new();
void sei_free(sei_t* s);

//D.1 SEI payload syntax
#define SEI_TYPE_BUFFERING_PERIOD 0
#define SEI_TYPE_PIC_TIMING       1
#define SEI_TYPE_PAN_SCAN_RECT    2
#define SEI_TYPE_FILLER_PAYLOAD   3
#define SEI_TYPE_USER_DATA_REGISTERED_ITU_T_T35  4
#define SEI_TYPE_USER_DATA_UNREGISTERED  5
#define SEI_TYPE_RECOVERY_POINT   6
#define SEI_TYPE_DEC_REF_PIC_MARKING_REPETITION 7
#define SEI_TYPE_SPARE_PIC        8
#define SEI_TYPE_SCENE_INFO       9
#define SEI_TYPE_SUB_SEQ_INFO    10
#define SEI_TYPE_SUB_SEQ_LAYER_CHARACTERISTICS  11
#define SEI_TYPE_SUB_SEQ_CHARACTERISTICS  12
#define SEI_TYPE_FULL_FRAME_FREEZE  13
#define SEI_TYPE_FULL_FRAME_FREEZE_RELEASE  14
#define SEI_TYPE_FULL_FRAME_SNAPSHOT  15
#define SEI_TYPE_PROGRESSIVE_REFINEMENT_SEGMENT_START  16
#define SEI_TYPE_PROGRESSIVE_REFINEMENT_SEGMENT_END  17
#define SEI_TYPE_MOTION_CONSTRAINED_SLICE_GROUP_SET  18
#define SEI_TYPE_FILM_GRAIN_CHARACTERISTICS  19
#define SEI_TYPE_DEBLOCKING_FILTER_DISPLAY_PREFERENCE  20
#define SEI_TYPE_STEREO_VIDEO_INFO  21

#ifdef __cplusplus
}
#endif

#endif
                                                                                                                                                                                                                                                  moonlight-embedded-2.1.1/third_party/h264bitstream/h264_stream.c                                    0000664 0000000 0000000 00000344201 12563604362 0024406 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* 
 * h264bitstream - a library for reading and writing H.264 video
 * Copyright (C) 2005-2007 Auroras Entertainment, LLC
 * Copyright (C) 2008-2011 Avail-TVN
 * Copyright (C) 2012 Alex Izvorski
 *
 * Written by Alex Izvorski <aizvorski@gmail.com> and Alex Giladi <alex.giladi@gmail.com>
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */


#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

#include "bs.h"
#include "h264_stream.h"
#include "h264_sei.h"

FILE* h264_dbgfile = NULL;

#define printf(...) fprintf((h264_dbgfile == NULL ? stdout : h264_dbgfile), __VA_ARGS__)

/** 
 Calculate the log base 2 of the argument, rounded up. 
 Zero or negative arguments return zero 
 Idea from http://www.southwindsgames.com/blog/2009/01/19/fast-integer-log2-function-in-cc/
 */
int intlog2(int x)
{
    int log = 0;
    if (x < 0) { x = 0; }
    while ((x >> log) > 0)
    {
        log++;
    }
    if (log > 0 && x == 1<<(log-1)) { log--; }
    return log;
}

int is_slice_type(int slice_type, int cmp_type)
{
    if (slice_type >= 5) { slice_type -= 5; }
    if (cmp_type >= 5) { cmp_type -= 5; }
    if (slice_type == cmp_type) { return 1; }
    else { return 0; }
}

int more_rbsp_data(h264_stream_t* h, bs_t* bs)
{
    // TODO this version handles reading only. writing version?

    // no more data
    if (bs_eof(bs)) { return 0; }

    // no rbsp_stop_bit yet
    if (bs_peek_u1(bs) == 0) { return 1; }

    // next bit is 1, is it the rsbp_stop_bit? only if the rest of bits are 0
    bs_t bs_tmp;
    bs_clone(&bs_tmp, bs);
    bs_skip_u1(&bs_tmp);
    while(!bs_eof(&bs_tmp))
    {
        // A later bit was 1, it wasn't the rsbp_stop_bit
        if (bs_read_u1(&bs_tmp) == 1) { return 1; }
    }

    // All following bits were 0, it was the rsbp_stop_bit
    return 0;
}

int more_rbsp_trailing_data(h264_stream_t* h, bs_t* b) { return !bs_eof(b); }

int _read_ff_coded_number(bs_t* b)
{
    int n1 = 0;
    int n2;
    do 
    {
        n2 = bs_read_u8(b);
        n1 += n2;
    } while (n2 == 0xff);
    return n1;
}

void _write_ff_coded_number(bs_t* b, int n)
{
    while (1)
    {
        if (n > 0xff)
        {
            bs_write_u8(b, 0xff);
            n -= 0xff;
        }
        else
        {
            bs_write_u8(b, n);
            break;
        }
    }
}

void debug_bytes(uint8_t* buf, int len)
{
    int i;
    for (i = 0; i < len; i++)
    {
        printf("%02X ", buf[i]);
        if ((i+1) % 16 == 0) { printf ("\n"); }
    }
    printf("\n");
}



void read_seq_parameter_set_rbsp(h264_stream_t* h, bs_t* b);
void read_scaling_list(bs_t* b, int* scalingList, int sizeOfScalingList, int* useDefaultScalingMatrixFlag );
void read_vui_parameters(h264_stream_t* h, bs_t* b);
void read_hrd_parameters(h264_stream_t* h, bs_t* b);
void read_pic_parameter_set_rbsp(h264_stream_t* h, bs_t* b);
void read_sei_rbsp(h264_stream_t* h, bs_t* b);
void read_sei_message(h264_stream_t* h, bs_t* b);
void read_access_unit_delimiter_rbsp(h264_stream_t* h, bs_t* b);
void read_end_of_seq_rbsp(h264_stream_t* h, bs_t* b);
void read_end_of_stream_rbsp(h264_stream_t* h, bs_t* b);
void read_filler_data_rbsp(h264_stream_t* h, bs_t* b);
void read_slice_layer_rbsp(h264_stream_t* h,  bs_t* b);
void read_rbsp_slice_trailing_bits(h264_stream_t* h, bs_t* b);
void read_rbsp_trailing_bits(h264_stream_t* h, bs_t* b);
void read_slice_header(h264_stream_t* h, bs_t* b);
void read_ref_pic_list_reordering(h264_stream_t* h, bs_t* b);
void read_pred_weight_table(h264_stream_t* h, bs_t* b);
void read_dec_ref_pic_marking(h264_stream_t* h, bs_t* b);



//7.3.1 NAL unit syntax
int read_nal_unit(h264_stream_t* h, uint8_t* buf, int size)
{
    nal_t* nal = h->nal;

    int nal_size = size;
    int rbsp_size = size;
    uint8_t* rbsp_buf = (uint8_t*)calloc(1, rbsp_size);

    if( 1 )
    {
    int rc = nal_to_rbsp(buf, &nal_size, rbsp_buf, &rbsp_size);

    if (rc < 0) { free(rbsp_buf); return -1; } // handle conversion error
    }

    if( 0 )
    {
    rbsp_size = size*3/4; // NOTE this may have to be slightly smaller (3/4 smaller, worst case) in order to be guaranteed to fit
    }

    bs_t* b = bs_new(rbsp_buf, rbsp_size);
    /* forbidden_zero_bit */ bs_skip_u(b, 1);
    nal->nal_ref_idc = bs_read_u(b, 2);
    nal->nal_unit_type = bs_read_u(b, 5);

    switch ( nal->nal_unit_type )
    {
        case NAL_UNIT_TYPE_CODED_SLICE_IDR:
        case NAL_UNIT_TYPE_CODED_SLICE_NON_IDR:  
        case NAL_UNIT_TYPE_CODED_SLICE_AUX:
            read_slice_layer_rbsp(h, b);
            break;

#ifdef HAVE_SEI
        case NAL_UNIT_TYPE_SEI:
            read_sei_rbsp(h, b);
            break;
#endif

        case NAL_UNIT_TYPE_SPS: 
            read_seq_parameter_set_rbsp(h, b); 
            break;

        case NAL_UNIT_TYPE_PPS:   
            read_pic_parameter_set_rbsp(h, b);
            break;

        case NAL_UNIT_TYPE_AUD:     
            read_access_unit_delimiter_rbsp(h, b); 
            break;

        case NAL_UNIT_TYPE_END_OF_SEQUENCE: 
            read_end_of_seq_rbsp(h, b);
            break;

        case NAL_UNIT_TYPE_END_OF_STREAM: 
            read_end_of_stream_rbsp(h, b);
            break;

        case NAL_UNIT_TYPE_FILLER:
        case NAL_UNIT_TYPE_SPS_EXT:
        case NAL_UNIT_TYPE_UNSPECIFIED:
        case NAL_UNIT_TYPE_CODED_SLICE_DATA_PARTITION_A:  
        case NAL_UNIT_TYPE_CODED_SLICE_DATA_PARTITION_B: 
        case NAL_UNIT_TYPE_CODED_SLICE_DATA_PARTITION_C:
        default:
            return -1;
    }

    if (bs_overrun(b)) { bs_free(b); free(rbsp_buf); return -1; }

    if( 0 )
    {
    // now get the actual size used
    rbsp_size = bs_pos(b);

    int rc = rbsp_to_nal(rbsp_buf, &rbsp_size, buf, &nal_size);
    if (rc < 0) { bs_free(b); free(rbsp_buf); return -1; }
    }

    bs_free(b);
    free(rbsp_buf);

    return nal_size;
}



//7.3.2.1 Sequence parameter set RBSP syntax
void read_seq_parameter_set_rbsp(h264_stream_t* h, bs_t* b)
{
    int i;

    sps_t* sps = h->sps;
    if( 1 )
    {
        memset(sps, 0, sizeof(sps_t));
        sps->chroma_format_idc = 1; 
    }
 
    sps->profile_idc = bs_read_u8(b);
    sps->constraint_set0_flag = bs_read_u1(b);
    sps->constraint_set1_flag = bs_read_u1(b);
    sps->constraint_set2_flag = bs_read_u1(b);
    sps->constraint_set3_flag = bs_read_u1(b);
    sps->constraint_set4_flag = bs_read_u1(b);
    sps->constraint_set5_flag = bs_read_u1(b);
    /* reserved_zero_2bits */ bs_skip_u(b, 2);
    sps->level_idc = bs_read_u8(b);
    sps->seq_parameter_set_id = bs_read_ue(b);

    if( sps->profile_idc == 100 || sps->profile_idc == 110 ||
        sps->profile_idc == 122 || sps->profile_idc == 144 )
    {
        sps->chroma_format_idc = bs_read_ue(b);
        if( sps->chroma_format_idc == 3 )
        {
            sps->residual_colour_transform_flag = bs_read_u1(b);
        }
        sps->bit_depth_luma_minus8 = bs_read_ue(b);
        sps->bit_depth_chroma_minus8 = bs_read_ue(b);
        sps->qpprime_y_zero_transform_bypass_flag = bs_read_u1(b);
        sps->seq_scaling_matrix_present_flag = bs_read_u1(b);
        if( sps->seq_scaling_matrix_present_flag )
        {
            for( i = 0; i < 8; i++ )
            {
                sps->seq_scaling_list_present_flag[ i ] = bs_read_u1(b);
                if( sps->seq_scaling_list_present_flag[ i ] )
                {
                    if( i < 6 )
                    {
                        read_scaling_list( b, sps->ScalingList4x4[ i ], 16,
                                                 &( sps->UseDefaultScalingMatrix4x4Flag[ i ] ) );
                    }
                    else
                    {
                        read_scaling_list( b, sps->ScalingList8x8[ i - 6 ], 64,
                                                 &( sps->UseDefaultScalingMatrix8x8Flag[ i - 6 ] ) );
                    }
                }
            }
        }
    }
    sps->log2_max_frame_num_minus4 = bs_read_ue(b);
    sps->pic_order_cnt_type = bs_read_ue(b);
    if( sps->pic_order_cnt_type == 0 )
    {
        sps->log2_max_pic_order_cnt_lsb_minus4 = bs_read_ue(b);
    }
    else if( sps->pic_order_cnt_type == 1 )
    {
        sps->delta_pic_order_always_zero_flag = bs_read_u1(b);
        sps->offset_for_non_ref_pic = bs_read_se(b);
        sps->offset_for_top_to_bottom_field = bs_read_se(b);
        sps->num_ref_frames_in_pic_order_cnt_cycle = bs_read_ue(b);
        for( i = 0; i < sps->num_ref_frames_in_pic_order_cnt_cycle; i++ )
        {
            sps->offset_for_ref_frame[ i ] = bs_read_se(b);
        }
    }
    sps->num_ref_frames = bs_read_ue(b);
    sps->gaps_in_frame_num_value_allowed_flag = bs_read_u1(b);
    sps->pic_width_in_mbs_minus1 = bs_read_ue(b);
    sps->pic_height_in_map_units_minus1 = bs_read_ue(b);
    sps->frame_mbs_only_flag = bs_read_u1(b);
    if( !sps->frame_mbs_only_flag )
    {
        sps->mb_adaptive_frame_field_flag = bs_read_u1(b);
    }
    sps->direct_8x8_inference_flag = bs_read_u1(b);
    sps->frame_cropping_flag = bs_read_u1(b);
    if( sps->frame_cropping_flag )
    {
        sps->frame_crop_left_offset = bs_read_ue(b);
        sps->frame_crop_right_offset = bs_read_ue(b);
        sps->frame_crop_top_offset = bs_read_ue(b);
        sps->frame_crop_bottom_offset = bs_read_ue(b);
    }
    sps->vui_parameters_present_flag = bs_read_u1(b);
    if( sps->vui_parameters_present_flag )
    {
        read_vui_parameters(h, b);
    }
    read_rbsp_trailing_bits(h, b);

    if( 1 )
    {
        memcpy(h->sps_table[sps->seq_parameter_set_id], h->sps, sizeof(sps_t));
    }
}


//7.3.2.1.1 Scaling list syntax
void read_scaling_list(bs_t* b, int* scalingList, int sizeOfScalingList, int* useDefaultScalingMatrixFlag )
{
    // NOTE need to be able to set useDefaultScalingMatrixFlag when reading, hence passing as pointer
    int lastScale = 8;
    int nextScale = 8;
    int delta_scale;
    for( int j = 0; j < sizeOfScalingList; j++ )
    {
        if( nextScale != 0 )
        {
            if( 0 )
            {
                nextScale = scalingList[ j ];
                if (useDefaultScalingMatrixFlag[0]) { nextScale = 0; }
                delta_scale = (nextScale - lastScale) % 256 ;
            }

            delta_scale = bs_read_se(b);

            if( 1 )
            {
                nextScale = ( lastScale + delta_scale + 256 ) % 256;
                useDefaultScalingMatrixFlag[0] = ( j == 0 && nextScale == 0 );
            }
        }
        if( 1 )
        {
            scalingList[ j ] = ( nextScale == 0 ) ? lastScale : nextScale;
        }
        lastScale = scalingList[ j ];
    }
}

//Appendix E.1.1 VUI parameters syntax
void read_vui_parameters(h264_stream_t* h, bs_t* b)
{
    sps_t* sps = h->sps;

    sps->vui.aspect_ratio_info_present_flag = bs_read_u1(b);
    if( sps->vui.aspect_ratio_info_present_flag )
    {
        sps->vui.aspect_ratio_idc = bs_read_u8(b);
        if( sps->vui.aspect_ratio_idc == SAR_Extended )
        {
            sps->vui.sar_width = bs_read_u(b, 16);
            sps->vui.sar_height = bs_read_u(b, 16);
        }
    }
    sps->vui.overscan_info_present_flag = bs_read_u1(b);
    if( sps->vui.overscan_info_present_flag )
    {
        sps->vui.overscan_appropriate_flag = bs_read_u1(b);
    }
    sps->vui.video_signal_type_present_flag = bs_read_u1(b);
    if( sps->vui.video_signal_type_present_flag )
    {
        sps->vui.video_format = bs_read_u(b, 3);
        sps->vui.video_full_range_flag = bs_read_u1(b);
        sps->vui.colour_description_present_flag = bs_read_u1(b);
        if( sps->vui.colour_description_present_flag )
        {
            sps->vui.colour_primaries = bs_read_u8(b);
            sps->vui.transfer_characteristics = bs_read_u8(b);
            sps->vui.matrix_coefficients = bs_read_u8(b);
        }
    }
    sps->vui.chroma_loc_info_present_flag = bs_read_u1(b);
    if( sps->vui.chroma_loc_info_present_flag )
    {
        sps->vui.chroma_sample_loc_type_top_field = bs_read_ue(b);
        sps->vui.chroma_sample_loc_type_bottom_field = bs_read_ue(b);
    }
    sps->vui.timing_info_present_flag = bs_read_u1(b);
    if( sps->vui.timing_info_present_flag )
    {
        sps->vui.num_units_in_tick = bs_read_u(b, 32);
        sps->vui.time_scale = bs_read_u(b, 32);
        sps->vui.fixed_frame_rate_flag = bs_read_u1(b);
    }
    sps->vui.nal_hrd_parameters_present_flag = bs_read_u1(b);
    if( sps->vui.nal_hrd_parameters_present_flag )
    {
        read_hrd_parameters(h, b);
    }
    sps->vui.vcl_hrd_parameters_present_flag = bs_read_u1(b);
    if( sps->vui.vcl_hrd_parameters_present_flag )
    {
        read_hrd_parameters(h, b);
    }
    if( sps->vui.nal_hrd_parameters_present_flag || sps->vui.vcl_hrd_parameters_present_flag )
    {
        sps->vui.low_delay_hrd_flag = bs_read_u1(b);
    }
    sps->vui.pic_struct_present_flag = bs_read_u1(b);
    sps->vui.bitstream_restriction_flag = bs_read_u1(b);
    if( sps->vui.bitstream_restriction_flag )
    {
        sps->vui.motion_vectors_over_pic_boundaries_flag = bs_read_u1(b);
        sps->vui.max_bytes_per_pic_denom = bs_read_ue(b);
        sps->vui.max_bits_per_mb_denom = bs_read_ue(b);
        sps->vui.log2_max_mv_length_horizontal = bs_read_ue(b);
        sps->vui.log2_max_mv_length_vertical = bs_read_ue(b);
        sps->vui.num_reorder_frames = bs_read_ue(b);
        sps->vui.max_dec_frame_buffering = bs_read_ue(b);
    }
}


//Appendix E.1.2 HRD parameters syntax
void read_hrd_parameters(h264_stream_t* h, bs_t* b)
{
    sps_t* sps = h->sps;

    sps->hrd.cpb_cnt_minus1 = bs_read_ue(b);
    sps->hrd.bit_rate_scale = bs_read_u(b, 4);
    sps->hrd.cpb_size_scale = bs_read_u(b, 4);
    for( int SchedSelIdx = 0; SchedSelIdx <= sps->hrd.cpb_cnt_minus1; SchedSelIdx++ )
    {
        sps->hrd.bit_rate_value_minus1[ SchedSelIdx ] = bs_read_ue(b);
        sps->hrd.cpb_size_value_minus1[ SchedSelIdx ] = bs_read_ue(b);
        sps->hrd.cbr_flag[ SchedSelIdx ] = bs_read_u1(b);
    }
    sps->hrd.initial_cpb_removal_delay_length_minus1 = bs_read_u(b, 5);
    sps->hrd.cpb_removal_delay_length_minus1 = bs_read_u(b, 5);
    sps->hrd.dpb_output_delay_length_minus1 = bs_read_u(b, 5);
    sps->hrd.time_offset_length = bs_read_u(b, 5);
}


/*
UNIMPLEMENTED
//7.3.2.1.2 Sequence parameter set extension RBSP syntax
int read_seq_parameter_set_extension_rbsp(bs_t* b, sps_ext_t* sps_ext) {
    seq_parameter_set_id = bs_read_ue(b);
    aux_format_idc = bs_read_ue(b);
    if( aux_format_idc != 0 ) {
        bit_depth_aux_minus8 = bs_read_ue(b);
        alpha_incr_flag = bs_read_u1(b);
        alpha_opaque_value = bs_read_u(v);
        alpha_transparent_value = bs_read_u(v);
    }
    additional_extension_flag = bs_read_u1(b);
    read_rbsp_trailing_bits();
}
*/

//7.3.2.2 Picture parameter set RBSP syntax
void read_pic_parameter_set_rbsp(h264_stream_t* h, bs_t* b)
{
    pps_t* pps = h->pps;
    if( 1 )
    {
        memset(pps, 0, sizeof(pps_t));
    }

    pps->pic_parameter_set_id = bs_read_ue(b);
    pps->seq_parameter_set_id = bs_read_ue(b);
    pps->entropy_coding_mode_flag = bs_read_u1(b);
    pps->pic_order_present_flag = bs_read_u1(b);
    pps->num_slice_groups_minus1 = bs_read_ue(b);

    if( pps->num_slice_groups_minus1 > 0 )
    {
        pps->slice_group_map_type = bs_read_ue(b);
        if( pps->slice_group_map_type == 0 )
        {
            for( int i_group = 0; i_group <= pps->num_slice_groups_minus1; i_group++ )
            {
                pps->run_length_minus1[ i_group ] = bs_read_ue(b);
            }
        }
        else if( pps->slice_group_map_type == 2 )
        {
            for( int i_group = 0; i_group < pps->num_slice_groups_minus1; i_group++ )
            {
                pps->top_left[ i_group ] = bs_read_ue(b);
                pps->bottom_right[ i_group ] = bs_read_ue(b);
            }
        }
        else if( pps->slice_group_map_type == 3 ||
                 pps->slice_group_map_type == 4 ||
                 pps->slice_group_map_type == 5 )
        {
            pps->slice_group_change_direction_flag = bs_read_u1(b);
            pps->slice_group_change_rate_minus1 = bs_read_ue(b);
        }
        else if( pps->slice_group_map_type == 6 )
        {
            pps->pic_size_in_map_units_minus1 = bs_read_ue(b);
            for( int i = 0; i <= pps->pic_size_in_map_units_minus1; i++ )
            {
                int v = intlog2( pps->num_slice_groups_minus1 + 1 );
                pps->slice_group_id[ i ] = bs_read_u(b, v);
            }
        }
    }
    pps->num_ref_idx_l0_active_minus1 = bs_read_ue(b);
    pps->num_ref_idx_l1_active_minus1 = bs_read_ue(b);
    pps->weighted_pred_flag = bs_read_u1(b);
    pps->weighted_bipred_idc = bs_read_u(b, 2);
    pps->pic_init_qp_minus26 = bs_read_se(b);
    pps->pic_init_qs_minus26 = bs_read_se(b);
    pps->chroma_qp_index_offset = bs_read_se(b);
    pps->deblocking_filter_control_present_flag = bs_read_u1(b);
    pps->constrained_intra_pred_flag = bs_read_u1(b);
    pps->redundant_pic_cnt_present_flag = bs_read_u1(b);

    int have_more_data = 0;
    if( 1 ) { have_more_data = more_rbsp_data(h, b); }
    if( 0 )
    {
        have_more_data = pps->transform_8x8_mode_flag | pps->pic_scaling_matrix_present_flag | pps->second_chroma_qp_index_offset != 0;
    }

    if( have_more_data )
    {
        pps->transform_8x8_mode_flag = bs_read_u1(b);
        pps->pic_scaling_matrix_present_flag = bs_read_u1(b);
        if( pps->pic_scaling_matrix_present_flag )
        {
            for( int i = 0; i < 6 + 2* pps->transform_8x8_mode_flag; i++ )
            {
                pps->pic_scaling_list_present_flag[ i ] = bs_read_u1(b);
                if( pps->pic_scaling_list_present_flag[ i ] )
                {
                    if( i < 6 )
                    {
                        read_scaling_list( b, pps->ScalingList4x4[ i ], 16,
                                                 &( pps->UseDefaultScalingMatrix4x4Flag[ i ] ) );
                    }
                    else
                    {
                        read_scaling_list( b, pps->ScalingList8x8[ i - 6 ], 64,
                                                 &( pps->UseDefaultScalingMatrix8x8Flag[ i - 6 ] ) );
                    }
                }
            }
        }
        pps->second_chroma_qp_index_offset = bs_read_se(b);
    }
    read_rbsp_trailing_bits(h, b);

    if( 1 )
    {
        memcpy(h->pps, h->pps_table[pps->pic_parameter_set_id], sizeof(pps_t));
    }
}

#ifdef HAVE_SEI
//7.3.2.3 Supplemental enhancement information RBSP syntax
void read_sei_rbsp(h264_stream_t* h, bs_t* b)
{
    if( 1 )
    {
    for( int i = 0; i < h->num_seis; i++ )
    {
        sei_free(h->seis[i]);
    }
    
    h->num_seis = 0;
    do {
        h->num_seis++;
        h->seis = (sei_t**)realloc(h->seis, h->num_seis * sizeof(sei_t*));
        h->seis[h->num_seis - 1] = sei_new();
        h->sei = h->seis[h->num_seis - 1];
        read_sei_message(h, b);
    } while( more_rbsp_data(h, b) );

    }

    if( 0 )
    {
    for (int i = 0; i < h->num_seis; i++)
    {
        h->sei = h->seis[i];
        read_sei_message(h, b);
    }
    h->sei = NULL;
    }

    read_rbsp_trailing_bits(h, b);
}

//7.3.2.3.1 Supplemental enhancement information message syntax
void read_sei_message(h264_stream_t* h, bs_t* b)
{
    if( 0 )
    {
        _write_ff_coded_number(b, h->sei->payloadType);
        _write_ff_coded_number(b, h->sei->payloadSize);
    }
    if( 1 )
    {
        h->sei->payloadType = _read_ff_coded_number(b);
        h->sei->payloadSize = _read_ff_coded_number(b);
    }
    read_sei_payload( h, b, h->sei->payloadType, h->sei->payloadSize );
}
#endif

//7.3.2.4 Access unit delimiter RBSP syntax
void read_access_unit_delimiter_rbsp(h264_stream_t* h, bs_t* b)
{
    h->aud->primary_pic_type = bs_read_u(b, 3);
    read_rbsp_trailing_bits(h, b);
}

//7.3.2.5 End of sequence RBSP syntax
void read_end_of_seq_rbsp(h264_stream_t* h, bs_t* b)
{
}

//7.3.2.6 End of stream RBSP syntax
void read_end_of_stream_rbsp(h264_stream_t* h, bs_t* b)
{
}

//7.3.2.7 Filler data RBSP syntax
void read_filler_data_rbsp(h264_stream_t* h, bs_t* b)
{
    while( bs_next_bits(b, 8) == 0xFF )
    {
        /* ff_byte */ bs_skip_u(b, 8);
    }
    read_rbsp_trailing_bits(h, b);
}

//7.3.2.8 Slice layer without partitioning RBSP syntax
void read_slice_layer_rbsp(h264_stream_t* h,  bs_t* b)
{
    read_slice_header(h, b);
    slice_data_rbsp_t* slice_data = h->slice_data;

    if ( slice_data != NULL )
    {
        if ( slice_data->rbsp_buf != NULL ) free( slice_data->rbsp_buf ); 
        uint8_t *sptr = b->p + (!!b->bits_left); // CABAC-specific: skip alignment bits, if there are any
        slice_data->rbsp_size = b->end - sptr;
        
        slice_data->rbsp_buf = (uint8_t*)malloc(slice_data->rbsp_size);
        memcpy( slice_data->rbsp_buf, sptr, slice_data->rbsp_size );
        // ugly hack: since next NALU starts at byte border, we are going to be padded by trailing_bits;
        return;
    }

    // FIXME should read or skip data
    //slice_data( ); /* all categories of slice_data( ) syntax */
    read_rbsp_slice_trailing_bits(h, b);
}

/*
// UNIMPLEMENTED
//7.3.2.9.1 Slice data partition A RBSP syntax
slice_data_partition_a_layer_rbsp( ) {
    read_slice_header( );             // only category 2
    slice_id = bs_read_ue(b)
    read_slice_data( );               // only category 2
    read_rbsp_slice_trailing_bits( ); // only category 2
}

//7.3.2.9.2 Slice data partition B RBSP syntax
slice_data_partition_b_layer_rbsp( ) {
    slice_id = bs_read_ue(b);    // only category 3
    if( redundant_pic_cnt_present_flag )
        redundant_pic_cnt = bs_read_ue(b);
    read_slice_data( );               // only category 3
    read_rbsp_slice_trailing_bits( ); // only category 3
}

//7.3.2.9.3 Slice data partition C RBSP syntax
slice_data_partition_c_layer_rbsp( ) {
    slice_id = bs_read_ue(b);    // only category 4
    if( redundant_pic_cnt_present_flag )
        redundant_pic_cnt = bs_read_ue(b);
    read_slice_data( );               // only category 4
    rbsp_slice_trailing_bits( ); // only category 4
}
*/

//7.3.2.10 RBSP slice trailing bits syntax
void read_rbsp_slice_trailing_bits(h264_stream_t* h, bs_t* b)
{
    read_rbsp_trailing_bits(h, b);
    if( h->pps->entropy_coding_mode_flag )
    {
        while( more_rbsp_trailing_data(h, b) )
        {
            /* cabac_zero_word */ bs_skip_u(b, 16);
        }
    }
}

//7.3.2.11 RBSP trailing bits syntax
void read_rbsp_trailing_bits(h264_stream_t* h, bs_t* b)
{
    /* rbsp_stop_one_bit */ bs_skip_u(b, 1);

    while( !bs_byte_aligned(b) )
    {
        /* rbsp_alignment_zero_bit */ bs_skip_u(b, 1);
    }
}

//7.3.3 Slice header syntax
void read_slice_header(h264_stream_t* h, bs_t* b)
{
    slice_header_t* sh = h->sh;
    if( 1 )
    {
        memset(sh, 0, sizeof(slice_header_t));
    }

    nal_t* nal = h->nal;

    sh->first_mb_in_slice = bs_read_ue(b);
    sh->slice_type = bs_read_ue(b);
    sh->pic_parameter_set_id = bs_read_ue(b);

    // TODO check existence, otherwise fail
    pps_t* pps = h->pps;
    sps_t* sps = h->sps;
    memcpy(h->pps_table[sh->pic_parameter_set_id], h->pps, sizeof(pps_t));
    memcpy(h->sps_table[pps->seq_parameter_set_id], h->sps, sizeof(sps_t));

    sh->frame_num = bs_read_u(b, sps->log2_max_frame_num_minus4 + 4 ); // was u(v)
    if( !sps->frame_mbs_only_flag )
    {
        sh->field_pic_flag = bs_read_u1(b);
        if( sh->field_pic_flag )
        {
            sh->bottom_field_flag = bs_read_u1(b);
        }
    }
    if( nal->nal_unit_type == 5 )
    {
        sh->idr_pic_id = bs_read_ue(b);
    }
    if( sps->pic_order_cnt_type == 0 )
    {
        sh->pic_order_cnt_lsb = bs_read_u(b, sps->log2_max_pic_order_cnt_lsb_minus4 + 4 ); // was u(v)
        if( pps->pic_order_present_flag && !sh->field_pic_flag )
        {
            sh->delta_pic_order_cnt_bottom = bs_read_se(b);
        }
    }
    if( sps->pic_order_cnt_type == 1 && !sps->delta_pic_order_always_zero_flag )
    {
        sh->delta_pic_order_cnt[ 0 ] = bs_read_se(b);
        if( pps->pic_order_present_flag && !sh->field_pic_flag )
        {
            sh->delta_pic_order_cnt[ 1 ] = bs_read_se(b);
        }
    }
    if( pps->redundant_pic_cnt_present_flag )
    {
        sh->redundant_pic_cnt = bs_read_ue(b);
    }
    if( is_slice_type( sh->slice_type, SH_SLICE_TYPE_B ) )
    {
        sh->direct_spatial_mv_pred_flag = bs_read_u1(b);
    }
    if( is_slice_type( sh->slice_type, SH_SLICE_TYPE_P ) || is_slice_type( sh->slice_type, SH_SLICE_TYPE_SP ) || is_slice_type( sh->slice_type, SH_SLICE_TYPE_B ) )
    {
        sh->num_ref_idx_active_override_flag = bs_read_u1(b);
        if( sh->num_ref_idx_active_override_flag )
        {
            sh->num_ref_idx_l0_active_minus1 = bs_read_ue(b); // FIXME does this modify the pps?
            if( is_slice_type( sh->slice_type, SH_SLICE_TYPE_B ) )
            {
                sh->num_ref_idx_l1_active_minus1 = bs_read_ue(b);
            }
        }
    }
    read_ref_pic_list_reordering(h, b);
    if( ( pps->weighted_pred_flag && ( is_slice_type( sh->slice_type, SH_SLICE_TYPE_P ) || is_slice_type( sh->slice_type, SH_SLICE_TYPE_SP ) ) ) ||
        ( pps->weighted_bipred_idc == 1 && is_slice_type( sh->slice_type, SH_SLICE_TYPE_B ) ) )
    {
        read_pred_weight_table(h, b);
    }
    if( nal->nal_ref_idc != 0 )
    {
        read_dec_ref_pic_marking(h, b);
    }
    if( pps->entropy_coding_mode_flag && ! is_slice_type( sh->slice_type, SH_SLICE_TYPE_I ) && ! is_slice_type( sh->slice_type, SH_SLICE_TYPE_SI ) )
    {
        sh->cabac_init_idc = bs_read_ue(b);
    }
    sh->slice_qp_delta = bs_read_se(b);
    if( is_slice_type( sh->slice_type, SH_SLICE_TYPE_SP ) || is_slice_type( sh->slice_type, SH_SLICE_TYPE_SI ) )
    {
        if( is_slice_type( sh->slice_type, SH_SLICE_TYPE_SP ) )
        {
            sh->sp_for_switch_flag = bs_read_u1(b);
        }
        sh->slice_qs_delta = bs_read_se(b);
    }
    if( pps->deblocking_filter_control_present_flag )
    {
        sh->disable_deblocking_filter_idc = bs_read_ue(b);
        if( sh->disable_deblocking_filter_idc != 1 )
        {
            sh->slice_alpha_c0_offset_div2 = bs_read_se(b);
            sh->slice_beta_offset_div2 = bs_read_se(b);
        }
    }
    if( pps->num_slice_groups_minus1 > 0 &&
        pps->slice_group_map_type >= 3 && pps->slice_group_map_type <= 5)
    {
        int v = intlog2( pps->pic_size_in_map_units_minus1 +  pps->slice_group_change_rate_minus1 + 1 );
        sh->slice_group_change_cycle = bs_read_u(b, v); // FIXME add 2?
    }
}

//7.3.3.1 Reference picture list reordering syntax
void read_ref_pic_list_reordering(h264_stream_t* h, bs_t* b)
{
    slice_header_t* sh = h->sh;
    // FIXME should be an array

    if( ! is_slice_type( sh->slice_type, SH_SLICE_TYPE_I ) && ! is_slice_type( sh->slice_type, SH_SLICE_TYPE_SI ) )
    {
        sh->rplr.ref_pic_list_reordering_flag_l0 = bs_read_u1(b);
        if( sh->rplr.ref_pic_list_reordering_flag_l0 )
        {
            int n = -1;
            do
            {
                n++;
                sh->rplr.reorder_l0.reordering_of_pic_nums_idc[ n ] = bs_read_ue(b);
                if( sh->rplr.reorder_l0.reordering_of_pic_nums_idc[ n ] == 0 ||
                    sh->rplr.reorder_l0.reordering_of_pic_nums_idc[ n ] == 1 )
                {
                    sh->rplr.reorder_l0.abs_diff_pic_num_minus1[ n ] = bs_read_ue(b);
                }
                else if( sh->rplr.reorder_l0.reordering_of_pic_nums_idc[ n ] == 2 )
                {
                    sh->rplr.reorder_l0.long_term_pic_num[ n ] = bs_read_ue(b);
                }
            } while( sh->rplr.reorder_l0.reordering_of_pic_nums_idc[ n ] != 3 && ! bs_eof(b) );
        }
    }
    if( is_slice_type( sh->slice_type, SH_SLICE_TYPE_B ) )
    {
        sh->rplr.ref_pic_list_reordering_flag_l1 = bs_read_u1(b);
        if( sh->rplr.ref_pic_list_reordering_flag_l1 )
        {
            int n = -1;
            do
            {
                n++;
                sh->rplr.reorder_l1.reordering_of_pic_nums_idc[ n ] = bs_read_ue(b);
                if( sh->rplr.reorder_l1.reordering_of_pic_nums_idc[ n ] == 0 ||
                    sh->rplr.reorder_l1.reordering_of_pic_nums_idc[ n ] == 1 )
                {
                    sh->rplr.reorder_l1.abs_diff_pic_num_minus1[ n ] = bs_read_ue(b);
                }
                else if( sh->rplr.reorder_l1.reordering_of_pic_nums_idc[ n ] == 2 )
                {
                    sh->rplr.reorder_l1.long_term_pic_num[ n ] = bs_read_ue(b);
                }
            } while( sh->rplr.reorder_l1.reordering_of_pic_nums_idc[ n ] != 3 && ! bs_eof(b) );
        }
    }
}

//7.3.3.2 Prediction weight table syntax
void read_pred_weight_table(h264_stream_t* h, bs_t* b)
{
    slice_header_t* sh = h->sh;
    sps_t* sps = h->sps;
    pps_t* pps = h->pps;

    int i, j;

    sh->pwt.luma_log2_weight_denom = bs_read_ue(b);
    if( sps->chroma_format_idc != 0 )
    {
        sh->pwt.chroma_log2_weight_denom = bs_read_ue(b);
    }
    for( i = 0; i <= pps->num_ref_idx_l0_active_minus1; i++ )
    {
        sh->pwt.luma_weight_l0_flag[i] = bs_read_u1(b);
        if( sh->pwt.luma_weight_l0_flag[i] )
        {
            sh->pwt.luma_weight_l0[ i ] = bs_read_se(b);
            sh->pwt.luma_offset_l0[ i ] = bs_read_se(b);
        }
        if ( sps->chroma_format_idc != 0 )
        {
            sh->pwt.chroma_weight_l0_flag[i] = bs_read_u1(b);
            if( sh->pwt.chroma_weight_l0_flag[i] )
            {
                for( j =0; j < 2; j++ )
                {
                    sh->pwt.chroma_weight_l0[ i ][ j ] = bs_read_se(b);
                    sh->pwt.chroma_offset_l0[ i ][ j ] = bs_read_se(b);
                }
            }
        }
    }
    if( is_slice_type( sh->slice_type, SH_SLICE_TYPE_B ) )
    {
        for( i = 0; i <= pps->num_ref_idx_l1_active_minus1; i++ )
        {
            sh->pwt.luma_weight_l1_flag[i] = bs_read_u1(b);
            if( sh->pwt.luma_weight_l1_flag[i] )
            {
                sh->pwt.luma_weight_l1[ i ] = bs_read_se(b);
                sh->pwt.luma_offset_l1[ i ] = bs_read_se(b);
            }
            if( sps->chroma_format_idc != 0 )
            {
                sh->pwt.chroma_weight_l1_flag[i] = bs_read_u1(b);
                if( sh->pwt.chroma_weight_l1_flag[i] )
                {
                    for( j = 0; j < 2; j++ )
                    {
                        sh->pwt.chroma_weight_l1[ i ][ j ] = bs_read_se(b);
                        sh->pwt.chroma_offset_l1[ i ][ j ] = bs_read_se(b);
                    }
                }
            }
        }
    }
}

//7.3.3.3 Decoded reference picture marking syntax
void read_dec_ref_pic_marking(h264_stream_t* h, bs_t* b)
{
    slice_header_t* sh = h->sh;
    // FIXME should be an array

    if( h->nal->nal_unit_type == 5 )
    {
        sh->drpm.no_output_of_prior_pics_flag = bs_read_u1(b);
        sh->drpm.long_term_reference_flag = bs_read_u1(b);
    }
    else
    {
        sh->drpm.adaptive_ref_pic_marking_mode_flag = bs_read_u1(b);
        if( sh->drpm.adaptive_ref_pic_marking_mode_flag )
        {
            int n = -1;
            do
            {
                n++;
                sh->drpm.memory_management_control_operation[ n ] = bs_read_ue(b);
                if( sh->drpm.memory_management_control_operation[ n ] == 1 ||
                    sh->drpm.memory_management_control_operation[ n ] == 3 )
                {
                    sh->drpm.difference_of_pic_nums_minus1[ n ] = bs_read_ue(b);
                }
                if(sh->drpm.memory_management_control_operation[ n ] == 2 )
                {
                    sh->drpm.long_term_pic_num[ n ] = bs_read_ue(b);
                }
                if( sh->drpm.memory_management_control_operation[ n ] == 3 ||
                    sh->drpm.memory_management_control_operation[ n ] == 6 )
                {
                    sh->drpm.long_term_frame_idx[ n ] = bs_read_ue(b);
                }
                if( sh->drpm.memory_management_control_operation[ n ] == 4 )
                {
                    sh->drpm.max_long_term_frame_idx_plus1[ n ] = bs_read_ue(b);
                }
            } while( sh->drpm.memory_management_control_operation[ n ] != 0 && ! bs_eof(b) );
        }
    }
}


void write_seq_parameter_set_rbsp(h264_stream_t* h, bs_t* b);
void write_scaling_list(bs_t* b, int* scalingList, int sizeOfScalingList, int* useDefaultScalingMatrixFlag );
void write_vui_parameters(h264_stream_t* h, bs_t* b);
void write_hrd_parameters(h264_stream_t* h, bs_t* b);
void write_pic_parameter_set_rbsp(h264_stream_t* h, bs_t* b);
void write_sei_rbsp(h264_stream_t* h, bs_t* b);
void write_sei_message(h264_stream_t* h, bs_t* b);
void write_access_unit_delimiter_rbsp(h264_stream_t* h, bs_t* b);
void write_end_of_seq_rbsp(h264_stream_t* h, bs_t* b);
void write_end_of_stream_rbsp(h264_stream_t* h, bs_t* b);
void write_filler_data_rbsp(h264_stream_t* h, bs_t* b);
void write_slice_layer_rbsp(h264_stream_t* h,  bs_t* b);
void write_rbsp_slice_trailing_bits(h264_stream_t* h, bs_t* b);
void write_rbsp_trailing_bits(h264_stream_t* h, bs_t* b);
void write_slice_header(h264_stream_t* h, bs_t* b);
void write_ref_pic_list_reordering(h264_stream_t* h, bs_t* b);
void write_pred_weight_table(h264_stream_t* h, bs_t* b);
void write_dec_ref_pic_marking(h264_stream_t* h, bs_t* b);



//7.3.1 NAL unit syntax
int write_nal_unit(h264_stream_t* h, uint8_t* buf, int size)
{
    nal_t* nal = h->nal;

    int nal_size = size;
    int rbsp_size = size;
    uint8_t* rbsp_buf = (uint8_t*)calloc(1, rbsp_size);

    if( 0 )
    {
    int rc = nal_to_rbsp(buf, &nal_size, rbsp_buf, &rbsp_size);

    if (rc < 0) { free(rbsp_buf); return -1; } // handle conversion error
    }

    if( 1 )
    {
    rbsp_size = size*3/4; // NOTE this may have to be slightly smaller (3/4 smaller, worst case) in order to be guaranteed to fit
    }

    bs_t* b = bs_new(rbsp_buf, rbsp_size);
    /* forbidden_zero_bit */ bs_write_u(b, 1, 0);
    bs_write_u(b, 2, nal->nal_ref_idc);
    bs_write_u(b, 5, nal->nal_unit_type);

    switch ( nal->nal_unit_type )
    {
        case NAL_UNIT_TYPE_CODED_SLICE_IDR:
        case NAL_UNIT_TYPE_CODED_SLICE_NON_IDR:  
        case NAL_UNIT_TYPE_CODED_SLICE_AUX:
            write_slice_layer_rbsp(h, b);
            break;

#ifdef HAVE_SEI
        case NAL_UNIT_TYPE_SEI:
            write_sei_rbsp(h, b);
            break;
#endif

        case NAL_UNIT_TYPE_SPS: 
            write_seq_parameter_set_rbsp(h, b); 
            break;

        case NAL_UNIT_TYPE_PPS:   
            write_pic_parameter_set_rbsp(h, b);
            break;

        case NAL_UNIT_TYPE_AUD:     
            write_access_unit_delimiter_rbsp(h, b); 
            break;

        case NAL_UNIT_TYPE_END_OF_SEQUENCE: 
            write_end_of_seq_rbsp(h, b);
            break;

        case NAL_UNIT_TYPE_END_OF_STREAM: 
            write_end_of_stream_rbsp(h, b);
            break;

        case NAL_UNIT_TYPE_FILLER:
        case NAL_UNIT_TYPE_SPS_EXT:
        case NAL_UNIT_TYPE_UNSPECIFIED:
        case NAL_UNIT_TYPE_CODED_SLICE_DATA_PARTITION_A:  
        case NAL_UNIT_TYPE_CODED_SLICE_DATA_PARTITION_B: 
        case NAL_UNIT_TYPE_CODED_SLICE_DATA_PARTITION_C:
        default:
            return -1;
    }

    if (bs_overrun(b)) { bs_free(b); free(rbsp_buf); return -1; }

    if( 1 )
    {
    // now get the actual size used
    rbsp_size = bs_pos(b);

    int rc = rbsp_to_nal(rbsp_buf, &rbsp_size, buf, &nal_size);
    if (rc < 0) { bs_free(b); free(rbsp_buf); return -1; }
    }

    bs_free(b);
    free(rbsp_buf);

    return nal_size;
}



//7.3.2.1 Sequence parameter set RBSP syntax
void write_seq_parameter_set_rbsp(h264_stream_t* h, bs_t* b)
{
    int i;

    sps_t* sps = h->sps;
    if( 0 )
    {
        memset(sps, 0, sizeof(sps_t));
        sps->chroma_format_idc = 1; 
    }
 
    bs_write_u8(b, sps->profile_idc);
    bs_write_u1(b, sps->constraint_set0_flag);
    bs_write_u1(b, sps->constraint_set1_flag);
    bs_write_u1(b, sps->constraint_set2_flag);
    bs_write_u1(b, sps->constraint_set3_flag);
    bs_write_u1(b, sps->constraint_set4_flag);
    bs_write_u1(b, sps->constraint_set5_flag);
    /* reserved_zero_2bits */ bs_write_u(b, 2, 0);
    bs_write_u8(b, sps->level_idc);
    bs_write_ue(b, sps->seq_parameter_set_id);

    if( sps->profile_idc == 100 || sps->profile_idc == 110 ||
        sps->profile_idc == 122 || sps->profile_idc == 144 )
    {
        bs_write_ue(b, sps->chroma_format_idc);
        if( sps->chroma_format_idc == 3 )
        {
            bs_write_u1(b, sps->residual_colour_transform_flag);
        }
        bs_write_ue(b, sps->bit_depth_luma_minus8);
        bs_write_ue(b, sps->bit_depth_chroma_minus8);
        bs_write_u1(b, sps->qpprime_y_zero_transform_bypass_flag);
        bs_write_u1(b, sps->seq_scaling_matrix_present_flag);
        if( sps->seq_scaling_matrix_present_flag )
        {
            for( i = 0; i < 8; i++ )
            {
                bs_write_u1(b, sps->seq_scaling_list_present_flag[ i ]);
                if( sps->seq_scaling_list_present_flag[ i ] )
                {
                    if( i < 6 )
                    {
                        write_scaling_list( b, sps->ScalingList4x4[ i ], 16,
                                                 &( sps->UseDefaultScalingMatrix4x4Flag[ i ] ) );
                    }
                    else
                    {
                        write_scaling_list( b, sps->ScalingList8x8[ i - 6 ], 64,
                                                 &( sps->UseDefaultScalingMatrix8x8Flag[ i - 6 ] ) );
                    }
                }
            }
        }
    }
    bs_write_ue(b, sps->log2_max_frame_num_minus4);
    bs_write_ue(b, sps->pic_order_cnt_type);
    if( sps->pic_order_cnt_type == 0 )
    {
        bs_write_ue(b, sps->log2_max_pic_order_cnt_lsb_minus4);
    }
    else if( sps->pic_order_cnt_type == 1 )
    {
        bs_write_u1(b, sps->delta_pic_order_always_zero_flag);
        bs_write_se(b, sps->offset_for_non_ref_pic);
        bs_write_se(b, sps->offset_for_top_to_bottom_field);
        bs_write_ue(b, sps->num_ref_frames_in_pic_order_cnt_cycle);
        for( i = 0; i < sps->num_ref_frames_in_pic_order_cnt_cycle; i++ )
        {
            bs_write_se(b, sps->offset_for_ref_frame[ i ]);
        }
    }
    bs_write_ue(b, sps->num_ref_frames);
    bs_write_u1(b, sps->gaps_in_frame_num_value_allowed_flag);
    bs_write_ue(b, sps->pic_width_in_mbs_minus1);
    bs_write_ue(b, sps->pic_height_in_map_units_minus1);
    bs_write_u1(b, sps->frame_mbs_only_flag);
    if( !sps->frame_mbs_only_flag )
    {
        bs_write_u1(b, sps->mb_adaptive_frame_field_flag);
    }
    bs_write_u1(b, sps->direct_8x8_inference_flag);
    bs_write_u1(b, sps->frame_cropping_flag);
    if( sps->frame_cropping_flag )
    {
        bs_write_ue(b, sps->frame_crop_left_offset);
        bs_write_ue(b, sps->frame_crop_right_offset);
        bs_write_ue(b, sps->frame_crop_top_offset);
        bs_write_ue(b, sps->frame_crop_bottom_offset);
    }
    bs_write_u1(b, sps->vui_parameters_present_flag);
    if( sps->vui_parameters_present_flag )
    {
        write_vui_parameters(h, b);
    }
    write_rbsp_trailing_bits(h, b);

    if( 0 )
    {
        memcpy(h->sps_table[sps->seq_parameter_set_id], h->sps, sizeof(sps_t));
    }
}


//7.3.2.1.1 Scaling list syntax
void write_scaling_list(bs_t* b, int* scalingList, int sizeOfScalingList, int* useDefaultScalingMatrixFlag )
{
    // NOTE need to be able to set useDefaultScalingMatrixFlag when reading, hence passing as pointer
    int lastScale = 8;
    int nextScale = 8;
    int delta_scale;
    for( int j = 0; j < sizeOfScalingList; j++ )
    {
        if( nextScale != 0 )
        {
            if( 1 )
            {
                nextScale = scalingList[ j ];
                if (useDefaultScalingMatrixFlag[0]) { nextScale = 0; }
                delta_scale = (nextScale - lastScale) % 256 ;
            }

            bs_write_se(b, delta_scale);

            if( 0 )
            {
                nextScale = ( lastScale + delta_scale + 256 ) % 256;
                useDefaultScalingMatrixFlag[0] = ( j == 0 && nextScale == 0 );
            }
        }
        if( 0 )
        {
            scalingList[ j ] = ( nextScale == 0 ) ? lastScale : nextScale;
        }
        lastScale = scalingList[ j ];
    }
}

//Appendix E.1.1 VUI parameters syntax
void write_vui_parameters(h264_stream_t* h, bs_t* b)
{
    sps_t* sps = h->sps;

    bs_write_u1(b, sps->vui.aspect_ratio_info_present_flag);
    if( sps->vui.aspect_ratio_info_present_flag )
    {
        bs_write_u8(b, sps->vui.aspect_ratio_idc);
        if( sps->vui.aspect_ratio_idc == SAR_Extended )
        {
            bs_write_u(b, 16, sps->vui.sar_width);
            bs_write_u(b, 16, sps->vui.sar_height);
        }
    }
    bs_write_u1(b, sps->vui.overscan_info_present_flag);
    if( sps->vui.overscan_info_present_flag )
    {
        bs_write_u1(b, sps->vui.overscan_appropriate_flag);
    }
    bs_write_u1(b, sps->vui.video_signal_type_present_flag);
    if( sps->vui.video_signal_type_present_flag )
    {
        bs_write_u(b, 3, sps->vui.video_format);
        bs_write_u1(b, sps->vui.video_full_range_flag);
        bs_write_u1(b, sps->vui.colour_description_present_flag);
        if( sps->vui.colour_description_present_flag )
        {
            bs_write_u8(b, sps->vui.colour_primaries);
            bs_write_u8(b, sps->vui.transfer_characteristics);
            bs_write_u8(b, sps->vui.matrix_coefficients);
        }
    }
    bs_write_u1(b, sps->vui.chroma_loc_info_present_flag);
    if( sps->vui.chroma_loc_info_present_flag )
    {
        bs_write_ue(b, sps->vui.chroma_sample_loc_type_top_field);
        bs_write_ue(b, sps->vui.chroma_sample_loc_type_bottom_field);
    }
    bs_write_u1(b, sps->vui.timing_info_present_flag);
    if( sps->vui.timing_info_present_flag )
    {
        bs_write_u(b, 32, sps->vui.num_units_in_tick);
        bs_write_u(b, 32, sps->vui.time_scale);
        bs_write_u1(b, sps->vui.fixed_frame_rate_flag);
    }
    bs_write_u1(b, sps->vui.nal_hrd_parameters_present_flag);
    if( sps->vui.nal_hrd_parameters_present_flag )
    {
        write_hrd_parameters(h, b);
    }
    bs_write_u1(b, sps->vui.vcl_hrd_parameters_present_flag);
    if( sps->vui.vcl_hrd_parameters_present_flag )
    {
        write_hrd_parameters(h, b);
    }
    if( sps->vui.nal_hrd_parameters_present_flag || sps->vui.vcl_hrd_parameters_present_flag )
    {
        bs_write_u1(b, sps->vui.low_delay_hrd_flag);
    }
    bs_write_u1(b, sps->vui.pic_struct_present_flag);
    bs_write_u1(b, sps->vui.bitstream_restriction_flag);
    if( sps->vui.bitstream_restriction_flag )
    {
        bs_write_u1(b, sps->vui.motion_vectors_over_pic_boundaries_flag);
        bs_write_ue(b, sps->vui.max_bytes_per_pic_denom);
        bs_write_ue(b, sps->vui.max_bits_per_mb_denom);
        bs_write_ue(b, sps->vui.log2_max_mv_length_horizontal);
        bs_write_ue(b, sps->vui.log2_max_mv_length_vertical);
        bs_write_ue(b, sps->vui.num_reorder_frames);
        bs_write_ue(b, sps->vui.max_dec_frame_buffering);
    }
}


//Appendix E.1.2 HRD parameters syntax
void write_hrd_parameters(h264_stream_t* h, bs_t* b)
{
    sps_t* sps = h->sps;

    bs_write_ue(b, sps->hrd.cpb_cnt_minus1);
    bs_write_u(b, 4, sps->hrd.bit_rate_scale);
    bs_write_u(b, 4, sps->hrd.cpb_size_scale);
    for( int SchedSelIdx = 0; SchedSelIdx <= sps->hrd.cpb_cnt_minus1; SchedSelIdx++ )
    {
        bs_write_ue(b, sps->hrd.bit_rate_value_minus1[ SchedSelIdx ]);
        bs_write_ue(b, sps->hrd.cpb_size_value_minus1[ SchedSelIdx ]);
        bs_write_u1(b, sps->hrd.cbr_flag[ SchedSelIdx ]);
    }
    bs_write_u(b, 5, sps->hrd.initial_cpb_removal_delay_length_minus1);
    bs_write_u(b, 5, sps->hrd.cpb_removal_delay_length_minus1);
    bs_write_u(b, 5, sps->hrd.dpb_output_delay_length_minus1);
    bs_write_u(b, 5, sps->hrd.time_offset_length);
}


/*
UNIMPLEMENTED
//7.3.2.1.2 Sequence parameter set extension RBSP syntax
int write_seq_parameter_set_extension_rbsp(bs_t* b, sps_ext_t* sps_ext) {
    bs_write_ue(b, seq_parameter_set_id);
    bs_write_ue(b, aux_format_idc);
    if( aux_format_idc != 0 ) {
        bs_write_ue(b, bit_depth_aux_minus8);
        bs_write_u1(b, alpha_incr_flag);
        alpha_opaque_value = bs_write_u(v);
        alpha_transparent_value = bs_write_u(v);
    }
    bs_write_u1(b, additional_extension_flag);
    write_rbsp_trailing_bits();
}
*/

//7.3.2.2 Picture parameter set RBSP syntax
void write_pic_parameter_set_rbsp(h264_stream_t* h, bs_t* b)
{
    pps_t* pps = h->pps;
    if( 0 )
    {
        memset(pps, 0, sizeof(pps_t));
    }

    bs_write_ue(b, pps->pic_parameter_set_id);
    bs_write_ue(b, pps->seq_parameter_set_id);
    bs_write_u1(b, pps->entropy_coding_mode_flag);
    bs_write_u1(b, pps->pic_order_present_flag);
    bs_write_ue(b, pps->num_slice_groups_minus1);

    if( pps->num_slice_groups_minus1 > 0 )
    {
        bs_write_ue(b, pps->slice_group_map_type);
        if( pps->slice_group_map_type == 0 )
        {
            for( int i_group = 0; i_group <= pps->num_slice_groups_minus1; i_group++ )
            {
                bs_write_ue(b, pps->run_length_minus1[ i_group ]);
            }
        }
        else if( pps->slice_group_map_type == 2 )
        {
            for( int i_group = 0; i_group < pps->num_slice_groups_minus1; i_group++ )
            {
                bs_write_ue(b, pps->top_left[ i_group ]);
                bs_write_ue(b, pps->bottom_right[ i_group ]);
            }
        }
        else if( pps->slice_group_map_type == 3 ||
                 pps->slice_group_map_type == 4 ||
                 pps->slice_group_map_type == 5 )
        {
            bs_write_u1(b, pps->slice_group_change_direction_flag);
            bs_write_ue(b, pps->slice_group_change_rate_minus1);
        }
        else if( pps->slice_group_map_type == 6 )
        {
            bs_write_ue(b, pps->pic_size_in_map_units_minus1);
            for( int i = 0; i <= pps->pic_size_in_map_units_minus1; i++ )
            {
                int v = intlog2( pps->num_slice_groups_minus1 + 1 );
                bs_write_u(b, v, pps->slice_group_id[ i ]);
            }
        }
    }
    bs_write_ue(b, pps->num_ref_idx_l0_active_minus1);
    bs_write_ue(b, pps->num_ref_idx_l1_active_minus1);
    bs_write_u1(b, pps->weighted_pred_flag);
    bs_write_u(b, 2, pps->weighted_bipred_idc);
    bs_write_se(b, pps->pic_init_qp_minus26);
    bs_write_se(b, pps->pic_init_qs_minus26);
    bs_write_se(b, pps->chroma_qp_index_offset);
    bs_write_u1(b, pps->deblocking_filter_control_present_flag);
    bs_write_u1(b, pps->constrained_intra_pred_flag);
    bs_write_u1(b, pps->redundant_pic_cnt_present_flag);

    int have_more_data = 0;
    if( 0 ) { have_more_data = more_rbsp_data(h, b); }
    if( 1 )
    {
        have_more_data = pps->transform_8x8_mode_flag | pps->pic_scaling_matrix_present_flag | pps->second_chroma_qp_index_offset != 0;
    }

    if( have_more_data )
    {
        bs_write_u1(b, pps->transform_8x8_mode_flag);
        bs_write_u1(b, pps->pic_scaling_matrix_present_flag);
        if( pps->pic_scaling_matrix_present_flag )
        {
            for( int i = 0; i < 6 + 2* pps->transform_8x8_mode_flag; i++ )
            {
                bs_write_u1(b, pps->pic_scaling_list_present_flag[ i ]);
                if( pps->pic_scaling_list_present_flag[ i ] )
                {
                    if( i < 6 )
                    {
                        write_scaling_list( b, pps->ScalingList4x4[ i ], 16,
                                                 &( pps->UseDefaultScalingMatrix4x4Flag[ i ] ) );
                    }
                    else
                    {
                        write_scaling_list( b, pps->ScalingList8x8[ i - 6 ], 64,
                                                 &( pps->UseDefaultScalingMatrix8x8Flag[ i - 6 ] ) );
                    }
                }
            }
        }
        bs_write_se(b, pps->second_chroma_qp_index_offset);
    }
    write_rbsp_trailing_bits(h, b);

    if( 0 )
    {
        memcpy(h->pps, h->pps_table[pps->pic_parameter_set_id], sizeof(pps_t));
    }
}

#ifdef HAVE_SEI
//7.3.2.3 Supplemental enhancement information RBSP syntax
void write_sei_rbsp(h264_stream_t* h, bs_t* b)
{
    if( 0 )
    {
    for( int i = 0; i < h->num_seis; i++ )
    {
        sei_free(h->seis[i]);
    }
    
    h->num_seis = 0;
    do {
        h->num_seis++;
        h->seis = (sei_t**)realloc(h->seis, h->num_seis * sizeof(sei_t*));
        h->seis[h->num_seis - 1] = sei_new();
        h->sei = h->seis[h->num_seis - 1];
        write_sei_message(h, b);
    } while( more_rbsp_data(h, b) );

    }

    if( 1 )
    {
    for (int i = 0; i < h->num_seis; i++)
    {
        h->sei = h->seis[i];
        write_sei_message(h, b);
    }
    h->sei = NULL;
    }

    write_rbsp_trailing_bits(h, b);
}

//7.3.2.3.1 Supplemental enhancement information message syntax
void write_sei_message(h264_stream_t* h, bs_t* b)
{
    if( 1 )
    {
        _write_ff_coded_number(b, h->sei->payloadType);
        _write_ff_coded_number(b, h->sei->payloadSize);
    }
    if( 0 )
    {
        h->sei->payloadType = _read_ff_coded_number(b);
        h->sei->payloadSize = _read_ff_coded_number(b);
    }
    write_sei_payload( h, b, h->sei->payloadType, h->sei->payloadSize );
}
#endif

//7.3.2.4 Access unit delimiter RBSP syntax
void write_access_unit_delimiter_rbsp(h264_stream_t* h, bs_t* b)
{
    bs_write_u(b, 3, h->aud->primary_pic_type);
    write_rbsp_trailing_bits(h, b);
}

//7.3.2.5 End of sequence RBSP syntax
void write_end_of_seq_rbsp(h264_stream_t* h, bs_t* b)
{
}

//7.3.2.6 End of stream RBSP syntax
void write_end_of_stream_rbsp(h264_stream_t* h, bs_t* b)
{
}

//7.3.2.7 Filler data RBSP syntax
void write_filler_data_rbsp(h264_stream_t* h, bs_t* b)
{
    while( bs_next_bits(b, 8) == 0xFF )
    {
        /* ff_byte */ bs_write_u(b, 8, 0xFF);
    }
    write_rbsp_trailing_bits(h, b);
}

//7.3.2.8 Slice layer without partitioning RBSP syntax
void write_slice_layer_rbsp(h264_stream_t* h,  bs_t* b)
{
    write_slice_header(h, b);
    slice_data_rbsp_t* slice_data = h->slice_data;

    if ( slice_data != NULL )
    {
        if ( slice_data->rbsp_buf != NULL ) free( slice_data->rbsp_buf ); 
        uint8_t *sptr = b->p + (!!b->bits_left); // CABAC-specific: skip alignment bits, if there are any
        slice_data->rbsp_size = b->end - sptr;
        
        slice_data->rbsp_buf = (uint8_t*)malloc(slice_data->rbsp_size);
        memcpy( slice_data->rbsp_buf, sptr, slice_data->rbsp_size );
        // ugly hack: since next NALU starts at byte border, we are going to be padded by trailing_bits;
        return;
    }

    // FIXME should read or skip data
    //slice_data( ); /* all categories of slice_data( ) syntax */
    write_rbsp_slice_trailing_bits(h, b);
}

/*
// UNIMPLEMENTED
//7.3.2.9.1 Slice data partition A RBSP syntax
slice_data_partition_a_layer_rbsp( ) {
    write_slice_header( );             // only category 2
    slice_id = bs_write_ue(b)
    write_slice_data( );               // only category 2
    write_rbsp_slice_trailing_bits( ); // only category 2
}

//7.3.2.9.2 Slice data partition B RBSP syntax
slice_data_partition_b_layer_rbsp( ) {
    bs_write_ue(b, slice_id);    // only category 3
    if( redundant_pic_cnt_present_flag )
        bs_write_ue(b, redundant_pic_cnt);
    write_slice_data( );               // only category 3
    write_rbsp_slice_trailing_bits( ); // only category 3
}

//7.3.2.9.3 Slice data partition C RBSP syntax
slice_data_partition_c_layer_rbsp( ) {
    bs_write_ue(b, slice_id);    // only category 4
    if( redundant_pic_cnt_present_flag )
        bs_write_ue(b, redundant_pic_cnt);
    write_slice_data( );               // only category 4
    rbsp_slice_trailing_bits( ); // only category 4
}
*/

//7.3.2.10 RBSP slice trailing bits syntax
void write_rbsp_slice_trailing_bits(h264_stream_t* h, bs_t* b)
{
    write_rbsp_trailing_bits(h, b);
    if( h->pps->entropy_coding_mode_flag )
    {
        while( more_rbsp_trailing_data(h, b) )
        {
            /* cabac_zero_word */ bs_write_u(b, 16, 0x0000);
        }
    }
}

//7.3.2.11 RBSP trailing bits syntax
void write_rbsp_trailing_bits(h264_stream_t* h, bs_t* b)
{
    /* rbsp_stop_one_bit */ bs_write_u(b, 1, 1);

    while( !bs_byte_aligned(b) )
    {
        /* rbsp_alignment_zero_bit */ bs_write_u(b, 1, 0);
    }
}

//7.3.3 Slice header syntax
void write_slice_header(h264_stream_t* h, bs_t* b)
{
    slice_header_t* sh = h->sh;
    if( 0 )
    {
        memset(sh, 0, sizeof(slice_header_t));
    }

    nal_t* nal = h->nal;

    bs_write_ue(b, sh->first_mb_in_slice);
    bs_write_ue(b, sh->slice_type);
    bs_write_ue(b, sh->pic_parameter_set_id);

    // TODO check existence, otherwise fail
    pps_t* pps = h->pps;
    sps_t* sps = h->sps;
    memcpy(h->pps_table[sh->pic_parameter_set_id], h->pps, sizeof(pps_t));
    memcpy(h->sps_table[pps->seq_parameter_set_id], h->sps, sizeof(sps_t));

    bs_write_u(b, sps->log2_max_frame_num_minus4 + 4 , sh->frame_num); // was u(v)
    if( !sps->frame_mbs_only_flag )
    {
        bs_write_u1(b, sh->field_pic_flag);
        if( sh->field_pic_flag )
        {
            bs_write_u1(b, sh->bottom_field_flag);
        }
    }
    if( nal->nal_unit_type == 5 )
    {
        bs_write_ue(b, sh->idr_pic_id);
    }
    if( sps->pic_order_cnt_type == 0 )
    {
        bs_write_u(b, sps->log2_max_pic_order_cnt_lsb_minus4 + 4 , sh->pic_order_cnt_lsb); // was u(v)
        if( pps->pic_order_present_flag && !sh->field_pic_flag )
        {
            bs_write_se(b, sh->delta_pic_order_cnt_bottom);
        }
    }
    if( sps->pic_order_cnt_type == 1 && !sps->delta_pic_order_always_zero_flag )
    {
        bs_write_se(b, sh->delta_pic_order_cnt[ 0 ]);
        if( pps->pic_order_present_flag && !sh->field_pic_flag )
        {
            bs_write_se(b, sh->delta_pic_order_cnt[ 1 ]);
        }
    }
    if( pps->redundant_pic_cnt_present_flag )
    {
        bs_write_ue(b, sh->redundant_pic_cnt);
    }
    if( is_slice_type( sh->slice_type, SH_SLICE_TYPE_B ) )
    {
        bs_write_u1(b, sh->direct_spatial_mv_pred_flag);
    }
    if( is_slice_type( sh->slice_type, SH_SLICE_TYPE_P ) || is_slice_type( sh->slice_type, SH_SLICE_TYPE_SP ) || is_slice_type( sh->slice_type, SH_SLICE_TYPE_B ) )
    {
        bs_write_u1(b, sh->num_ref_idx_active_override_flag);
        if( sh->num_ref_idx_active_override_flag )
        {
            bs_write_ue(b, sh->num_ref_idx_l0_active_minus1); // FIXME does this modify the pps?
            if( is_slice_type( sh->slice_type, SH_SLICE_TYPE_B ) )
            {
                bs_write_ue(b, sh->num_ref_idx_l1_active_minus1);
            }
        }
    }
    write_ref_pic_list_reordering(h, b);
    if( ( pps->weighted_pred_flag && ( is_slice_type( sh->slice_type, SH_SLICE_TYPE_P ) || is_slice_type( sh->slice_type, SH_SLICE_TYPE_SP ) ) ) ||
        ( pps->weighted_bipred_idc == 1 && is_slice_type( sh->slice_type, SH_SLICE_TYPE_B ) ) )
    {
        write_pred_weight_table(h, b);
    }
    if( nal->nal_ref_idc != 0 )
    {
        write_dec_ref_pic_marking(h, b);
    }
    if( pps->entropy_coding_mode_flag && ! is_slice_type( sh->slice_type, SH_SLICE_TYPE_I ) && ! is_slice_type( sh->slice_type, SH_SLICE_TYPE_SI ) )
    {
        bs_write_ue(b, sh->cabac_init_idc);
    }
    bs_write_se(b, sh->slice_qp_delta);
    if( is_slice_type( sh->slice_type, SH_SLICE_TYPE_SP ) || is_slice_type( sh->slice_type, SH_SLICE_TYPE_SI ) )
    {
        if( is_slice_type( sh->slice_type, SH_SLICE_TYPE_SP ) )
        {
            bs_write_u1(b, sh->sp_for_switch_flag);
        }
        bs_write_se(b, sh->slice_qs_delta);
    }
    if( pps->deblocking_filter_control_present_flag )
    {
        bs_write_ue(b, sh->disable_deblocking_filter_idc);
        if( sh->disable_deblocking_filter_idc != 1 )
        {
            bs_write_se(b, sh->slice_alpha_c0_offset_div2);
            bs_write_se(b, sh->slice_beta_offset_div2);
        }
    }
    if( pps->num_slice_groups_minus1 > 0 &&
        pps->slice_group_map_type >= 3 && pps->slice_group_map_type <= 5)
    {
        int v = intlog2( pps->pic_size_in_map_units_minus1 +  pps->slice_group_change_rate_minus1 + 1 );
        bs_write_u(b, v, sh->slice_group_change_cycle); // FIXME add 2?
    }
}

//7.3.3.1 Reference picture list reordering syntax
void write_ref_pic_list_reordering(h264_stream_t* h, bs_t* b)
{
    slice_header_t* sh = h->sh;
    // FIXME should be an array

    if( ! is_slice_type( sh->slice_type, SH_SLICE_TYPE_I ) && ! is_slice_type( sh->slice_type, SH_SLICE_TYPE_SI ) )
    {
        bs_write_u1(b, sh->rplr.ref_pic_list_reordering_flag_l0);
        if( sh->rplr.ref_pic_list_reordering_flag_l0 )
        {
            int n = -1;
            do
            {
                n++;
                bs_write_ue(b, sh->rplr.reorder_l0.reordering_of_pic_nums_idc[ n ]);
                if( sh->rplr.reorder_l0.reordering_of_pic_nums_idc[ n ] == 0 ||
                    sh->rplr.reorder_l0.reordering_of_pic_nums_idc[ n ] == 1 )
                {
                    bs_write_ue(b, sh->rplr.reorder_l0.abs_diff_pic_num_minus1[ n ]);
                }
                else if( sh->rplr.reorder_l0.reordering_of_pic_nums_idc[ n ] == 2 )
                {
                    bs_write_ue(b, sh->rplr.reorder_l0.long_term_pic_num[ n ]);
                }
            } while( sh->rplr.reorder_l0.reordering_of_pic_nums_idc[ n ] != 3 && ! bs_eof(b) );
        }
    }
    if( is_slice_type( sh->slice_type, SH_SLICE_TYPE_B ) )
    {
        bs_write_u1(b, sh->rplr.ref_pic_list_reordering_flag_l1);
        if( sh->rplr.ref_pic_list_reordering_flag_l1 )
        {
            int n = -1;
            do
            {
                n++;
                bs_write_ue(b, sh->rplr.reorder_l1.reordering_of_pic_nums_idc[ n ]);
                if( sh->rplr.reorder_l1.reordering_of_pic_nums_idc[ n ] == 0 ||
                    sh->rplr.reorder_l1.reordering_of_pic_nums_idc[ n ] == 1 )
                {
                    bs_write_ue(b, sh->rplr.reorder_l1.abs_diff_pic_num_minus1[ n ]);
                }
                else if( sh->rplr.reorder_l1.reordering_of_pic_nums_idc[ n ] == 2 )
                {
                    bs_write_ue(b, sh->rplr.reorder_l1.long_term_pic_num[ n ]);
                }
            } while( sh->rplr.reorder_l1.reordering_of_pic_nums_idc[ n ] != 3 && ! bs_eof(b) );
        }
    }
}

//7.3.3.2 Prediction weight table syntax
void write_pred_weight_table(h264_stream_t* h, bs_t* b)
{
    slice_header_t* sh = h->sh;
    sps_t* sps = h->sps;
    pps_t* pps = h->pps;

    int i, j;

    bs_write_ue(b, sh->pwt.luma_log2_weight_denom);
    if( sps->chroma_format_idc != 0 )
    {
        bs_write_ue(b, sh->pwt.chroma_log2_weight_denom);
    }
    for( i = 0; i <= pps->num_ref_idx_l0_active_minus1; i++ )
    {
        bs_write_u1(b, sh->pwt.luma_weight_l0_flag[i]);
        if( sh->pwt.luma_weight_l0_flag[i] )
        {
            bs_write_se(b, sh->pwt.luma_weight_l0[ i ]);
            bs_write_se(b, sh->pwt.luma_offset_l0[ i ]);
        }
        if ( sps->chroma_format_idc != 0 )
        {
            bs_write_u1(b, sh->pwt.chroma_weight_l0_flag[i]);
            if( sh->pwt.chroma_weight_l0_flag[i] )
            {
                for( j =0; j < 2; j++ )
                {
                    bs_write_se(b, sh->pwt.chroma_weight_l0[ i ][ j ]);
                    bs_write_se(b, sh->pwt.chroma_offset_l0[ i ][ j ]);
                }
            }
        }
    }
    if( is_slice_type( sh->slice_type, SH_SLICE_TYPE_B ) )
    {
        for( i = 0; i <= pps->num_ref_idx_l1_active_minus1; i++ )
        {
            bs_write_u1(b, sh->pwt.luma_weight_l1_flag[i]);
            if( sh->pwt.luma_weight_l1_flag[i] )
            {
                bs_write_se(b, sh->pwt.luma_weight_l1[ i ]);
                bs_write_se(b, sh->pwt.luma_offset_l1[ i ]);
            }
            if( sps->chroma_format_idc != 0 )
            {
                bs_write_u1(b, sh->pwt.chroma_weight_l1_flag[i]);
                if( sh->pwt.chroma_weight_l1_flag[i] )
                {
                    for( j = 0; j < 2; j++ )
                    {
                        bs_write_se(b, sh->pwt.chroma_weight_l1[ i ][ j ]);
                        bs_write_se(b, sh->pwt.chroma_offset_l1[ i ][ j ]);
                    }
                }
            }
        }
    }
}

//7.3.3.3 Decoded reference picture marking syntax
void write_dec_ref_pic_marking(h264_stream_t* h, bs_t* b)
{
    slice_header_t* sh = h->sh;
    // FIXME should be an array

    if( h->nal->nal_unit_type == 5 )
    {
        bs_write_u1(b, sh->drpm.no_output_of_prior_pics_flag);
        bs_write_u1(b, sh->drpm.long_term_reference_flag);
    }
    else
    {
        bs_write_u1(b, sh->drpm.adaptive_ref_pic_marking_mode_flag);
        if( sh->drpm.adaptive_ref_pic_marking_mode_flag )
        {
            int n = -1;
            do
            {
                n++;
                bs_write_ue(b, sh->drpm.memory_management_control_operation[ n ]);
                if( sh->drpm.memory_management_control_operation[ n ] == 1 ||
                    sh->drpm.memory_management_control_operation[ n ] == 3 )
                {
                    bs_write_ue(b, sh->drpm.difference_of_pic_nums_minus1[ n ]);
                }
                if(sh->drpm.memory_management_control_operation[ n ] == 2 )
                {
                    bs_write_ue(b, sh->drpm.long_term_pic_num[ n ]);
                }
                if( sh->drpm.memory_management_control_operation[ n ] == 3 ||
                    sh->drpm.memory_management_control_operation[ n ] == 6 )
                {
                    bs_write_ue(b, sh->drpm.long_term_frame_idx[ n ]);
                }
                if( sh->drpm.memory_management_control_operation[ n ] == 4 )
                {
                    bs_write_ue(b, sh->drpm.max_long_term_frame_idx_plus1[ n ]);
                }
            } while( sh->drpm.memory_management_control_operation[ n ] != 0 && ! bs_eof(b) );
        }
    }
}


void read_debug_seq_parameter_set_rbsp(h264_stream_t* h, bs_t* b);
void read_debug_scaling_list(bs_t* b, int* scalingList, int sizeOfScalingList, int* useDefaultScalingMatrixFlag );
void read_debug_vui_parameters(h264_stream_t* h, bs_t* b);
void read_debug_hrd_parameters(h264_stream_t* h, bs_t* b);
void read_debug_pic_parameter_set_rbsp(h264_stream_t* h, bs_t* b);
void read_debug_sei_rbsp(h264_stream_t* h, bs_t* b);
void read_debug_sei_message(h264_stream_t* h, bs_t* b);
void read_debug_access_unit_delimiter_rbsp(h264_stream_t* h, bs_t* b);
void read_debug_end_of_seq_rbsp(h264_stream_t* h, bs_t* b);
void read_debug_end_of_stream_rbsp(h264_stream_t* h, bs_t* b);
void read_debug_filler_data_rbsp(h264_stream_t* h, bs_t* b);
void read_debug_slice_layer_rbsp(h264_stream_t* h,  bs_t* b);
void read_debug_rbsp_slice_trailing_bits(h264_stream_t* h, bs_t* b);
void read_debug_rbsp_trailing_bits(h264_stream_t* h, bs_t* b);
void read_debug_slice_header(h264_stream_t* h, bs_t* b);
void read_debug_ref_pic_list_reordering(h264_stream_t* h, bs_t* b);
void read_debug_pred_weight_table(h264_stream_t* h, bs_t* b);
void read_debug_dec_ref_pic_marking(h264_stream_t* h, bs_t* b);



//7.3.1 NAL unit syntax
int read_debug_nal_unit(h264_stream_t* h, uint8_t* buf, int size)
{
    nal_t* nal = h->nal;

    int nal_size = size;
    int rbsp_size = size;
    uint8_t* rbsp_buf = (uint8_t*)calloc(1, rbsp_size);

    if( 1 )
    {
    int rc = nal_to_rbsp(buf, &nal_size, rbsp_buf, &rbsp_size);

    if (rc < 0) { free(rbsp_buf); return -1; } // handle conversion error
    }

    if( 0 )
    {
    rbsp_size = size*3/4; // NOTE this may have to be slightly smaller (3/4 smaller, worst case) in order to be guaranteed to fit
    }

    bs_t* b = bs_new(rbsp_buf, rbsp_size);
    printf("%d.%d: ", b->p - b->start, b->bits_left); int forbidden_zero_bit = bs_read_u(b, 1); printf("forbidden_zero_bit: %d \n", forbidden_zero_bit); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); nal->nal_ref_idc = bs_read_u(b, 2); printf("nal->nal_ref_idc: %d \n", nal->nal_ref_idc); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); nal->nal_unit_type = bs_read_u(b, 5); printf("nal->nal_unit_type: %d \n", nal->nal_unit_type); 

    switch ( nal->nal_unit_type )
    {
        case NAL_UNIT_TYPE_CODED_SLICE_IDR:
        case NAL_UNIT_TYPE_CODED_SLICE_NON_IDR:  
        case NAL_UNIT_TYPE_CODED_SLICE_AUX:
            read_debug_slice_layer_rbsp(h, b);
            break;

#ifdef HAVE_SEI
        case NAL_UNIT_TYPE_SEI:
            read_debug_sei_rbsp(h, b);
            break;
#endif

        case NAL_UNIT_TYPE_SPS: 
            read_debug_seq_parameter_set_rbsp(h, b); 
            break;

        case NAL_UNIT_TYPE_PPS:   
            read_debug_pic_parameter_set_rbsp(h, b);
            break;

        case NAL_UNIT_TYPE_AUD:     
            read_debug_access_unit_delimiter_rbsp(h, b); 
            break;

        case NAL_UNIT_TYPE_END_OF_SEQUENCE: 
            read_debug_end_of_seq_rbsp(h, b);
            break;

        case NAL_UNIT_TYPE_END_OF_STREAM: 
            read_debug_end_of_stream_rbsp(h, b);
            break;

        case NAL_UNIT_TYPE_FILLER:
        case NAL_UNIT_TYPE_SPS_EXT:
        case NAL_UNIT_TYPE_UNSPECIFIED:
        case NAL_UNIT_TYPE_CODED_SLICE_DATA_PARTITION_A:  
        case NAL_UNIT_TYPE_CODED_SLICE_DATA_PARTITION_B: 
        case NAL_UNIT_TYPE_CODED_SLICE_DATA_PARTITION_C:
        default:
            return -1;
    }

    if (bs_overrun(b)) { bs_free(b); free(rbsp_buf); return -1; }

    if( 0 )
    {
    // now get the actual size used
    rbsp_size = bs_pos(b);

    int rc = rbsp_to_nal(rbsp_buf, &rbsp_size, buf, &nal_size);
    if (rc < 0) { bs_free(b); free(rbsp_buf); return -1; }
    }

    bs_free(b);
    free(rbsp_buf);

    return nal_size;
}



//7.3.2.1 Sequence parameter set RBSP syntax
void read_debug_seq_parameter_set_rbsp(h264_stream_t* h, bs_t* b)
{
    int i;

    sps_t* sps = h->sps;
    if( 1 )
    {
        memset(sps, 0, sizeof(sps_t));
        sps->chroma_format_idc = 1; 
    }
 
    printf("%d.%d: ", b->p - b->start, b->bits_left); sps->profile_idc = bs_read_u8(b); printf("sps->profile_idc: %d \n", sps->profile_idc); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); sps->constraint_set0_flag = bs_read_u1(b); printf("sps->constraint_set0_flag: %d \n", sps->constraint_set0_flag); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); sps->constraint_set1_flag = bs_read_u1(b); printf("sps->constraint_set1_flag: %d \n", sps->constraint_set1_flag); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); sps->constraint_set2_flag = bs_read_u1(b); printf("sps->constraint_set2_flag: %d \n", sps->constraint_set2_flag); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); sps->constraint_set3_flag = bs_read_u1(b); printf("sps->constraint_set3_flag: %d \n", sps->constraint_set3_flag); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); sps->constraint_set4_flag = bs_read_u1(b); printf("sps->constraint_set4_flag: %d \n", sps->constraint_set4_flag); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); sps->constraint_set5_flag = bs_read_u1(b); printf("sps->constraint_set5_flag: %d \n", sps->constraint_set5_flag); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); int reserved_zero_2bits = bs_read_u(b, 2); printf("reserved_zero_2bits: %d \n", reserved_zero_2bits); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); sps->level_idc = bs_read_u8(b); printf("sps->level_idc: %d \n", sps->level_idc); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); sps->seq_parameter_set_id = bs_read_ue(b); printf("sps->seq_parameter_set_id: %d \n", sps->seq_parameter_set_id); 

    if( sps->profile_idc == 100 || sps->profile_idc == 110 ||
        sps->profile_idc == 122 || sps->profile_idc == 144 )
    {
        printf("%d.%d: ", b->p - b->start, b->bits_left); sps->chroma_format_idc = bs_read_ue(b); printf("sps->chroma_format_idc: %d \n", sps->chroma_format_idc); 
        if( sps->chroma_format_idc == 3 )
        {
            printf("%d.%d: ", b->p - b->start, b->bits_left); sps->residual_colour_transform_flag = bs_read_u1(b); printf("sps->residual_colour_transform_flag: %d \n", sps->residual_colour_transform_flag); 
        }
        printf("%d.%d: ", b->p - b->start, b->bits_left); sps->bit_depth_luma_minus8 = bs_read_ue(b); printf("sps->bit_depth_luma_minus8: %d \n", sps->bit_depth_luma_minus8); 
        printf("%d.%d: ", b->p - b->start, b->bits_left); sps->bit_depth_chroma_minus8 = bs_read_ue(b); printf("sps->bit_depth_chroma_minus8: %d \n", sps->bit_depth_chroma_minus8); 
        printf("%d.%d: ", b->p - b->start, b->bits_left); sps->qpprime_y_zero_transform_bypass_flag = bs_read_u1(b); printf("sps->qpprime_y_zero_transform_bypass_flag: %d \n", sps->qpprime_y_zero_transform_bypass_flag); 
        printf("%d.%d: ", b->p - b->start, b->bits_left); sps->seq_scaling_matrix_present_flag = bs_read_u1(b); printf("sps->seq_scaling_matrix_present_flag: %d \n", sps->seq_scaling_matrix_present_flag); 
        if( sps->seq_scaling_matrix_present_flag )
        {
            for( i = 0; i < 8; i++ )
            {
                printf("%d.%d: ", b->p - b->start, b->bits_left); sps->seq_scaling_list_present_flag[ i ] = bs_read_u1(b); printf("sps->seq_scaling_list_present_flag[ i ]: %d \n", sps->seq_scaling_list_present_flag[ i ]); 
                if( sps->seq_scaling_list_present_flag[ i ] )
                {
                    if( i < 6 )
                    {
                        read_debug_scaling_list( b, sps->ScalingList4x4[ i ], 16,
                                                 &( sps->UseDefaultScalingMatrix4x4Flag[ i ] ) );
                    }
                    else
                    {
                        read_debug_scaling_list( b, sps->ScalingList8x8[ i - 6 ], 64,
                                                 &( sps->UseDefaultScalingMatrix8x8Flag[ i - 6 ] ) );
                    }
                }
            }
        }
    }
    printf("%d.%d: ", b->p - b->start, b->bits_left); sps->log2_max_frame_num_minus4 = bs_read_ue(b); printf("sps->log2_max_frame_num_minus4: %d \n", sps->log2_max_frame_num_minus4); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); sps->pic_order_cnt_type = bs_read_ue(b); printf("sps->pic_order_cnt_type: %d \n", sps->pic_order_cnt_type); 
    if( sps->pic_order_cnt_type == 0 )
    {
        printf("%d.%d: ", b->p - b->start, b->bits_left); sps->log2_max_pic_order_cnt_lsb_minus4 = bs_read_ue(b); printf("sps->log2_max_pic_order_cnt_lsb_minus4: %d \n", sps->log2_max_pic_order_cnt_lsb_minus4); 
    }
    else if( sps->pic_order_cnt_type == 1 )
    {
        printf("%d.%d: ", b->p - b->start, b->bits_left); sps->delta_pic_order_always_zero_flag = bs_read_u1(b); printf("sps->delta_pic_order_always_zero_flag: %d \n", sps->delta_pic_order_always_zero_flag); 
        printf("%d.%d: ", b->p - b->start, b->bits_left); sps->offset_for_non_ref_pic = bs_read_se(b); printf("sps->offset_for_non_ref_pic: %d \n", sps->offset_for_non_ref_pic); 
        printf("%d.%d: ", b->p - b->start, b->bits_left); sps->offset_for_top_to_bottom_field = bs_read_se(b); printf("sps->offset_for_top_to_bottom_field: %d \n", sps->offset_for_top_to_bottom_field); 
        printf("%d.%d: ", b->p - b->start, b->bits_left); sps->num_ref_frames_in_pic_order_cnt_cycle = bs_read_ue(b); printf("sps->num_ref_frames_in_pic_order_cnt_cycle: %d \n", sps->num_ref_frames_in_pic_order_cnt_cycle); 
        for( i = 0; i < sps->num_ref_frames_in_pic_order_cnt_cycle; i++ )
        {
            printf("%d.%d: ", b->p - b->start, b->bits_left); sps->offset_for_ref_frame[ i ] = bs_read_se(b); printf("sps->offset_for_ref_frame[ i ]: %d \n", sps->offset_for_ref_frame[ i ]); 
        }
    }
    printf("%d.%d: ", b->p - b->start, b->bits_left); sps->num_ref_frames = bs_read_ue(b); printf("sps->num_ref_frames: %d \n", sps->num_ref_frames); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); sps->gaps_in_frame_num_value_allowed_flag = bs_read_u1(b); printf("sps->gaps_in_frame_num_value_allowed_flag: %d \n", sps->gaps_in_frame_num_value_allowed_flag); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); sps->pic_width_in_mbs_minus1 = bs_read_ue(b); printf("sps->pic_width_in_mbs_minus1: %d \n", sps->pic_width_in_mbs_minus1); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); sps->pic_height_in_map_units_minus1 = bs_read_ue(b); printf("sps->pic_height_in_map_units_minus1: %d \n", sps->pic_height_in_map_units_minus1); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); sps->frame_mbs_only_flag = bs_read_u1(b); printf("sps->frame_mbs_only_flag: %d \n", sps->frame_mbs_only_flag); 
    if( !sps->frame_mbs_only_flag )
    {
        printf("%d.%d: ", b->p - b->start, b->bits_left); sps->mb_adaptive_frame_field_flag = bs_read_u1(b); printf("sps->mb_adaptive_frame_field_flag: %d \n", sps->mb_adaptive_frame_field_flag); 
    }
    printf("%d.%d: ", b->p - b->start, b->bits_left); sps->direct_8x8_inference_flag = bs_read_u1(b); printf("sps->direct_8x8_inference_flag: %d \n", sps->direct_8x8_inference_flag); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); sps->frame_cropping_flag = bs_read_u1(b); printf("sps->frame_cropping_flag: %d \n", sps->frame_cropping_flag); 
    if( sps->frame_cropping_flag )
    {
        printf("%d.%d: ", b->p - b->start, b->bits_left); sps->frame_crop_left_offset = bs_read_ue(b); printf("sps->frame_crop_left_offset: %d \n", sps->frame_crop_left_offset); 
        printf("%d.%d: ", b->p - b->start, b->bits_left); sps->frame_crop_right_offset = bs_read_ue(b); printf("sps->frame_crop_right_offset: %d \n", sps->frame_crop_right_offset); 
        printf("%d.%d: ", b->p - b->start, b->bits_left); sps->frame_crop_top_offset = bs_read_ue(b); printf("sps->frame_crop_top_offset: %d \n", sps->frame_crop_top_offset); 
        printf("%d.%d: ", b->p - b->start, b->bits_left); sps->frame_crop_bottom_offset = bs_read_ue(b); printf("sps->frame_crop_bottom_offset: %d \n", sps->frame_crop_bottom_offset); 
    }
    printf("%d.%d: ", b->p - b->start, b->bits_left); sps->vui_parameters_present_flag = bs_read_u1(b); printf("sps->vui_parameters_present_flag: %d \n", sps->vui_parameters_present_flag); 
    if( sps->vui_parameters_present_flag )
    {
        read_debug_vui_parameters(h, b);
    }
    read_debug_rbsp_trailing_bits(h, b);

    if( 1 )
    {
        memcpy(h->sps_table[sps->seq_parameter_set_id], h->sps, sizeof(sps_t));
    }
}


//7.3.2.1.1 Scaling list syntax
void read_debug_scaling_list(bs_t* b, int* scalingList, int sizeOfScalingList, int* useDefaultScalingMatrixFlag )
{
    // NOTE need to be able to set useDefaultScalingMatrixFlag when reading, hence passing as pointer
    int lastScale = 8;
    int nextScale = 8;
    int delta_scale;
    for( int j = 0; j < sizeOfScalingList; j++ )
    {
        if( nextScale != 0 )
        {
            if( 0 )
            {
                nextScale = scalingList[ j ];
                if (useDefaultScalingMatrixFlag[0]) { nextScale = 0; }
                delta_scale = (nextScale - lastScale) % 256 ;
            }

            printf("%d.%d: ", b->p - b->start, b->bits_left); delta_scale = bs_read_se(b); printf("delta_scale: %d \n", delta_scale); 

            if( 1 )
            {
                nextScale = ( lastScale + delta_scale + 256 ) % 256;
                useDefaultScalingMatrixFlag[0] = ( j == 0 && nextScale == 0 );
            }
        }
        if( 1 )
        {
            scalingList[ j ] = ( nextScale == 0 ) ? lastScale : nextScale;
        }
        lastScale = scalingList[ j ];
    }
}

//Appendix E.1.1 VUI parameters syntax
void read_debug_vui_parameters(h264_stream_t* h, bs_t* b)
{
    sps_t* sps = h->sps;

    printf("%d.%d: ", b->p - b->start, b->bits_left); sps->vui.aspect_ratio_info_present_flag = bs_read_u1(b); printf("sps->vui.aspect_ratio_info_present_flag: %d \n", sps->vui.aspect_ratio_info_present_flag); 
    if( sps->vui.aspect_ratio_info_present_flag )
    {
        printf("%d.%d: ", b->p - b->start, b->bits_left); sps->vui.aspect_ratio_idc = bs_read_u8(b); printf("sps->vui.aspect_ratio_idc: %d \n", sps->vui.aspect_ratio_idc); 
        if( sps->vui.aspect_ratio_idc == SAR_Extended )
        {
            printf("%d.%d: ", b->p - b->start, b->bits_left); sps->vui.sar_width = bs_read_u(b, 16); printf("sps->vui.sar_width: %d \n", sps->vui.sar_width); 
            printf("%d.%d: ", b->p - b->start, b->bits_left); sps->vui.sar_height = bs_read_u(b, 16); printf("sps->vui.sar_height: %d \n", sps->vui.sar_height); 
        }
    }
    printf("%d.%d: ", b->p - b->start, b->bits_left); sps->vui.overscan_info_present_flag = bs_read_u1(b); printf("sps->vui.overscan_info_present_flag: %d \n", sps->vui.overscan_info_present_flag); 
    if( sps->vui.overscan_info_present_flag )
    {
        printf("%d.%d: ", b->p - b->start, b->bits_left); sps->vui.overscan_appropriate_flag = bs_read_u1(b); printf("sps->vui.overscan_appropriate_flag: %d \n", sps->vui.overscan_appropriate_flag); 
    }
    printf("%d.%d: ", b->p - b->start, b->bits_left); sps->vui.video_signal_type_present_flag = bs_read_u1(b); printf("sps->vui.video_signal_type_present_flag: %d \n", sps->vui.video_signal_type_present_flag); 
    if( sps->vui.video_signal_type_present_flag )
    {
        printf("%d.%d: ", b->p - b->start, b->bits_left); sps->vui.video_format = bs_read_u(b, 3); printf("sps->vui.video_format: %d \n", sps->vui.video_format); 
        printf("%d.%d: ", b->p - b->start, b->bits_left); sps->vui.video_full_range_flag = bs_read_u1(b); printf("sps->vui.video_full_range_flag: %d \n", sps->vui.video_full_range_flag); 
        printf("%d.%d: ", b->p - b->start, b->bits_left); sps->vui.colour_description_present_flag = bs_read_u1(b); printf("sps->vui.colour_description_present_flag: %d \n", sps->vui.colour_description_present_flag); 
        if( sps->vui.colour_description_present_flag )
        {
            printf("%d.%d: ", b->p - b->start, b->bits_left); sps->vui.colour_primaries = bs_read_u8(b); printf("sps->vui.colour_primaries: %d \n", sps->vui.colour_primaries); 
            printf("%d.%d: ", b->p - b->start, b->bits_left); sps->vui.transfer_characteristics = bs_read_u8(b); printf("sps->vui.transfer_characteristics: %d \n", sps->vui.transfer_characteristics); 
            printf("%d.%d: ", b->p - b->start, b->bits_left); sps->vui.matrix_coefficients = bs_read_u8(b); printf("sps->vui.matrix_coefficients: %d \n", sps->vui.matrix_coefficients); 
        }
    }
    printf("%d.%d: ", b->p - b->start, b->bits_left); sps->vui.chroma_loc_info_present_flag = bs_read_u1(b); printf("sps->vui.chroma_loc_info_present_flag: %d \n", sps->vui.chroma_loc_info_present_flag); 
    if( sps->vui.chroma_loc_info_present_flag )
    {
        printf("%d.%d: ", b->p - b->start, b->bits_left); sps->vui.chroma_sample_loc_type_top_field = bs_read_ue(b); printf("sps->vui.chroma_sample_loc_type_top_field: %d \n", sps->vui.chroma_sample_loc_type_top_field); 
        printf("%d.%d: ", b->p - b->start, b->bits_left); sps->vui.chroma_sample_loc_type_bottom_field = bs_read_ue(b); printf("sps->vui.chroma_sample_loc_type_bottom_field: %d \n", sps->vui.chroma_sample_loc_type_bottom_field); 
    }
    printf("%d.%d: ", b->p - b->start, b->bits_left); sps->vui.timing_info_present_flag = bs_read_u1(b); printf("sps->vui.timing_info_present_flag: %d \n", sps->vui.timing_info_present_flag); 
    if( sps->vui.timing_info_present_flag )
    {
        printf("%d.%d: ", b->p - b->start, b->bits_left); sps->vui.num_units_in_tick = bs_read_u(b, 32); printf("sps->vui.num_units_in_tick: %d \n", sps->vui.num_units_in_tick); 
        printf("%d.%d: ", b->p - b->start, b->bits_left); sps->vui.time_scale = bs_read_u(b, 32); printf("sps->vui.time_scale: %d \n", sps->vui.time_scale); 
        printf("%d.%d: ", b->p - b->start, b->bits_left); sps->vui.fixed_frame_rate_flag = bs_read_u1(b); printf("sps->vui.fixed_frame_rate_flag: %d \n", sps->vui.fixed_frame_rate_flag); 
    }
    printf("%d.%d: ", b->p - b->start, b->bits_left); sps->vui.nal_hrd_parameters_present_flag = bs_read_u1(b); printf("sps->vui.nal_hrd_parameters_present_flag: %d \n", sps->vui.nal_hrd_parameters_present_flag); 
    if( sps->vui.nal_hrd_parameters_present_flag )
    {
        read_debug_hrd_parameters(h, b);
    }
    printf("%d.%d: ", b->p - b->start, b->bits_left); sps->vui.vcl_hrd_parameters_present_flag = bs_read_u1(b); printf("sps->vui.vcl_hrd_parameters_present_flag: %d \n", sps->vui.vcl_hrd_parameters_present_flag); 
    if( sps->vui.vcl_hrd_parameters_present_flag )
    {
        read_debug_hrd_parameters(h, b);
    }
    if( sps->vui.nal_hrd_parameters_present_flag || sps->vui.vcl_hrd_parameters_present_flag )
    {
        printf("%d.%d: ", b->p - b->start, b->bits_left); sps->vui.low_delay_hrd_flag = bs_read_u1(b); printf("sps->vui.low_delay_hrd_flag: %d \n", sps->vui.low_delay_hrd_flag); 
    }
    printf("%d.%d: ", b->p - b->start, b->bits_left); sps->vui.pic_struct_present_flag = bs_read_u1(b); printf("sps->vui.pic_struct_present_flag: %d \n", sps->vui.pic_struct_present_flag); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); sps->vui.bitstream_restriction_flag = bs_read_u1(b); printf("sps->vui.bitstream_restriction_flag: %d \n", sps->vui.bitstream_restriction_flag); 
    if( sps->vui.bitstream_restriction_flag )
    {
        printf("%d.%d: ", b->p - b->start, b->bits_left); sps->vui.motion_vectors_over_pic_boundaries_flag = bs_read_u1(b); printf("sps->vui.motion_vectors_over_pic_boundaries_flag: %d \n", sps->vui.motion_vectors_over_pic_boundaries_flag); 
        printf("%d.%d: ", b->p - b->start, b->bits_left); sps->vui.max_bytes_per_pic_denom = bs_read_ue(b); printf("sps->vui.max_bytes_per_pic_denom: %d \n", sps->vui.max_bytes_per_pic_denom); 
        printf("%d.%d: ", b->p - b->start, b->bits_left); sps->vui.max_bits_per_mb_denom = bs_read_ue(b); printf("sps->vui.max_bits_per_mb_denom: %d \n", sps->vui.max_bits_per_mb_denom); 
        printf("%d.%d: ", b->p - b->start, b->bits_left); sps->vui.log2_max_mv_length_horizontal = bs_read_ue(b); printf("sps->vui.log2_max_mv_length_horizontal: %d \n", sps->vui.log2_max_mv_length_horizontal); 
        printf("%d.%d: ", b->p - b->start, b->bits_left); sps->vui.log2_max_mv_length_vertical = bs_read_ue(b); printf("sps->vui.log2_max_mv_length_vertical: %d \n", sps->vui.log2_max_mv_length_vertical); 
        printf("%d.%d: ", b->p - b->start, b->bits_left); sps->vui.num_reorder_frames = bs_read_ue(b); printf("sps->vui.num_reorder_frames: %d \n", sps->vui.num_reorder_frames); 
        printf("%d.%d: ", b->p - b->start, b->bits_left); sps->vui.max_dec_frame_buffering = bs_read_ue(b); printf("sps->vui.max_dec_frame_buffering: %d \n", sps->vui.max_dec_frame_buffering); 
    }
}


//Appendix E.1.2 HRD parameters syntax
void read_debug_hrd_parameters(h264_stream_t* h, bs_t* b)
{
    sps_t* sps = h->sps;

    printf("%d.%d: ", b->p - b->start, b->bits_left); sps->hrd.cpb_cnt_minus1 = bs_read_ue(b); printf("sps->hrd.cpb_cnt_minus1: %d \n", sps->hrd.cpb_cnt_minus1); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); sps->hrd.bit_rate_scale = bs_read_u(b, 4); printf("sps->hrd.bit_rate_scale: %d \n", sps->hrd.bit_rate_scale); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); sps->hrd.cpb_size_scale = bs_read_u(b, 4); printf("sps->hrd.cpb_size_scale: %d \n", sps->hrd.cpb_size_scale); 
    for( int SchedSelIdx = 0; SchedSelIdx <= sps->hrd.cpb_cnt_minus1; SchedSelIdx++ )
    {
        printf("%d.%d: ", b->p - b->start, b->bits_left); sps->hrd.bit_rate_value_minus1[ SchedSelIdx ] = bs_read_ue(b); printf("sps->hrd.bit_rate_value_minus1[ SchedSelIdx ]: %d \n", sps->hrd.bit_rate_value_minus1[ SchedSelIdx ]); 
        printf("%d.%d: ", b->p - b->start, b->bits_left); sps->hrd.cpb_size_value_minus1[ SchedSelIdx ] = bs_read_ue(b); printf("sps->hrd.cpb_size_value_minus1[ SchedSelIdx ]: %d \n", sps->hrd.cpb_size_value_minus1[ SchedSelIdx ]); 
        printf("%d.%d: ", b->p - b->start, b->bits_left); sps->hrd.cbr_flag[ SchedSelIdx ] = bs_read_u1(b); printf("sps->hrd.cbr_flag[ SchedSelIdx ]: %d \n", sps->hrd.cbr_flag[ SchedSelIdx ]); 
    }
    printf("%d.%d: ", b->p - b->start, b->bits_left); sps->hrd.initial_cpb_removal_delay_length_minus1 = bs_read_u(b, 5); printf("sps->hrd.initial_cpb_removal_delay_length_minus1: %d \n", sps->hrd.initial_cpb_removal_delay_length_minus1); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); sps->hrd.cpb_removal_delay_length_minus1 = bs_read_u(b, 5); printf("sps->hrd.cpb_removal_delay_length_minus1: %d \n", sps->hrd.cpb_removal_delay_length_minus1); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); sps->hrd.dpb_output_delay_length_minus1 = bs_read_u(b, 5); printf("sps->hrd.dpb_output_delay_length_minus1: %d \n", sps->hrd.dpb_output_delay_length_minus1); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); sps->hrd.time_offset_length = bs_read_u(b, 5); printf("sps->hrd.time_offset_length: %d \n", sps->hrd.time_offset_length); 
}


/*
UNIMPLEMENTED
//7.3.2.1.2 Sequence parameter set extension RBSP syntax
int read_debug_seq_parameter_set_extension_rbsp(bs_t* b, sps_ext_t* sps_ext) {
    printf("%d.%d: ", b->p - b->start, b->bits_left); seq_parameter_set_id = bs_read_ue(b); printf("seq_parameter_set_id: %d \n", seq_parameter_set_id); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); aux_format_idc = bs_read_ue(b); printf("aux_format_idc: %d \n", aux_format_idc); 
    if( aux_format_idc != 0 ) {
        printf("%d.%d: ", b->p - b->start, b->bits_left); bit_depth_aux_minus8 = bs_read_ue(b); printf("bit_depth_aux_minus8: %d \n", bit_depth_aux_minus8); 
        printf("%d.%d: ", b->p - b->start, b->bits_left); alpha_incr_flag = bs_read_u1(b); printf("alpha_incr_flag: %d \n", alpha_incr_flag); 
        alpha_opaque_value = bs_read_debug_u(v);
        alpha_transparent_value = bs_read_debug_u(v);
    }
    printf("%d.%d: ", b->p - b->start, b->bits_left); additional_extension_flag = bs_read_u1(b); printf("additional_extension_flag: %d \n", additional_extension_flag); 
    read_debug_rbsp_trailing_bits();
}
*/

//7.3.2.2 Picture parameter set RBSP syntax
void read_debug_pic_parameter_set_rbsp(h264_stream_t* h, bs_t* b)
{
    pps_t* pps = h->pps;
    if( 1 )
    {
        memset(pps, 0, sizeof(pps_t));
    }

    printf("%d.%d: ", b->p - b->start, b->bits_left); pps->pic_parameter_set_id = bs_read_ue(b); printf("pps->pic_parameter_set_id: %d \n", pps->pic_parameter_set_id); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); pps->seq_parameter_set_id = bs_read_ue(b); printf("pps->seq_parameter_set_id: %d \n", pps->seq_parameter_set_id); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); pps->entropy_coding_mode_flag = bs_read_u1(b); printf("pps->entropy_coding_mode_flag: %d \n", pps->entropy_coding_mode_flag); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); pps->pic_order_present_flag = bs_read_u1(b); printf("pps->pic_order_present_flag: %d \n", pps->pic_order_present_flag); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); pps->num_slice_groups_minus1 = bs_read_ue(b); printf("pps->num_slice_groups_minus1: %d \n", pps->num_slice_groups_minus1); 

    if( pps->num_slice_groups_minus1 > 0 )
    {
        printf("%d.%d: ", b->p - b->start, b->bits_left); pps->slice_group_map_type = bs_read_ue(b); printf("pps->slice_group_map_type: %d \n", pps->slice_group_map_type); 
        if( pps->slice_group_map_type == 0 )
        {
            for( int i_group = 0; i_group <= pps->num_slice_groups_minus1; i_group++ )
            {
                printf("%d.%d: ", b->p - b->start, b->bits_left); pps->run_length_minus1[ i_group ] = bs_read_ue(b); printf("pps->run_length_minus1[ i_group ]: %d \n", pps->run_length_minus1[ i_group ]); 
            }
        }
        else if( pps->slice_group_map_type == 2 )
        {
            for( int i_group = 0; i_group < pps->num_slice_groups_minus1; i_group++ )
            {
                printf("%d.%d: ", b->p - b->start, b->bits_left); pps->top_left[ i_group ] = bs_read_ue(b); printf("pps->top_left[ i_group ]: %d \n", pps->top_left[ i_group ]); 
                printf("%d.%d: ", b->p - b->start, b->bits_left); pps->bottom_right[ i_group ] = bs_read_ue(b); printf("pps->bottom_right[ i_group ]: %d \n", pps->bottom_right[ i_group ]); 
            }
        }
        else if( pps->slice_group_map_type == 3 ||
                 pps->slice_group_map_type == 4 ||
                 pps->slice_group_map_type == 5 )
        {
            printf("%d.%d: ", b->p - b->start, b->bits_left); pps->slice_group_change_direction_flag = bs_read_u1(b); printf("pps->slice_group_change_direction_flag: %d \n", pps->slice_group_change_direction_flag); 
            printf("%d.%d: ", b->p - b->start, b->bits_left); pps->slice_group_change_rate_minus1 = bs_read_ue(b); printf("pps->slice_group_change_rate_minus1: %d \n", pps->slice_group_change_rate_minus1); 
        }
        else if( pps->slice_group_map_type == 6 )
        {
            printf("%d.%d: ", b->p - b->start, b->bits_left); pps->pic_size_in_map_units_minus1 = bs_read_ue(b); printf("pps->pic_size_in_map_units_minus1: %d \n", pps->pic_size_in_map_units_minus1); 
            for( int i = 0; i <= pps->pic_size_in_map_units_minus1; i++ )
            {
                int v = intlog2( pps->num_slice_groups_minus1 + 1 );
                printf("%d.%d: ", b->p - b->start, b->bits_left); pps->slice_group_id[ i ] = bs_read_u(b, v); printf("pps->slice_group_id[ i ]: %d \n", pps->slice_group_id[ i ]); 
            }
        }
    }
    printf("%d.%d: ", b->p - b->start, b->bits_left); pps->num_ref_idx_l0_active_minus1 = bs_read_ue(b); printf("pps->num_ref_idx_l0_active_minus1: %d \n", pps->num_ref_idx_l0_active_minus1); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); pps->num_ref_idx_l1_active_minus1 = bs_read_ue(b); printf("pps->num_ref_idx_l1_active_minus1: %d \n", pps->num_ref_idx_l1_active_minus1); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); pps->weighted_pred_flag = bs_read_u1(b); printf("pps->weighted_pred_flag: %d \n", pps->weighted_pred_flag); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); pps->weighted_bipred_idc = bs_read_u(b, 2); printf("pps->weighted_bipred_idc: %d \n", pps->weighted_bipred_idc); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); pps->pic_init_qp_minus26 = bs_read_se(b); printf("pps->pic_init_qp_minus26: %d \n", pps->pic_init_qp_minus26); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); pps->pic_init_qs_minus26 = bs_read_se(b); printf("pps->pic_init_qs_minus26: %d \n", pps->pic_init_qs_minus26); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); pps->chroma_qp_index_offset = bs_read_se(b); printf("pps->chroma_qp_index_offset: %d \n", pps->chroma_qp_index_offset); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); pps->deblocking_filter_control_present_flag = bs_read_u1(b); printf("pps->deblocking_filter_control_present_flag: %d \n", pps->deblocking_filter_control_present_flag); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); pps->constrained_intra_pred_flag = bs_read_u1(b); printf("pps->constrained_intra_pred_flag: %d \n", pps->constrained_intra_pred_flag); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); pps->redundant_pic_cnt_present_flag = bs_read_u1(b); printf("pps->redundant_pic_cnt_present_flag: %d \n", pps->redundant_pic_cnt_present_flag); 

    int have_more_data = 0;
    if( 1 ) { have_more_data = more_rbsp_data(h, b); }
    if( 0 )
    {
        have_more_data = pps->transform_8x8_mode_flag | pps->pic_scaling_matrix_present_flag | pps->second_chroma_qp_index_offset != 0;
    }

    if( have_more_data )
    {
        printf("%d.%d: ", b->p - b->start, b->bits_left); pps->transform_8x8_mode_flag = bs_read_u1(b); printf("pps->transform_8x8_mode_flag: %d \n", pps->transform_8x8_mode_flag); 
        printf("%d.%d: ", b->p - b->start, b->bits_left); pps->pic_scaling_matrix_present_flag = bs_read_u1(b); printf("pps->pic_scaling_matrix_present_flag: %d \n", pps->pic_scaling_matrix_present_flag); 
        if( pps->pic_scaling_matrix_present_flag )
        {
            for( int i = 0; i < 6 + 2* pps->transform_8x8_mode_flag; i++ )
            {
                printf("%d.%d: ", b->p - b->start, b->bits_left); pps->pic_scaling_list_present_flag[ i ] = bs_read_u1(b); printf("pps->pic_scaling_list_present_flag[ i ]: %d \n", pps->pic_scaling_list_present_flag[ i ]); 
                if( pps->pic_scaling_list_present_flag[ i ] )
                {
                    if( i < 6 )
                    {
                        read_debug_scaling_list( b, pps->ScalingList4x4[ i ], 16,
                                                 &( pps->UseDefaultScalingMatrix4x4Flag[ i ] ) );
                    }
                    else
                    {
                        read_debug_scaling_list( b, pps->ScalingList8x8[ i - 6 ], 64,
                                                 &( pps->UseDefaultScalingMatrix8x8Flag[ i - 6 ] ) );
                    }
                }
            }
        }
        printf("%d.%d: ", b->p - b->start, b->bits_left); pps->second_chroma_qp_index_offset = bs_read_se(b); printf("pps->second_chroma_qp_index_offset: %d \n", pps->second_chroma_qp_index_offset); 
    }
    read_debug_rbsp_trailing_bits(h, b);

    if( 1 )
    {
        memcpy(h->pps, h->pps_table[pps->pic_parameter_set_id], sizeof(pps_t));
    }
}

#ifdef HAVE_SEI
//7.3.2.3 Supplemental enhancement information RBSP syntax
void read_debug_sei_rbsp(h264_stream_t* h, bs_t* b)
{
    if( 1 )
    {
    for( int i = 0; i < h->num_seis; i++ )
    {
        sei_free(h->seis[i]);
    }
    
    h->num_seis = 0;
    do {
        h->num_seis++;
        h->seis = (sei_t**)realloc(h->seis, h->num_seis * sizeof(sei_t*));
        h->seis[h->num_seis - 1] = sei_new();
        h->sei = h->seis[h->num_seis - 1];
        read_debug_sei_message(h, b);
    } while( more_rbsp_data(h, b) );

    }

    if( 0 )
    {
    for (int i = 0; i < h->num_seis; i++)
    {
        h->sei = h->seis[i];
        read_debug_sei_message(h, b);
    }
    h->sei = NULL;
    }

    read_debug_rbsp_trailing_bits(h, b);
}

//7.3.2.3.1 Supplemental enhancement information message syntax
void read_debug_sei_message(h264_stream_t* h, bs_t* b)
{
    if( 0 )
    {
        _write_ff_coded_number(b, h->sei->payloadType);
        _write_ff_coded_number(b, h->sei->payloadSize);
    }
    if( 1 )
    {
        h->sei->payloadType = _read_ff_coded_number(b);
        h->sei->payloadSize = _read_ff_coded_number(b);
    }
    read_debug_sei_payload( h, b, h->sei->payloadType, h->sei->payloadSize );
}
#endif

//7.3.2.4 Access unit delimiter RBSP syntax
void read_debug_access_unit_delimiter_rbsp(h264_stream_t* h, bs_t* b)
{
    printf("%d.%d: ", b->p - b->start, b->bits_left); h->aud->primary_pic_type = bs_read_u(b, 3); printf("h->aud->primary_pic_type: %d \n", h->aud->primary_pic_type); 
    read_debug_rbsp_trailing_bits(h, b);
}

//7.3.2.5 End of sequence RBSP syntax
void read_debug_end_of_seq_rbsp(h264_stream_t* h, bs_t* b)
{
}

//7.3.2.6 End of stream RBSP syntax
void read_debug_end_of_stream_rbsp(h264_stream_t* h, bs_t* b)
{
}

//7.3.2.7 Filler data RBSP syntax
void read_debug_filler_data_rbsp(h264_stream_t* h, bs_t* b)
{
    while( bs_next_bits(b, 8) == 0xFF )
    {
        printf("%d.%d: ", b->p - b->start, b->bits_left); int ff_byte = bs_read_u(b, 8); printf("ff_byte: %d \n", ff_byte); 
    }
    read_debug_rbsp_trailing_bits(h, b);
}

//7.3.2.8 Slice layer without partitioning RBSP syntax
void read_debug_slice_layer_rbsp(h264_stream_t* h,  bs_t* b)
{
    read_debug_slice_header(h, b);
    slice_data_rbsp_t* slice_data = h->slice_data;

    if ( slice_data != NULL )
    {
        if ( slice_data->rbsp_buf != NULL ) free( slice_data->rbsp_buf ); 
        uint8_t *sptr = b->p + (!!b->bits_left); // CABAC-specific: skip alignment bits, if there are any
        slice_data->rbsp_size = b->end - sptr;
        
        slice_data->rbsp_buf = (uint8_t*)malloc(slice_data->rbsp_size);
        memcpy( slice_data->rbsp_buf, sptr, slice_data->rbsp_size );
        // ugly hack: since next NALU starts at byte border, we are going to be padded by trailing_bits;
        return;
    }

    // FIXME should read or skip data
    //slice_data( ); /* all categories of slice_data( ) syntax */
    read_debug_rbsp_slice_trailing_bits(h, b);
}

/*
// UNIMPLEMENTED
//7.3.2.9.1 Slice data partition A RBSP syntax
slice_data_partition_a_layer_rbsp( ) {
    read_debug_slice_header( );             // only category 2
    slice_id = bs_read_debug_ue(b)
    read_debug_slice_data( );               // only category 2
    read_debug_rbsp_slice_trailing_bits( ); // only category 2
}

//7.3.2.9.2 Slice data partition B RBSP syntax
slice_data_partition_b_layer_rbsp( ) {
    printf("%d.%d: ", b->p - b->start, b->bits_left); slice_id = bs_read_ue(b); printf("slice_id: %d \n", slice_id);     // only category 3
    if( redundant_pic_cnt_present_flag )
        printf("%d.%d: ", b->p - b->start, b->bits_left); redundant_pic_cnt = bs_read_ue(b); printf("redundant_pic_cnt: %d \n", redundant_pic_cnt); 
    read_debug_slice_data( );               // only category 3
    read_debug_rbsp_slice_trailing_bits( ); // only category 3
}

//7.3.2.9.3 Slice data partition C RBSP syntax
slice_data_partition_c_layer_rbsp( ) {
    printf("%d.%d: ", b->p - b->start, b->bits_left); slice_id = bs_read_ue(b); printf("slice_id: %d \n", slice_id);     // only category 4
    if( redundant_pic_cnt_present_flag )
        printf("%d.%d: ", b->p - b->start, b->bits_left); redundant_pic_cnt = bs_read_ue(b); printf("redundant_pic_cnt: %d \n", redundant_pic_cnt); 
    read_debug_slice_data( );               // only category 4
    rbsp_slice_trailing_bits( ); // only category 4
}
*/

//7.3.2.10 RBSP slice trailing bits syntax
void read_debug_rbsp_slice_trailing_bits(h264_stream_t* h, bs_t* b)
{
    read_debug_rbsp_trailing_bits(h, b);
    if( h->pps->entropy_coding_mode_flag )
    {
        while( more_rbsp_trailing_data(h, b) )
        {
            printf("%d.%d: ", b->p - b->start, b->bits_left); int cabac_zero_word = bs_read_u(b, 16); printf("cabac_zero_word: %d \n", cabac_zero_word); 
        }
    }
}

//7.3.2.11 RBSP trailing bits syntax
void read_debug_rbsp_trailing_bits(h264_stream_t* h, bs_t* b)
{
    printf("%d.%d: ", b->p - b->start, b->bits_left); int rbsp_stop_one_bit = bs_read_u(b, 1); printf("rbsp_stop_one_bit: %d \n", rbsp_stop_one_bit); 

    while( !bs_byte_aligned(b) )
    {
        printf("%d.%d: ", b->p - b->start, b->bits_left); int rbsp_alignment_zero_bit = bs_read_u(b, 1); printf("rbsp_alignment_zero_bit: %d \n", rbsp_alignment_zero_bit); 
    }
}

//7.3.3 Slice header syntax
void read_debug_slice_header(h264_stream_t* h, bs_t* b)
{
    slice_header_t* sh = h->sh;
    if( 1 )
    {
        memset(sh, 0, sizeof(slice_header_t));
    }

    nal_t* nal = h->nal;

    printf("%d.%d: ", b->p - b->start, b->bits_left); sh->first_mb_in_slice = bs_read_ue(b); printf("sh->first_mb_in_slice: %d \n", sh->first_mb_in_slice); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); sh->slice_type = bs_read_ue(b); printf("sh->slice_type: %d \n", sh->slice_type); 
    printf("%d.%d: ", b->p - b->start, b->bits_left); sh->pic_parameter_set_id = bs_read_ue(b); printf("sh->pic_parameter_set_id: %d \n", sh->pic_parameter_set_id); 

    // TODO check existence, otherwise fail
    pps_t* pps = h->pps;
    sps_t* sps = h->sps;
    memcpy(h->pps_table[sh->pic_parameter_set_id], h->pps, sizeof(pps_t));
    memcpy(h->sps_table[pps->seq_parameter_set_id], h->sps, sizeof(sps_t));

    printf("%d.%d: ", b->p - b->start, b->bits_left); sh->frame_num = bs_read_u(b, sps->log2_max_frame_num_minus4 + 4 ); printf("sh->frame_num: %d \n", sh->frame_num);  // was u(v)
    if( !sps->frame_mbs_only_flag )
    {
        printf("%d.%d: ", b->p - b->start, b->bits_left); sh->field_pic_flag = bs_read_u1(b); printf("sh->field_pic_flag: %d \n", sh->field_pic_flag); 
        if( sh->field_pic_flag )
        {
            printf("%d.%d: ", b->p - b->start, b->bits_left); sh->bottom_field_flag = bs_read_u1(b); printf("sh->bottom_field_flag: %d \n", sh->bottom_field_flag); 
        }
    }
    if( nal->nal_unit_type == 5 )
    {
        printf("%d.%d: ", b->p - b->start, b->bits_left); sh->idr_pic_id = bs_read_ue(b); printf("sh->idr_pic_id: %d \n", sh->idr_pic_id); 
    }
    if( sps->pic_order_cnt_type == 0 )
    {
        printf("%d.%d: ", b->p - b->start, b->bits_left); sh->pic_order_cnt_lsb = bs_read_u(b, sps->log2_max_pic_order_cnt_lsb_minus4 + 4 ); printf("sh->pic_order_cnt_lsb: %d \n", sh->pic_order_cnt_lsb);  // was u(v)
        if( pps->pic_order_present_flag && !sh->field_pic_flag )
        {
            printf("%d.%d: ", b->p - b->start, b->bits_left); sh->delta_pic_order_cnt_bottom = bs_read_se(b); printf("sh->delta_pic_order_cnt_bottom: %d \n", sh->delta_pic_order_cnt_bottom); 
        }
    }
    if( sps->pic_order_cnt_type == 1 && !sps->delta_pic_order_always_zero_flag )
    {
        printf("%d.%d: ", b->p - b->start, b->bits_left); sh->delta_pic_order_cnt[ 0 ] = bs_read_se(b); printf("sh->delta_pic_order_cnt[ 0 ]: %d \n", sh->delta_pic_order_cnt[ 0 ]); 
        if( pps->pic_order_present_flag && !sh->field_pic_flag )
        {
            printf("%d.%d: ", b->p - b->start, b->bits_left); sh->delta_pic_order_cnt[ 1 ] = bs_read_se(b); printf("sh->delta_pic_order_cnt[ 1 ]: %d \n", sh->delta_pic_order_cnt[ 1 ]); 
        }
    }
    if( pps->redundant_pic_cnt_present_flag )
    {
        printf("%d.%d: ", b->p - b->start, b->bits_left); sh->redundant_pic_cnt = bs_read_ue(b); printf("sh->redundant_pic_cnt: %d \n", sh->redundant_pic_cnt); 
    }
    if( is_slice_type( sh->slice_type, SH_SLICE_TYPE_B ) )
    {
        printf("%d.%d: ", b->p - b->start, b->bits_left); sh->direct_spatial_mv_pred_flag = bs_read_u1(b); printf("sh->direct_spatial_mv_pred_flag: %d \n", sh->direct_spatial_mv_pred_flag); 
    }
    if( is_slice_type( sh->slice_type, SH_SLICE_TYPE_P ) || is_slice_type( sh->slice_type, SH_SLICE_TYPE_SP ) || is_slice_type( sh->slice_type, SH_SLICE_TYPE_B ) )
    {
        printf("%d.%d: ", b->p - b->start, b->bits_left); sh->num_ref_idx_active_override_flag = bs_read_u1(b); printf("sh->num_ref_idx_active_override_flag: %d \n", sh->num_ref_idx_active_override_flag); 
        if( sh->num_ref_idx_active_override_flag )
        {
            printf("%d.%d: ", b->p - b->start, b->bits_left); sh->num_ref_idx_l0_active_minus1 = bs_read_ue(b); printf("sh->num_ref_idx_l0_active_minus1: %d \n", sh->num_ref_idx_l0_active_minus1);  // FIXME does this modify the pps?
            if( is_slice_type( sh->slice_type, SH_SLICE_TYPE_B ) )
            {
                printf("%d.%d: ", b->p - b->start, b->bits_left); sh->num_ref_idx_l1_active_minus1 = bs_read_ue(b); printf("sh->num_ref_idx_l1_active_minus1: %d \n", sh->num_ref_idx_l1_active_minus1); 
            }
        }
    }
    read_debug_ref_pic_list_reordering(h, b);
    if( ( pps->weighted_pred_flag && ( is_slice_type( sh->slice_type, SH_SLICE_TYPE_P ) || is_slice_type( sh->slice_type, SH_SLICE_TYPE_SP ) ) ) ||
        ( pps->weighted_bipred_idc == 1 && is_slice_type( sh->slice_type, SH_SLICE_TYPE_B ) ) )
    {
        read_debug_pred_weight_table(h, b);
    }
    if( nal->nal_ref_idc != 0 )
    {
        read_debug_dec_ref_pic_marking(h, b);
    }
    if( pps->entropy_coding_mode_flag && ! is_slice_type( sh->slice_type, SH_SLICE_TYPE_I ) && ! is_slice_type( sh->slice_type, SH_SLICE_TYPE_SI ) )
    {
        printf("%d.%d: ", b->p - b->start, b->bits_left); sh->cabac_init_idc = bs_read_ue(b); printf("sh->cabac_init_idc: %d \n", sh->cabac_init_idc); 
    }
    printf("%d.%d: ", b->p - b->start, b->bits_left); sh->slice_qp_delta = bs_read_se(b); printf("sh->slice_qp_delta: %d \n", sh->slice_qp_delta); 
    if( is_slice_type( sh->slice_type, SH_SLICE_TYPE_SP ) || is_slice_type( sh->slice_type, SH_SLICE_TYPE_SI ) )
    {
        if( is_slice_type( sh->slice_type, SH_SLICE_TYPE_SP ) )
        {
            printf("%d.%d: ", b->p - b->start, b->bits_left); sh->sp_for_switch_flag = bs_read_u1(b); printf("sh->sp_for_switch_flag: %d \n", sh->sp_for_switch_flag); 
        }
        printf("%d.%d: ", b->p - b->start, b->bits_left); sh->slice_qs_delta = bs_read_se(b); printf("sh->slice_qs_delta: %d \n", sh->slice_qs_delta); 
    }
    if( pps->deblocking_filter_control_present_flag )
    {
        printf("%d.%d: ", b->p - b->start, b->bits_left); sh->disable_deblocking_filter_idc = bs_read_ue(b); printf("sh->disable_deblocking_filter_idc: %d \n", sh->disable_deblocking_filter_idc); 
        if( sh->disable_deblocking_filter_idc != 1 )
        {
            printf("%d.%d: ", b->p - b->start, b->bits_left); sh->slice_alpha_c0_offset_div2 = bs_read_se(b); printf("sh->slice_alpha_c0_offset_div2: %d \n", sh->slice_alpha_c0_offset_div2); 
            printf("%d.%d: ", b->p - b->start, b->bits_left); sh->slice_beta_offset_div2 = bs_read_se(b); printf("sh->slice_beta_offset_div2: %d \n", sh->slice_beta_offset_div2); 
        }
    }
    if( pps->num_slice_groups_minus1 > 0 &&
        pps->slice_group_map_type >= 3 && pps->slice_group_map_type <= 5)
    {
        int v = intlog2( pps->pic_size_in_map_units_minus1 +  pps->slice_group_change_rate_minus1 + 1 );
        printf("%d.%d: ", b->p - b->start, b->bits_left); sh->slice_group_change_cycle = bs_read_u(b, v); printf("sh->slice_group_change_cycle: %d \n", sh->slice_group_change_cycle);  // FIXME add 2?
    }
}

//7.3.3.1 Reference picture list reordering syntax
void read_debug_ref_pic_list_reordering(h264_stream_t* h, bs_t* b)
{
    slice_header_t* sh = h->sh;
    // FIXME should be an array

    if( ! is_slice_type( sh->slice_type, SH_SLICE_TYPE_I ) && ! is_slice_type( sh->slice_type, SH_SLICE_TYPE_SI ) )
    {
        printf("%d.%d: ", b->p - b->start, b->bits_left); sh->rplr.ref_pic_list_reordering_flag_l0 = bs_read_u1(b); printf("sh->rplr.ref_pic_list_reordering_flag_l0: %d \n", sh->rplr.ref_pic_list_reordering_flag_l0); 
        if( sh->rplr.ref_pic_list_reordering_flag_l0 )
        {
            int n = -1;
            do
            {
                n++;
                printf("%d.%d: ", b->p - b->start, b->bits_left); sh->rplr.reorder_l0.reordering_of_pic_nums_idc[ n ] = bs_read_ue(b); printf("sh->rplr.reorder_l0.reordering_of_pic_nums_idc[ n ]: %d \n", sh->rplr.reorder_l0.reordering_of_pic_nums_idc[ n ]); 
                if( sh->rplr.reorder_l0.reordering_of_pic_nums_idc[ n ] == 0 ||
                    sh->rplr.reorder_l0.reordering_of_pic_nums_idc[ n ] == 1 )
                {
                    printf("%d.%d: ", b->p - b->start, b->bits_left); sh->rplr.reorder_l0.abs_diff_pic_num_minus1[ n ] = bs_read_ue(b); printf("sh->rplr.reorder_l0.abs_diff_pic_num_minus1[ n ]: %d \n", sh->rplr.reorder_l0.abs_diff_pic_num_minus1[ n ]); 
                }
                else if( sh->rplr.reorder_l0.reordering_of_pic_nums_idc[ n ] == 2 )
                {
                    printf("%d.%d: ", b->p - b->start, b->bits_left); sh->rplr.reorder_l0.long_term_pic_num[ n ] = bs_read_ue(b); printf("sh->rplr.reorder_l0.long_term_pic_num[ n ]: %d \n", sh->rplr.reorder_l0.long_term_pic_num[ n ]); 
                }
            } while( sh->rplr.reorder_l0.reordering_of_pic_nums_idc[ n ] != 3 && ! bs_eof(b) );
        }
    }
    if( is_slice_type( sh->slice_type, SH_SLICE_TYPE_B ) )
    {
        printf("%d.%d: ", b->p - b->start, b->bits_left); sh->rplr.ref_pic_list_reordering_flag_l1 = bs_read_u1(b); printf("sh->rplr.ref_pic_list_reordering_flag_l1: %d \n", sh->rplr.ref_pic_list_reordering_flag_l1); 
        if( sh->rplr.ref_pic_list_reordering_flag_l1 )
        {
            int n = -1;
            do
            {
                n++;
                printf("%d.%d: ", b->p - b->start, b->bits_left); sh->rplr.reorder_l1.reordering_of_pic_nums_idc[ n ] = bs_read_ue(b); printf("sh->rplr.reorder_l1.reordering_of_pic_nums_idc[ n ]: %d \n", sh->rplr.reorder_l1.reordering_of_pic_nums_idc[ n ]); 
                if( sh->rplr.reorder_l1.reordering_of_pic_nums_idc[ n ] == 0 ||
                    sh->rplr.reorder_l1.reordering_of_pic_nums_idc[ n ] == 1 )
                {
                    printf("%d.%d: ", b->p - b->start, b->bits_left); sh->rplr.reorder_l1.abs_diff_pic_num_minus1[ n ] = bs_read_ue(b); printf("sh->rplr.reorder_l1.abs_diff_pic_num_minus1[ n ]: %d \n", sh->rplr.reorder_l1.abs_diff_pic_num_minus1[ n ]); 
                }
                else if( sh->rplr.reorder_l1.reordering_of_pic_nums_idc[ n ] == 2 )
                {
                    printf("%d.%d: ", b->p - b->start, b->bits_left); sh->rplr.reorder_l1.long_term_pic_num[ n ] = bs_read_ue(b); printf("sh->rplr.reorder_l1.long_term_pic_num[ n ]: %d \n", sh->rplr.reorder_l1.long_term_pic_num[ n ]); 
                }
            } while( sh->rplr.reorder_l1.reordering_of_pic_nums_idc[ n ] != 3 && ! bs_eof(b) );
        }
    }
}

//7.3.3.2 Prediction weight table syntax
void read_debug_pred_weight_table(h264_stream_t* h, bs_t* b)
{
    slice_header_t* sh = h->sh;
    sps_t* sps = h->sps;
    pps_t* pps = h->pps;

    int i, j;

    printf("%d.%d: ", b->p - b->start, b->bits_left); sh->pwt.luma_log2_weight_denom = bs_read_ue(b); printf("sh->pwt.luma_log2_weight_denom: %d \n", sh->pwt.luma_log2_weight_denom); 
    if( sps->chroma_format_idc != 0 )
    {
        printf("%d.%d: ", b->p - b->start, b->bits_left); sh->pwt.chroma_log2_weight_denom = bs_read_ue(b); printf("sh->pwt.chroma_log2_weight_denom: %d \n", sh->pwt.chroma_log2_weight_denom); 
    }
    for( i = 0; i <= pps->num_ref_idx_l0_active_minus1; i++ )
    {
        printf("%d.%d: ", b->p - b->start, b->bits_left); sh->pwt.luma_weight_l0_flag[i] = bs_read_u1(b); printf("sh->pwt.luma_weight_l0_flag[i]: %d \n", sh->pwt.luma_weight_l0_flag[i]); 
        if( sh->pwt.luma_weight_l0_flag[i] )
        {
            printf("%d.%d: ", b->p - b->start, b->bits_left); sh->pwt.luma_weight_l0[ i ] = bs_read_se(b); printf("sh->pwt.luma_weight_l0[ i ]: %d \n", sh->pwt.luma_weight_l0[ i ]); 
            printf("%d.%d: ", b->p - b->start, b->bits_left); sh->pwt.luma_offset_l0[ i ] = bs_read_se(b); printf("sh->pwt.luma_offset_l0[ i ]: %d \n", sh->pwt.luma_offset_l0[ i ]); 
        }
        if ( sps->chroma_format_idc != 0 )
        {
            printf("%d.%d: ", b->p - b->start, b->bits_left); sh->pwt.chroma_weight_l0_flag[i] = bs_read_u1(b); printf("sh->pwt.chroma_weight_l0_flag[i]: %d \n", sh->pwt.chroma_weight_l0_flag[i]); 
            if( sh->pwt.chroma_weight_l0_flag[i] )
            {
                for( j =0; j < 2; j++ )
                {
                    printf("%d.%d: ", b->p - b->start, b->bits_left); sh->pwt.chroma_weight_l0[ i ][ j ] = bs_read_se(b); printf("sh->pwt.chroma_weight_l0[ i ][ j ]: %d \n", sh->pwt.chroma_weight_l0[ i ][ j ]); 
                    printf("%d.%d: ", b->p - b->start, b->bits_left); sh->pwt.chroma_offset_l0[ i ][ j ] = bs_read_se(b); printf("sh->pwt.chroma_offset_l0[ i ][ j ]: %d \n", sh->pwt.chroma_offset_l0[ i ][ j ]); 
                }
            }
        }
    }
    if( is_slice_type( sh->slice_type, SH_SLICE_TYPE_B ) )
    {
        for( i = 0; i <= pps->num_ref_idx_l1_active_minus1; i++ )
        {
            printf("%d.%d: ", b->p - b->start, b->bits_left); sh->pwt.luma_weight_l1_flag[i] = bs_read_u1(b); printf("sh->pwt.luma_weight_l1_flag[i]: %d \n", sh->pwt.luma_weight_l1_flag[i]); 
            if( sh->pwt.luma_weight_l1_flag[i] )
            {
                printf("%d.%d: ", b->p - b->start, b->bits_left); sh->pwt.luma_weight_l1[ i ] = bs_read_se(b); printf("sh->pwt.luma_weight_l1[ i ]: %d \n", sh->pwt.luma_weight_l1[ i ]); 
                printf("%d.%d: ", b->p - b->start, b->bits_left); sh->pwt.luma_offset_l1[ i ] = bs_read_se(b); printf("sh->pwt.luma_offset_l1[ i ]: %d \n", sh->pwt.luma_offset_l1[ i ]); 
            }
            if( sps->chroma_format_idc != 0 )
            {
                printf("%d.%d: ", b->p - b->start, b->bits_left); sh->pwt.chroma_weight_l1_flag[i] = bs_read_u1(b); printf("sh->pwt.chroma_weight_l1_flag[i]: %d \n", sh->pwt.chroma_weight_l1_flag[i]); 
                if( sh->pwt.chroma_weight_l1_flag[i] )
                {
                    for( j = 0; j < 2; j++ )
                    {
                        printf("%d.%d: ", b->p - b->start, b->bits_left); sh->pwt.chroma_weight_l1[ i ][ j ] = bs_read_se(b); printf("sh->pwt.chroma_weight_l1[ i ][ j ]: %d \n", sh->pwt.chroma_weight_l1[ i ][ j ]); 
                        printf("%d.%d: ", b->p - b->start, b->bits_left); sh->pwt.chroma_offset_l1[ i ][ j ] = bs_read_se(b); printf("sh->pwt.chroma_offset_l1[ i ][ j ]: %d \n", sh->pwt.chroma_offset_l1[ i ][ j ]); 
                    }
                }
            }
        }
    }
}

//7.3.3.3 Decoded reference picture marking syntax
void read_debug_dec_ref_pic_marking(h264_stream_t* h, bs_t* b)
{
    slice_header_t* sh = h->sh;
    // FIXME should be an array

    if( h->nal->nal_unit_type == 5 )
    {
        printf("%d.%d: ", b->p - b->start, b->bits_left); sh->drpm.no_output_of_prior_pics_flag = bs_read_u1(b); printf("sh->drpm.no_output_of_prior_pics_flag: %d \n", sh->drpm.no_output_of_prior_pics_flag); 
        printf("%d.%d: ", b->p - b->start, b->bits_left); sh->drpm.long_term_reference_flag = bs_read_u1(b); printf("sh->drpm.long_term_reference_flag: %d \n", sh->drpm.long_term_reference_flag); 
    }
    else
    {
        printf("%d.%d: ", b->p - b->start, b->bits_left); sh->drpm.adaptive_ref_pic_marking_mode_flag = bs_read_u1(b); printf("sh->drpm.adaptive_ref_pic_marking_mode_flag: %d \n", sh->drpm.adaptive_ref_pic_marking_mode_flag); 
        if( sh->drpm.adaptive_ref_pic_marking_mode_flag )
        {
            int n = -1;
            do
            {
                n++;
                printf("%d.%d: ", b->p - b->start, b->bits_left); sh->drpm.memory_management_control_operation[ n ] = bs_read_ue(b); printf("sh->drpm.memory_management_control_operation[ n ]: %d \n", sh->drpm.memory_management_control_operation[ n ]); 
                if( sh->drpm.memory_management_control_operation[ n ] == 1 ||
                    sh->drpm.memory_management_control_operation[ n ] == 3 )
                {
                    printf("%d.%d: ", b->p - b->start, b->bits_left); sh->drpm.difference_of_pic_nums_minus1[ n ] = bs_read_ue(b); printf("sh->drpm.difference_of_pic_nums_minus1[ n ]: %d \n", sh->drpm.difference_of_pic_nums_minus1[ n ]); 
                }
                if(sh->drpm.memory_management_control_operation[ n ] == 2 )
                {
                    printf("%d.%d: ", b->p - b->start, b->bits_left); sh->drpm.long_term_pic_num[ n ] = bs_read_ue(b); printf("sh->drpm.long_term_pic_num[ n ]: %d \n", sh->drpm.long_term_pic_num[ n ]); 
                }
                if( sh->drpm.memory_management_control_operation[ n ] == 3 ||
                    sh->drpm.memory_management_control_operation[ n ] == 6 )
                {
                    printf("%d.%d: ", b->p - b->start, b->bits_left); sh->drpm.long_term_frame_idx[ n ] = bs_read_ue(b); printf("sh->drpm.long_term_frame_idx[ n ]: %d \n", sh->drpm.long_term_frame_idx[ n ]); 
                }
                if( sh->drpm.memory_management_control_operation[ n ] == 4 )
                {
                    printf("%d.%d: ", b->p - b->start, b->bits_left); sh->drpm.max_long_term_frame_idx_plus1[ n ] = bs_read_ue(b); printf("sh->drpm.max_long_term_frame_idx_plus1[ n ]: %d \n", sh->drpm.max_long_term_frame_idx_plus1[ n ]); 
                }
            } while( sh->drpm.memory_management_control_operation[ n ] != 0 && ! bs_eof(b) );
        }
    }
}
                                                                                                                                                                                                                                                                                                                                                                                               moonlight-embedded-2.1.1/third_party/h264bitstream/h264_stream.h                                    0000664 0000000 0000000 00000044061 12563604362 0024414 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* 
 * h264bitstream - a library for reading and writing H.264 video
 * Copyright (C) 2005-2007 Auroras Entertainment, LLC
 * Copyright (C) 2008-2011 Avail-TVN
 * 
 * Written by Alex Izvorski <aizvorski@gmail.com> and Alex Giladi <alex.giladi@gmail.com>
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

#ifndef _H264_STREAM_H
#define _H264_STREAM_H        1

#include <stdint.h>
#include <stdio.h>
#include <assert.h>

#include "bs.h"
#include "h264_sei.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
   Sequence Parameter Set
   @see 7.3.2.1 Sequence parameter set RBSP syntax
   @see read_seq_parameter_set_rbsp
   @see write_seq_parameter_set_rbsp
   @see debug_sps
*/
typedef struct
{
    int profile_idc;
    int constraint_set0_flag;
    int constraint_set1_flag;
    int constraint_set2_flag;
    int constraint_set3_flag;
    int constraint_set4_flag;
    int constraint_set5_flag;
    int reserved_zero_2bits;
    int level_idc;
    int seq_parameter_set_id;
    int chroma_format_idc;
    int residual_colour_transform_flag;
    int bit_depth_luma_minus8;
    int bit_depth_chroma_minus8;
    int qpprime_y_zero_transform_bypass_flag;
    int seq_scaling_matrix_present_flag;
      int seq_scaling_list_present_flag[8];
      int* ScalingList4x4[6];
      int UseDefaultScalingMatrix4x4Flag[6];
      int* ScalingList8x8[2];
      int UseDefaultScalingMatrix8x8Flag[2];
    int log2_max_frame_num_minus4;
    int pic_order_cnt_type;
      int log2_max_pic_order_cnt_lsb_minus4;
      int delta_pic_order_always_zero_flag;
      int offset_for_non_ref_pic;
      int offset_for_top_to_bottom_field;
      int num_ref_frames_in_pic_order_cnt_cycle;
      int offset_for_ref_frame[256];
    int num_ref_frames;
    int gaps_in_frame_num_value_allowed_flag;
    int pic_width_in_mbs_minus1;
    int pic_height_in_map_units_minus1;
    int frame_mbs_only_flag;
    int mb_adaptive_frame_field_flag;
    int direct_8x8_inference_flag;
    int frame_cropping_flag;
      int frame_crop_left_offset;
      int frame_crop_right_offset;
      int frame_crop_top_offset;
      int frame_crop_bottom_offset;
    int vui_parameters_present_flag;
    
    struct
    {
        int aspect_ratio_info_present_flag;
          int aspect_ratio_idc;
            int sar_width;
            int sar_height;
        int overscan_info_present_flag;
          int overscan_appropriate_flag;
        int video_signal_type_present_flag;
          int video_format;
          int video_full_range_flag;
          int colour_description_present_flag;
            int colour_primaries;
            int transfer_characteristics;
            int matrix_coefficients;
        int chroma_loc_info_present_flag;
          int chroma_sample_loc_type_top_field;
          int chroma_sample_loc_type_bottom_field;
        int timing_info_present_flag;
          int num_units_in_tick;
          int time_scale;
          int fixed_frame_rate_flag;
        int nal_hrd_parameters_present_flag;
        int vcl_hrd_parameters_present_flag;
          int low_delay_hrd_flag;
        int pic_struct_present_flag;
        int bitstream_restriction_flag;
          int motion_vectors_over_pic_boundaries_flag;
          int max_bytes_per_pic_denom;
          int max_bits_per_mb_denom;
          int log2_max_mv_length_horizontal;
          int log2_max_mv_length_vertical;
          int num_reorder_frames;
          int max_dec_frame_buffering;
    } vui;

    struct
    {
        int cpb_cnt_minus1;
        int bit_rate_scale;
        int cpb_size_scale;
          int bit_rate_value_minus1[32]; // up to cpb_cnt_minus1, which is <= 31
          int cpb_size_value_minus1[32];
          int cbr_flag[32];
        int initial_cpb_removal_delay_length_minus1;
        int cpb_removal_delay_length_minus1;
        int dpb_output_delay_length_minus1;
        int time_offset_length;
    } hrd;

} sps_t;


/**
   Picture Parameter Set
   @see 7.3.2.2 Picture parameter set RBSP syntax
   @see read_pic_parameter_set_rbsp
   @see write_pic_parameter_set_rbsp
   @see debug_pps
*/
typedef struct 
{
    int pic_parameter_set_id;
    int seq_parameter_set_id;
    int entropy_coding_mode_flag;
    int pic_order_present_flag;
    int num_slice_groups_minus1;
    int slice_group_map_type;
      int run_length_minus1[8]; // up to num_slice_groups_minus1, which is <= 7 in Baseline and Extended, 0 otheriwse
      int top_left[8];
      int bottom_right[8];
      int slice_group_change_direction_flag;
      int slice_group_change_rate_minus1;
      int pic_size_in_map_units_minus1;
      int slice_group_id[256]; // FIXME what size?
    int num_ref_idx_l0_active_minus1;
    int num_ref_idx_l1_active_minus1;
    int weighted_pred_flag;
    int weighted_bipred_idc;
    int pic_init_qp_minus26;
    int pic_init_qs_minus26;
    int chroma_qp_index_offset;
    int deblocking_filter_control_present_flag;
    int constrained_intra_pred_flag;
    int redundant_pic_cnt_present_flag;

    // set iff we carry any of the optional headers
    int _more_rbsp_data_present;

    int transform_8x8_mode_flag;
    int pic_scaling_matrix_present_flag;
       int pic_scaling_list_present_flag[8];
       int* ScalingList4x4[6];
       int UseDefaultScalingMatrix4x4Flag[6];
       int* ScalingList8x8[2];
       int UseDefaultScalingMatrix8x8Flag[2];
    int second_chroma_qp_index_offset;
} pps_t;


/**
  Slice Header
  @see 7.3.3 Slice header syntax
  @see read_slice_header_rbsp
  @see write_slice_header_rbsp
  @see debug_slice_header_rbsp
*/
typedef struct
{
    int first_mb_in_slice;
    int slice_type;
    int pic_parameter_set_id;
    int frame_num;
    int field_pic_flag;
      int bottom_field_flag;
    int idr_pic_id;
    int pic_order_cnt_lsb;
    int delta_pic_order_cnt_bottom;
    int delta_pic_order_cnt[ 2 ];
    int redundant_pic_cnt;
    int direct_spatial_mv_pred_flag;
    int num_ref_idx_active_override_flag;
    int num_ref_idx_l0_active_minus1;
    int num_ref_idx_l1_active_minus1;
    int cabac_init_idc;
    int slice_qp_delta;
    int sp_for_switch_flag;
    int slice_qs_delta;
    int disable_deblocking_filter_idc;
    int slice_alpha_c0_offset_div2;
    int slice_beta_offset_div2;
    int slice_group_change_cycle;


    struct
    {
        int luma_log2_weight_denom;
        int chroma_log2_weight_denom;
        int luma_weight_l0_flag[64];
        int luma_weight_l0[64];
        int luma_offset_l0[64];
        int chroma_weight_l0_flag[64];
        int chroma_weight_l0[64][2];
        int chroma_offset_l0[64][2];
        int luma_weight_l1_flag[64];
        int luma_weight_l1[64];
        int luma_offset_l1[64];
        int chroma_weight_l1_flag[64];
        int chroma_weight_l1[64][2];
        int chroma_offset_l1[64][2];
    } pwt; // predictive weight table

    // TODO check max index
    // TODO array of structs instead of struct of arrays
    struct
    {
        int ref_pic_list_reordering_flag_l0;
        struct
        {
            int reordering_of_pic_nums_idc[64];
            int abs_diff_pic_num_minus1[64];
            int long_term_pic_num[64];
        } reorder_l0;
        int ref_pic_list_reordering_flag_l1;
        struct
        {
            int reordering_of_pic_nums_idc[64];
            int abs_diff_pic_num_minus1[64];
            int long_term_pic_num[64];
        } reorder_l1;
    } rplr; // ref pic list reorder

    struct
    {
        int no_output_of_prior_pics_flag;
        int long_term_reference_flag;
        int adaptive_ref_pic_marking_mode_flag;
        int memory_management_control_operation[64];
        int difference_of_pic_nums_minus1[64];
        int long_term_pic_num[64];
        int long_term_frame_idx[64];
        int max_long_term_frame_idx_plus1[64];
    } drpm; // decoded ref pic marking

} slice_header_t;


/**
   Access unit delimiter
   @see 7.3.1 NAL unit syntax
   @see read_nal_unit
   @see write_nal_unit
   @see debug_nal
*/
typedef struct
{
    int primary_pic_type;
} aud_t;

/**
   Network Abstraction Layer (NAL) unit
   @see 7.3.1 NAL unit syntax
   @see read_nal_unit
   @see write_nal_unit
   @see debug_nal
*/
typedef struct
{
    int forbidden_zero_bit;
    int nal_ref_idc;
    int nal_unit_type;
    void* parsed; // FIXME
    int sizeof_parsed;

    //uint8_t* rbsp_buf;
    //int rbsp_size;
} nal_t;

typedef struct
{
    int _is_initialized;
    int sps_id;
    int initial_cpb_removal_delay;
    int initial_cpb_delay_offset;
} sei_buffering_t;

typedef struct
{
    int clock_timestamp_flag;
        int ct_type;
        int nuit_field_based_flag;
        int counting_type;
        int full_timestamp_flag;
        int discontinuity_flag;
        int cnt_dropped_flag;
        int n_frames;

        int seconds_value;
        int minutes_value;
        int hours_value;

        int seconds_flag;
        int minutes_flag;
        int hours_flag;

        int time_offset;
} picture_timestamp_t;

typedef struct
{
  int _is_initialized;
  int cpb_removal_delay;
  int dpb_output_delay;
  int pic_struct;
  picture_timestamp_t clock_timestamps[3]; // 3 is the maximum possible value
} sei_picture_timing_t;


typedef struct
{
  int rbsp_size;
  uint8_t* rbsp_buf;
} slice_data_rbsp_t;

/**
   H264 stream
   Contains data structures for all NAL types that can be handled by this library.  
   When reading, data is read into those, and when writing it is written from those.  
   The reason why they are all contained in one place is that some of them depend on others, we need to 
   have all of them available to read or write correctly.
 */
typedef struct
{
    nal_t* nal;
    sps_t* sps;
    pps_t* pps;
    aud_t* aud;
    sei_t* sei; //This is a TEMP pointer at whats in h->seis...    
    int num_seis;
    slice_header_t* sh;
    slice_data_rbsp_t* slice_data;

    sps_t* sps_table[32];
    pps_t* pps_table[256];
    sei_t** seis;

} h264_stream_t;

h264_stream_t* h264_new();
void h264_free(h264_stream_t* h);

int find_nal_unit(uint8_t* buf, int size, int* nal_start, int* nal_end);

int rbsp_to_nal(const uint8_t* rbsp_buf, const int* rbsp_size, uint8_t* nal_buf, int* nal_size);
int nal_to_rbsp(const uint8_t* nal_buf, int* nal_size, uint8_t* rbsp_buf, int* rbsp_size);

int read_nal_unit(h264_stream_t* h, uint8_t* buf, int size);
int peek_nal_unit(h264_stream_t* h, uint8_t* buf, int size);

void read_seq_parameter_set_rbsp(h264_stream_t* h, bs_t* b);
void read_scaling_list(bs_t* b, int* scalingList, int sizeOfScalingList, int* useDefaultScalingMatrixFlag );
void read_vui_parameters(h264_stream_t* h, bs_t* b);
void read_hrd_parameters(h264_stream_t* h, bs_t* b);

void read_pic_parameter_set_rbsp(h264_stream_t* h, bs_t* b);

void read_sei_rbsp(h264_stream_t* h, bs_t* b);
void read_sei_message(h264_stream_t* h, bs_t* b);
void read_access_unit_delimiter_rbsp(h264_stream_t* h, bs_t* b);
void read_end_of_seq_rbsp(h264_stream_t* h, bs_t* b);
void read_end_of_stream_rbsp(h264_stream_t* h, bs_t* b);
void read_filler_data_rbsp(h264_stream_t* h, bs_t* b);

void read_slice_layer_rbsp(h264_stream_t* h, bs_t* b);
void read_rbsp_slice_trailing_bits(h264_stream_t* h, bs_t* b);
void read_rbsp_trailing_bits(h264_stream_t* h, bs_t* b);
void read_slice_header(h264_stream_t* h, bs_t* b);
void read_ref_pic_list_reordering(h264_stream_t* h, bs_t* b);
void read_pred_weight_table(h264_stream_t* h, bs_t* b);
void read_dec_ref_pic_marking(h264_stream_t* h, bs_t* b);

int more_rbsp_trailing_data(h264_stream_t* h, bs_t* b);

int write_nal_unit(h264_stream_t* h, uint8_t* buf, int size);

void write_seq_parameter_set_rbsp(h264_stream_t* h, bs_t* b);
void write_scaling_list(bs_t* b, int* scalingList, int sizeOfScalingList, int* useDefaultScalingMatrixFlag );
void write_vui_parameters(h264_stream_t* h, bs_t* b);
void write_hrd_parameters(h264_stream_t* h, bs_t* b);

void write_pic_parameter_set_rbsp(h264_stream_t* h, bs_t* b);

void write_sei_rbsp(h264_stream_t* h, bs_t* b);
void write_sei_message(h264_stream_t* h, bs_t* b);
void write_access_unit_delimiter_rbsp(h264_stream_t* h, bs_t* b);
void write_end_of_seq_rbsp(h264_stream_t* h, bs_t* b);
void write_end_of_stream_rbsp(h264_stream_t* h, bs_t* b);
void write_filler_data_rbsp(h264_stream_t* h, bs_t* b);

void write_slice_layer_rbsp(h264_stream_t* h, bs_t* b);
void write_rbsp_slice_trailing_bits(h264_stream_t* h, bs_t* b);
void write_rbsp_trailing_bits(h264_stream_t* h, bs_t* b);
void write_slice_header(h264_stream_t* h, bs_t* b);
void write_ref_pic_list_reordering(h264_stream_t* h, bs_t* b);
void write_pred_weight_table(h264_stream_t* h, bs_t* b);
void write_dec_ref_pic_marking(h264_stream_t* h, bs_t* b);

int read_debug_nal_unit(h264_stream_t* h, uint8_t* buf, int size);

void debug_sps(sps_t* sps);
void debug_pps(pps_t* pps);
void debug_slice_header(slice_header_t* sh);
void debug_nal(h264_stream_t* h, nal_t* nal);

void debug_bytes(uint8_t* buf, int len);

void read_sei_payload( h264_stream_t* h, bs_t* b, int payloadType, int payloadSize);
void write_sei_payload( h264_stream_t* h, bs_t* b, int payloadType, int payloadSize);

//NAL ref idc codes
#define NAL_REF_IDC_PRIORITY_HIGHEST    3
#define NAL_REF_IDC_PRIORITY_HIGH       2
#define NAL_REF_IDC_PRIORITY_LOW        1
#define NAL_REF_IDC_PRIORITY_DISPOSABLE 0

//Table 7-1 NAL unit type codes
#define NAL_UNIT_TYPE_UNSPECIFIED                    0    // Unspecified
#define NAL_UNIT_TYPE_CODED_SLICE_NON_IDR            1    // Coded slice of a non-IDR picture
#define NAL_UNIT_TYPE_CODED_SLICE_DATA_PARTITION_A   2    // Coded slice data partition A
#define NAL_UNIT_TYPE_CODED_SLICE_DATA_PARTITION_B   3    // Coded slice data partition B
#define NAL_UNIT_TYPE_CODED_SLICE_DATA_PARTITION_C   4    // Coded slice data partition C
#define NAL_UNIT_TYPE_CODED_SLICE_IDR                5    // Coded slice of an IDR picture
#define NAL_UNIT_TYPE_SEI                            6    // Supplemental enhancement information (SEI)
#define NAL_UNIT_TYPE_SPS                            7    // Sequence parameter set
#define NAL_UNIT_TYPE_PPS                            8    // Picture parameter set
#define NAL_UNIT_TYPE_AUD                            9    // Access unit delimiter
#define NAL_UNIT_TYPE_END_OF_SEQUENCE               10    // End of sequence
#define NAL_UNIT_TYPE_END_OF_STREAM                 11    // End of stream
#define NAL_UNIT_TYPE_FILLER                        12    // Filler data
#define NAL_UNIT_TYPE_SPS_EXT                       13    // Sequence parameter set extension
                                             // 14..18    // Reserved
#define NAL_UNIT_TYPE_CODED_SLICE_AUX               19    // Coded slice of an auxiliary coded picture without partitioning
                                             // 20..23    // Reserved
                                             // 24..31    // Unspecified

 

//7.4.3 Table 7-6. Name association to slice_type
#define SH_SLICE_TYPE_P        0        // P (P slice)
#define SH_SLICE_TYPE_B        1        // B (B slice)
#define SH_SLICE_TYPE_I        2        // I (I slice)
#define SH_SLICE_TYPE_SP       3        // SP (SP slice)
#define SH_SLICE_TYPE_SI       4        // SI (SI slice)
//as per footnote to Table 7-6, the *_ONLY slice types indicate that all other slices in that picture are of the same type
#define SH_SLICE_TYPE_P_ONLY    5        // P (P slice)
#define SH_SLICE_TYPE_B_ONLY    6        // B (B slice)
#define SH_SLICE_TYPE_I_ONLY    7        // I (I slice)
#define SH_SLICE_TYPE_SP_ONLY   8        // SP (SP slice)
#define SH_SLICE_TYPE_SI_ONLY   9        // SI (SI slice)

//Appendix E. Table E-1  Meaning of sample aspect ratio indicator
#define SAR_Unspecified  0           // Unspecified
#define SAR_1_1        1             //  1:1
#define SAR_12_11      2             // 12:11
#define SAR_10_11      3             // 10:11
#define SAR_16_11      4             // 16:11
#define SAR_40_33      5             // 40:33
#define SAR_24_11      6             // 24:11
#define SAR_20_11      7             // 20:11
#define SAR_32_11      8             // 32:11
#define SAR_80_33      9             // 80:33
#define SAR_18_11     10             // 18:11
#define SAR_15_11     11             // 15:11
#define SAR_64_33     12             // 64:33
#define SAR_160_99    13             // 160:99
                                     // 14..254           Reserved
#define SAR_Extended      255        // Extended_SAR

//7.4.3.1 Table 7-7 reordering_of_pic_nums_idc operations for reordering of reference picture lists
#define RPLR_IDC_ABS_DIFF_ADD       0
#define RPLR_IDC_ABS_DIFF_SUBTRACT  1
#define RPLR_IDC_LONG_TERM          2
#define RPLR_IDC_END                3

//7.4.3.3 Table 7-9 Memory management control operation (memory_management_control_operation) values
#define MMCO_END                     0
#define MMCO_SHORT_TERM_UNUSED       1
#define MMCO_LONG_TERM_UNUSED        2
#define MMCO_SHORT_TERM_TO_LONG_TERM 3
#define MMCO_LONG_TERM_MAX_INDEX     4
#define MMCO_ALL_UNUSED              5
#define MMCO_CURRENT_TO_LONG_TERM    6

//7.4.2.4 Table 7-5 Meaning of primary_pic_type
#define AUD_PRIMARY_PIC_TYPE_I       0                // I
#define AUD_PRIMARY_PIC_TYPE_IP      1                // I, P
#define AUD_PRIMARY_PIC_TYPE_IPB     2                // I, P, B
#define AUD_PRIMARY_PIC_TYPE_SI      3                // SI
#define AUD_PRIMARY_PIC_TYPE_SISP    4                // SI, SP
#define AUD_PRIMARY_PIC_TYPE_ISI     5                // I, SI
#define AUD_PRIMARY_PIC_TYPE_ISIPSP  6                // I, SI, P, SP
#define AUD_PRIMARY_PIC_TYPE_ISIPSPB 7                // I, SI, P, SP, B

#define H264_PROFILE_BASELINE  66
#define H264_PROFILE_MAIN      77
#define H264_PROFILE_EXTENDED  88
#define H264_PROFILE_HIGH     100

// file handle for debug output
extern FILE* h264_dbgfile;

#ifdef __cplusplus
}
#endif

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               moonlight-embedded-2.1.1/third_party/ilclient/                                                      0000775 0000000 0000000 00000000000 12563604362 0021405 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        moonlight-embedded-2.1.1/third_party/ilclient/ilclient.c                                            0000664 0000000 0000000 00000172336 12563604362 0023370 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * \file
 *
 * \brief This API defines helper functions for writing IL clients.
 *
 * This file defines an IL client side library.  This is useful when
 * writing IL clients, since there tends to be much repeated and
 * common code across both single and multiple clients.  This library
 * seeks to remove that common code and abstract some of the
 * interactions with components.  There is a wrapper around a
 * component and tunnel, and some operations can be done on lists of
 * these.  The callbacks from components are handled, and specific
 * events can be checked or waited for.
*/

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>

#include <interface/vcos/vcos.h>
#include <interface/vcos/vcos_logging.h>
#include <interface/vmcs_host/vchost.h>

#include <IL/OMX_Broadcom.h>
#include <ilclient.h>

#define VCOS_LOG_CATEGORY (&ilclient_log_category)

#ifndef ILCLIENT_THREAD_DEFAULT_STACK_SIZE
#define ILCLIENT_THREAD_DEFAULT_STACK_SIZE   (6<<10)
#endif

static VCOS_LOG_CAT_T ilclient_log_category;

/******************************************************************************
Static data and types used only in this file.
******************************************************************************/

struct _ILEVENT_T {
   OMX_EVENTTYPE eEvent;
   OMX_U32 nData1;
   OMX_U32 nData2;
   OMX_PTR pEventData;
   struct _ILEVENT_T *next;
};

#define NUM_EVENTS 100
struct _ILCLIENT_T {
   ILEVENT_T *event_list;
   VCOS_SEMAPHORE_T event_sema;
   ILEVENT_T event_rep[NUM_EVENTS];

   ILCLIENT_CALLBACK_T port_settings_callback;
   void *port_settings_callback_data;
   ILCLIENT_CALLBACK_T eos_callback;
   void *eos_callback_data;
   ILCLIENT_CALLBACK_T error_callback;
   void *error_callback_data;
   ILCLIENT_BUFFER_CALLBACK_T fill_buffer_done_callback;
   void *fill_buffer_done_callback_data;
   ILCLIENT_BUFFER_CALLBACK_T empty_buffer_done_callback;
   void *empty_buffer_done_callback_data;
   ILCLIENT_CALLBACK_T configchanged_callback;
   void *configchanged_callback_data;
};

struct _COMPONENT_T {
   OMX_HANDLETYPE comp;
   ILCLIENT_CREATE_FLAGS_T flags;
   VCOS_SEMAPHORE_T sema;
   VCOS_EVENT_FLAGS_T event;
   struct _COMPONENT_T *related;
   OMX_BUFFERHEADERTYPE *out_list;
   OMX_BUFFERHEADERTYPE *in_list;
   char name[32];
   char bufname[32];
   unsigned int error_mask;
   unsigned int private;
   ILEVENT_T *list;
   ILCLIENT_T *client;
};

#define random_wait()
static char *states[] = {"Invalid", "Loaded", "Idle", "Executing", "Pause", "WaitingForResources"};

typedef enum {
   ILCLIENT_ERROR_UNPOPULATED  = 0x1,
   ILCLIENT_ERROR_SAMESTATE    = 0x2,
   ILCLIENT_ERROR_BADPARAMETER = 0x4
} ILERROR_MASK_T;

/******************************************************************************
Static functions.
******************************************************************************/

static OMX_ERRORTYPE ilclient_empty_buffer_done(OMX_IN OMX_HANDLETYPE hComponent,
      OMX_IN OMX_PTR pAppData,
      OMX_IN OMX_BUFFERHEADERTYPE* pBuffer);
static OMX_ERRORTYPE ilclient_empty_buffer_done_error(OMX_IN OMX_HANDLETYPE hComponent,
      OMX_IN OMX_PTR pAppData,
      OMX_IN OMX_BUFFERHEADERTYPE* pBuffer);
static OMX_ERRORTYPE ilclient_fill_buffer_done(OMX_OUT OMX_HANDLETYPE hComponent,
      OMX_OUT OMX_PTR pAppData,
      OMX_OUT OMX_BUFFERHEADERTYPE* pBuffer);
static OMX_ERRORTYPE ilclient_fill_buffer_done_error(OMX_OUT OMX_HANDLETYPE hComponent,
      OMX_OUT OMX_PTR pAppData,
      OMX_OUT OMX_BUFFERHEADERTYPE* pBuffer);
static OMX_ERRORTYPE ilclient_event_handler(OMX_IN OMX_HANDLETYPE hComponent,
      OMX_IN OMX_PTR pAppData,
      OMX_IN OMX_EVENTTYPE eEvent,
      OMX_IN OMX_U32 nData1,
      OMX_IN OMX_U32 nData2,
      OMX_IN OMX_PTR pEventData);
static void ilclient_lock_events(ILCLIENT_T *st);
static void ilclient_unlock_events(ILCLIENT_T *st);

/******************************************************************************
Global functions
******************************************************************************/

/***********************************************************
 * Name: ilclient_init
 *
 * Description: Creates ilclient pointer
 *
 * Returns: pointer to client structure
 ***********************************************************/
ILCLIENT_T *ilclient_init()
{
   ILCLIENT_T *st = vcos_malloc(sizeof(ILCLIENT_T), "ilclient");
   int i;
   
   if (!st)
      return NULL;
   
   vcos_log_set_level(VCOS_LOG_CATEGORY, VCOS_LOG_WARN);
   vcos_log_register("ilclient", VCOS_LOG_CATEGORY);

   memset(st, 0, sizeof(ILCLIENT_T));

   i = vcos_semaphore_create(&st->event_sema, "il:event", 1);
   vc_assert(i == VCOS_SUCCESS);

   ilclient_lock_events(st);
   st->event_list = NULL;
   for (i=0; i<NUM_EVENTS; i++)
   {
      st->event_rep[i].eEvent = -1; // mark as unused
      st->event_rep[i].next = st->event_list;
      st->event_list = st->event_rep+i;
   }
   ilclient_unlock_events(st);
   return st;
}

/***********************************************************
 * Name: ilclient_destroy
 *
 * Description: frees client state
 *
 * Returns: void
 ***********************************************************/
void ilclient_destroy(ILCLIENT_T *st)
{
   vcos_semaphore_delete(&st->event_sema);
   vcos_free(st);
   vcos_log_unregister(VCOS_LOG_CATEGORY);
}

/***********************************************************
 * Name: ilclient_set_port_settings_callback
 *
 * Description: sets the callback used when receiving port settings
 * changed messages.  The data field in the callback function will be
 * the port index reporting the message.
 *
 * Returns: void
 ***********************************************************/
void ilclient_set_port_settings_callback(ILCLIENT_T *st, ILCLIENT_CALLBACK_T func, void *userdata)
{
   st->port_settings_callback = func;
   st->port_settings_callback_data = userdata;
}

/***********************************************************
 * Name: ilclient_set_eos_callback
 *
 * Description: sets the callback used when receiving eos flags.  The
 * data parameter in the callback function will be the port index
 * reporting an eos flag.
 *
 * Returns: void
 ***********************************************************/
void ilclient_set_eos_callback(ILCLIENT_T *st, ILCLIENT_CALLBACK_T func, void *userdata)
{
   st->eos_callback = func;
   st->eos_callback_data = userdata;
}

/***********************************************************
 * Name: ilclient_set_error_callback
 *
 * Description: sets the callback used when receiving error events.
 * The data parameter in the callback function will be the error code
 * being reported.
 *
 * Returns: void
 ***********************************************************/
void ilclient_set_error_callback(ILCLIENT_T *st, ILCLIENT_CALLBACK_T func, void *userdata)
{
   st->error_callback = func;
   st->error_callback_data = userdata;
}

/***********************************************************
 * Name: ilclient_set_fill_buffer_done_callback
 *
 * Description: sets the callback used when receiving
 * fill_buffer_done event
 *
 * Returns: void
 ***********************************************************/
void ilclient_set_fill_buffer_done_callback(ILCLIENT_T *st, ILCLIENT_BUFFER_CALLBACK_T func, void *userdata)
{
   st->fill_buffer_done_callback = func;
   st->fill_buffer_done_callback_data = userdata;
}

/***********************************************************
 * Name: ilclient_set_empty_buffer_done_callback
 *
 * Description: sets the callback used when receiving
 * empty_buffer_done event
 *
 * Returns: void
 ***********************************************************/
void ilclient_set_empty_buffer_done_callback(ILCLIENT_T *st, ILCLIENT_BUFFER_CALLBACK_T func, void *userdata)
{
   st->empty_buffer_done_callback = func;
   st->empty_buffer_done_callback_data = userdata;
}

/***********************************************************
 * Name: ilclient_set_configchanged_callback
 *
 * Description: sets the callback used when a config changed
 * event is received
 *
 * Returns: void
 ***********************************************************/
void ilclient_set_configchanged_callback(ILCLIENT_T *st, ILCLIENT_CALLBACK_T func, void *userdata)
{
   st->configchanged_callback = func;
   st->configchanged_callback_data = userdata;
}

/***********************************************************
 * Name: ilclient_create_component
 *
 * Description: initialises a component state structure and creates
 * the IL component.
 *
 * Returns: 0 on success, -1 on failure
 ***********************************************************/
int ilclient_create_component(ILCLIENT_T *client, COMPONENT_T **comp, char *name,
                              ILCLIENT_CREATE_FLAGS_T flags)
{
   OMX_CALLBACKTYPE callbacks;
   OMX_ERRORTYPE error;
   char component_name[128];
   int32_t status;

   *comp = vcos_malloc(sizeof(COMPONENT_T), "il:comp");
   if(!*comp)
      return -1;

   memset(*comp, 0, sizeof(COMPONENT_T));

#define COMP_PREFIX "OMX.broadcom."

   status = vcos_event_flags_create(&(*comp)->event,"il:comp");
   vc_assert(status == VCOS_SUCCESS);
   status = vcos_semaphore_create(&(*comp)->sema, "il:comp", 1);
   vc_assert(status == VCOS_SUCCESS);
   (*comp)->client = client;

   vcos_snprintf((*comp)->name, sizeof((*comp)->name), "cl:%s", name);
   vcos_snprintf((*comp)->bufname, sizeof((*comp)->bufname), "cl:%s buffer", name);
   vcos_snprintf(component_name, sizeof(component_name), "%s%s", COMP_PREFIX, name);

   (*comp)->flags = flags;

   callbacks.EventHandler = ilclient_event_handler;
   callbacks.EmptyBufferDone = flags & ILCLIENT_ENABLE_INPUT_BUFFERS ? ilclient_empty_buffer_done : ilclient_empty_buffer_done_error;
   callbacks.FillBufferDone = flags & ILCLIENT_ENABLE_OUTPUT_BUFFERS ? ilclient_fill_buffer_done : ilclient_fill_buffer_done_error;

   error = OMX_GetHandle(&(*comp)->comp, component_name, *comp, &callbacks);

   if (error == OMX_ErrorNone)
   {
      OMX_UUIDTYPE uid;
      char name[128];
      OMX_VERSIONTYPE compVersion, specVersion;

      if(OMX_GetComponentVersion((*comp)->comp, name, &compVersion, &specVersion, &uid) == OMX_ErrorNone)
      {
         char *p = (char *) uid + strlen(COMP_PREFIX);

         vcos_snprintf((*comp)->name, sizeof((*comp)->name), "cl:%s", p);
         (*comp)->name[sizeof((*comp)->name)-1] = 0;
         vcos_snprintf((*comp)->bufname, sizeof((*comp)->bufname), "cl:%s buffer", p);
         (*comp)->bufname[sizeof((*comp)->bufname)-1] = 0;
      }

      if(flags & (ILCLIENT_DISABLE_ALL_PORTS | ILCLIENT_OUTPUT_ZERO_BUFFERS))
      {
         OMX_PORT_PARAM_TYPE ports;
         OMX_INDEXTYPE types[] = {OMX_IndexParamAudioInit, OMX_IndexParamVideoInit, OMX_IndexParamImageInit, OMX_IndexParamOtherInit};
         int i;

         ports.nSize = sizeof(OMX_PORT_PARAM_TYPE);
         ports.nVersion.nVersion = OMX_VERSION;

         for(i=0; i<4; i++)
         {
            OMX_ERRORTYPE error = OMX_GetParameter((*comp)->comp, types[i], &ports);
            if(error == OMX_ErrorNone)
            {
               uint32_t j;
               for(j=0; j<ports.nPorts; j++)
               {
                  if(flags & ILCLIENT_DISABLE_ALL_PORTS)
                     ilclient_disable_port(*comp, ports.nStartPortNumber+j);
                  
                  if(flags & ILCLIENT_OUTPUT_ZERO_BUFFERS)
                  {
                     OMX_PARAM_PORTDEFINITIONTYPE portdef;
                     portdef.nSize = sizeof(OMX_PARAM_PORTDEFINITIONTYPE);
                     portdef.nVersion.nVersion = OMX_VERSION;
                     portdef.nPortIndex = ports.nStartPortNumber+j;
                     if(OMX_GetParameter((*comp)->comp, OMX_IndexParamPortDefinition, &portdef) == OMX_ErrorNone)
                     {
                        if(portdef.eDir == OMX_DirOutput && portdef.nBufferCountActual > 0)
                        {
                           portdef.nBufferCountActual = 0;
                           OMX_SetParameter((*comp)->comp, OMX_IndexParamPortDefinition, &portdef);
                        }
                     }
                  }
               }
            }
         }
      }
      return 0;
   }
   else
   {
      vcos_event_flags_delete(&(*comp)->event);
      vcos_semaphore_delete(&(*comp)->sema);
      vcos_free(*comp);
      *comp = NULL;
      return -1;
   }
}

/***********************************************************
 * Name: ilclient_remove_event
 *
 * Description: Removes an event from a component event list.  ignore1
 * and ignore2 are flags indicating whether to not match on nData1 and
 * nData2 respectively.
 *
 * Returns: 0 if the event was removed.  -1 if no matching event was
 * found.
 ***********************************************************/
int ilclient_remove_event(COMPONENT_T *st, OMX_EVENTTYPE eEvent,
                          OMX_U32 nData1, int ignore1, OMX_IN OMX_U32 nData2, int ignore2)
{
   ILEVENT_T *cur, *prev;
   uint32_t set;
   ilclient_lock_events(st->client);

   cur = st->list;
   prev = NULL;

   while (cur && !(cur->eEvent == eEvent && (ignore1 || cur->nData1 == nData1) && (ignore2 || cur->nData2 == nData2)))
   {
      prev = cur;
      cur = cur->next;
   }

   if (cur == NULL)
   {
      ilclient_unlock_events(st->client);
      return -1;
   }

   if (prev == NULL)
      st->list = cur->next;
   else
      prev->next = cur->next;

   // add back into spare list
   cur->next = st->client->event_list;
   st->client->event_list = cur;
   cur->eEvent = -1; // mark as unused

   // if we're removing an OMX_EventError or OMX_EventParamOrConfigChanged event, then clear the error bit from the eventgroup,
   // since the user might have been notified through the error callback, and then 
   // can't clear the event bit - this will then cause problems the next time they
   // wait for an error.
   if(eEvent == OMX_EventError)
      vcos_event_flags_get(&st->event, ILCLIENT_EVENT_ERROR, VCOS_OR_CONSUME, 0, &set);
   else if(eEvent == OMX_EventParamOrConfigChanged)
      vcos_event_flags_get(&st->event, ILCLIENT_CONFIG_CHANGED, VCOS_OR_CONSUME, 0, &set);

   ilclient_unlock_events(st->client);
   return 0;
}

/***********************************************************
 * Name: ilclient_state_transition
 *
 * Description: Transitions a null terminated list of IL components to
 * a given state.  All components are told to transition in a random
 * order before any are checked for transition completion.
 *
 * Returns: void
 ***********************************************************/
void ilclient_state_transition(COMPONENT_T *list[], OMX_STATETYPE state)
{
   OMX_ERRORTYPE error;
   int i, num;
   uint32_t set;

   num=0;
   while (list[num])
      num++;

   // if we transition the supplier port first, it will call freebuffer on the non
   // supplier, which will correctly signal a port unpopulated error.  We want to
   // ignore these errors.
   if (state == OMX_StateLoaded)
      for (i=0; i<num; i++)
         list[i]->error_mask |= ILCLIENT_ERROR_UNPOPULATED;
   for (i=0; i<num; i++)
      list[i]->private = ((rand() >> 13) & 0xff)+1;

   for (i=0; i<num; i++)
   {
      // transition the components in a random order
      int j, min = -1;
      for (j=0; j<num; j++)
         if (list[j]->private && (min == -1 || list[min]->private > list[j]->private))
            min = j;

      list[min]->private = 0;

      random_wait();
      //Clear error event for this component
      vcos_event_flags_get(&list[min]->event, ILCLIENT_EVENT_ERROR, VCOS_OR_CONSUME, 0, &set);

      error = OMX_SendCommand(list[min]->comp, OMX_CommandStateSet, state, NULL);
      vc_assert(error == OMX_ErrorNone);
   }

   random_wait();

   for (i=0; i<num; i++)
      if(ilclient_wait_for_command_complete(list[i], OMX_CommandStateSet, state) < 0)
         vc_assert(0);

   if (state == OMX_StateLoaded)
      for (i=0; i<num; i++)
         list[i]->error_mask &= ~ILCLIENT_ERROR_UNPOPULATED;
}

/***********************************************************
 * Name: ilclient_teardown_tunnels
 *
 * Description: tears down a null terminated list of tunnels.
 *
 * Returns: void
 ***********************************************************/
void ilclient_teardown_tunnels(TUNNEL_T *tunnel)
{
   int i;
   OMX_ERRORTYPE error;

   i=0;;
   while (tunnel[i].source)
   {
      error = OMX_SetupTunnel(tunnel[i].source->comp, tunnel[i].source_port, NULL, 0);
      vc_assert(error == OMX_ErrorNone);

      error = OMX_SetupTunnel(tunnel[i].sink->comp, tunnel[i].sink_port, NULL, 0);
      vc_assert(error == OMX_ErrorNone);
      i++;
   }
}

/***********************************************************
 * Name: ilclient_disable_tunnel
 *
 * Description: disables a tunnel by disabling the ports.  Allows
 * ports to signal same state error if they were already disabled.
 *
 * Returns: void
 ***********************************************************/
void ilclient_disable_tunnel(TUNNEL_T *tunnel)
{
   OMX_ERRORTYPE error;
   
   if(tunnel->source == 0 || tunnel->sink == 0)
      return;

   tunnel->source->error_mask |= ILCLIENT_ERROR_UNPOPULATED;
   tunnel->sink->error_mask |= ILCLIENT_ERROR_UNPOPULATED;

   error = OMX_SendCommand(tunnel->source->comp, OMX_CommandPortDisable, tunnel->source_port, NULL);
   vc_assert(error == OMX_ErrorNone);

   error = OMX_SendCommand(tunnel->sink->comp, OMX_CommandPortDisable, tunnel->sink_port, NULL);
   vc_assert(error == OMX_ErrorNone);

   if(ilclient_wait_for_command_complete(tunnel->source, OMX_CommandPortDisable, tunnel->source_port) < 0)
      vc_assert(0);

   if(ilclient_wait_for_command_complete(tunnel->sink, OMX_CommandPortDisable, tunnel->sink_port) < 0)
      vc_assert(0);

   tunnel->source->error_mask &= ~ILCLIENT_ERROR_UNPOPULATED;
   tunnel->sink->error_mask &= ~ILCLIENT_ERROR_UNPOPULATED;
}

/***********************************************************
 * Name: ilclient_enable_tunnel
 *
 * Description: enables a tunnel by enabling the ports
 *
 * Returns: 0 on success, -1 on failure
 ***********************************************************/
int ilclient_enable_tunnel(TUNNEL_T *tunnel)
{
   OMX_STATETYPE state;
   OMX_ERRORTYPE error;

   ilclient_debug_output("ilclient: enable tunnel from %x/%d to %x/%d",
                         tunnel->source, tunnel->source_port,
                         tunnel->sink, tunnel->sink_port);

   error = OMX_SendCommand(tunnel->source->comp, OMX_CommandPortEnable, tunnel->source_port, NULL);
   vc_assert(error == OMX_ErrorNone);

   error = OMX_SendCommand(tunnel->sink->comp, OMX_CommandPortEnable, tunnel->sink_port, NULL);
   vc_assert(error == OMX_ErrorNone);

   // to complete, the sink component can't be in loaded state
   error = OMX_GetState(tunnel->sink->comp, &state);
   vc_assert(error == OMX_ErrorNone);
   if (state == OMX_StateLoaded)
   {
      int ret = 0;

      if(ilclient_wait_for_command_complete(tunnel->sink, OMX_CommandPortEnable, tunnel->sink_port) != 0 ||
         OMX_SendCommand(tunnel->sink->comp, OMX_CommandStateSet, OMX_StateIdle, NULL) != OMX_ErrorNone ||
         (ret = ilclient_wait_for_command_complete_dual(tunnel->sink, OMX_CommandStateSet, OMX_StateIdle, tunnel->source)) < 0)
      {
         if(ret == -2)
         {
            // the error was reported fom the source component: clear this error and disable the sink component
            ilclient_wait_for_command_complete(tunnel->source, OMX_CommandPortEnable, tunnel->source_port);
            ilclient_disable_port(tunnel->sink, tunnel->sink_port);
         }

         ilclient_debug_output("ilclient: could not change component state to IDLE");
         ilclient_disable_port(tunnel->source, tunnel->source_port);
         return -1;
      }
   }
   else
   {
      if (ilclient_wait_for_command_complete(tunnel->sink, OMX_CommandPortEnable, tunnel->sink_port) != 0)
      {
         ilclient_debug_output("ilclient: could not change sink port %d to enabled", tunnel->sink_port);

         //Oops failed to enable the sink port
         ilclient_disable_port(tunnel->source, tunnel->source_port);
         //Clean up the port enable event from the source port.
         ilclient_wait_for_event(tunnel->source, OMX_EventCmdComplete,
                                 OMX_CommandPortEnable, 0, tunnel->source_port, 0,
                                 ILCLIENT_PORT_ENABLED | ILCLIENT_EVENT_ERROR, VCOS_EVENT_FLAGS_SUSPEND);
         return -1;
      }
   }

   if(ilclient_wait_for_command_complete(tunnel->source, OMX_CommandPortEnable, tunnel->source_port) != 0)
   {
      ilclient_debug_output("ilclient: could not change source port %d to enabled", tunnel->source_port);

      //Failed to enable the source port
      ilclient_disable_port(tunnel->sink, tunnel->sink_port);
      return -1;
   }

   return 0;
}


/***********************************************************
 * Name: ilclient_flush_tunnels
 *
 * Description: flushes all ports used in a null terminated list of
 * tunnels.  max specifies the maximum number of tunnels to flush from
 * the list, where max=0 means all tunnels.
 *
 * Returns: void
 ***********************************************************/
void ilclient_flush_tunnels(TUNNEL_T *tunnel, int max)
{
   OMX_ERRORTYPE error;
   int i;

   i=0;
   while (tunnel[i].source && (max == 0 || i < max))
   {
      error = OMX_SendCommand(tunnel[i].source->comp, OMX_CommandFlush, tunnel[i].source_port, NULL);
      vc_assert(error == OMX_ErrorNone);

      error = OMX_SendCommand(tunnel[i].sink->comp, OMX_CommandFlush, tunnel[i].sink_port, NULL);
      vc_assert(error == OMX_ErrorNone);

      ilclient_wait_for_event(tunnel[i].source, OMX_EventCmdComplete,
                              OMX_CommandFlush, 0, tunnel[i].source_port, 0,
                              ILCLIENT_PORT_FLUSH, VCOS_EVENT_FLAGS_SUSPEND);
      ilclient_wait_for_event(tunnel[i].sink, OMX_EventCmdComplete,
                              OMX_CommandFlush, 0, tunnel[i].sink_port, 0,
                              ILCLIENT_PORT_FLUSH, VCOS_EVENT_FLAGS_SUSPEND);
      i++;
   }
}


/***********************************************************
 * Name: ilclient_return_events
 *
 * Description: Returns all events from a component event list to the
 * list of unused event structures.
 *
 * Returns: void
 ***********************************************************/
void ilclient_return_events(COMPONENT_T *comp)
{
   ilclient_lock_events(comp->client);
   while (comp->list)
   {
      ILEVENT_T *next = comp->list->next;
      comp->list->next = comp->client->event_list;
      comp->client->event_list = comp->list;
      comp->list = next;
   }
   ilclient_unlock_events(comp->client);
}

/***********************************************************
 * Name: ilclient_cleanup_components
 *
 * Description: frees all components from a null terminated list and
 * deletes resources used in component state structure.
 *
 * Returns: void
 ***********************************************************/
void ilclient_cleanup_components(COMPONENT_T *list[])
{
   int i;
   OMX_ERRORTYPE error;

   i=0;
   while (list[i])
   {
      ilclient_return_events(list[i]);
      if (list[i]->comp)
      {
         error = OMX_FreeHandle(list[i]->comp);

         vc_assert(error == OMX_ErrorNone);
      }
      i++;
   }

   i=0;
   while (list[i])
   {
      vcos_event_flags_delete(&list[i]->event);
      vcos_semaphore_delete(&list[i]->sema);
      vcos_free(list[i]);
      list[i] = NULL;
      i++;
   }
}

/***********************************************************
 * Name: ilclient_change_component_state
 *
 * Description: changes the state of a single component.  Note: this
 * may not be suitable if the component is tunnelled and requires
 * connected components to also change state.
 *
 * Returns: 0 on success, -1 on failure (note - trying to change to
 * the same state which causes a OMX_ErrorSameState is treated as
 * success)
 ***********************************************************/
int ilclient_change_component_state(COMPONENT_T *comp, OMX_STATETYPE state)
{
   OMX_ERRORTYPE error;
   error = OMX_SendCommand(comp->comp, OMX_CommandStateSet, state, NULL);
   vc_assert(error == OMX_ErrorNone);
   if(ilclient_wait_for_command_complete(comp, OMX_CommandStateSet, state) < 0)
   {
      ilclient_debug_output("ilclient: could not change component state to %d", state);
      ilclient_remove_event(comp, OMX_EventError, 0, 1, 0, 1);
      return -1;
   }
   return 0;
}

/***********************************************************
 * Name: ilclient_disable_port
 *
 * Description: disables a port on a given component.
 *
 * Returns: void
 ***********************************************************/
void ilclient_disable_port(COMPONENT_T *comp, int portIndex)
{
   OMX_ERRORTYPE error;
   error = OMX_SendCommand(comp->comp, OMX_CommandPortDisable, portIndex, NULL);
   vc_assert(error == OMX_ErrorNone);
   if(ilclient_wait_for_command_complete(comp, OMX_CommandPortDisable, portIndex) < 0)
      vc_assert(0);
}

/***********************************************************
 * Name: ilclient_enabled_port
 *
 * Description: enables a port on a given component.
 *
 * Returns: void
 ***********************************************************/
void ilclient_enable_port(COMPONENT_T *comp, int portIndex)
{
   OMX_ERRORTYPE error;
   error = OMX_SendCommand(comp->comp, OMX_CommandPortEnable, portIndex, NULL);
   vc_assert(error == OMX_ErrorNone);
   if(ilclient_wait_for_command_complete(comp, OMX_CommandPortEnable, portIndex) < 0)
      vc_assert(0);
}


/***********************************************************
 * Name: ilclient_enable_port_buffers
 *
 * Description: enables a port on a given component which requires
 * buffers to be supplied by the client.
 *
 * Returns: void
 ***********************************************************/
int ilclient_enable_port_buffers(COMPONENT_T *comp, int portIndex,
                                 ILCLIENT_MALLOC_T ilclient_malloc,
                                 ILCLIENT_FREE_T ilclient_free,
                                 void *private)
{
   OMX_ERRORTYPE error;
   OMX_PARAM_PORTDEFINITIONTYPE portdef;
   OMX_BUFFERHEADERTYPE *list = NULL, **end = &list;
   OMX_STATETYPE state;
   int i;

   memset(&portdef, 0, sizeof(OMX_PARAM_PORTDEFINITIONTYPE));
   portdef.nSize = sizeof(OMX_PARAM_PORTDEFINITIONTYPE);
   portdef.nVersion.nVersion = OMX_VERSION;
   portdef.nPortIndex = portIndex;
   
   // work out buffer requirements, check port is in the right state
   error = OMX_GetParameter(comp->comp, OMX_IndexParamPortDefinition, &portdef);
   if(error != OMX_ErrorNone || portdef.bEnabled != OMX_FALSE || portdef.nBufferCountActual == 0 || portdef.nBufferSize == 0)
      return -1;

   // check component is in the right state to accept buffers
   error = OMX_GetState(comp->comp, &state);
   if (error != OMX_ErrorNone || !(state == OMX_StateIdle || state == OMX_StateExecuting || state == OMX_StatePause))
      return -1;

   // send the command
   error = OMX_SendCommand(comp->comp, OMX_CommandPortEnable, portIndex, NULL);
   vc_assert(error == OMX_ErrorNone);

   for (i=0; i != portdef.nBufferCountActual; i++)
   {
      unsigned char *buf;
      if(ilclient_malloc)
         buf = ilclient_malloc(private, portdef.nBufferSize, portdef.nBufferAlignment, comp->bufname);
      else
         buf = vcos_malloc_aligned(portdef.nBufferSize, portdef.nBufferAlignment, comp->bufname);

      if(!buf)
         break;

      error = OMX_UseBuffer(comp->comp, end, portIndex, NULL, portdef.nBufferSize, buf);
      if(error != OMX_ErrorNone)
      {
         if(ilclient_free)
            ilclient_free(private, buf);
         else
            vcos_free(buf);

         break;
      }
      end = (OMX_BUFFERHEADERTYPE **) &((*end)->pAppPrivate);
   }

   // queue these buffers
   vcos_semaphore_wait(&comp->sema);

   if(portdef.eDir == OMX_DirInput)
   {
      *end = comp->in_list;
      comp->in_list = list;
   }
   else
   {
      *end = comp->out_list;
      comp->out_list = list;
   }

   vcos_semaphore_post(&comp->sema);

   if(i != portdef.nBufferCountActual ||
      ilclient_wait_for_command_complete(comp, OMX_CommandPortEnable, portIndex) < 0)
   {
      ilclient_disable_port_buffers(comp, portIndex, NULL, ilclient_free, private);

      // at this point the first command might have terminated with an error, which means that
      // the port is disabled before the disable_port_buffers function is called, so we're left
      // with the error bit set and an error event in the queue.  Clear these now if they exist.
      ilclient_remove_event(comp, OMX_EventError, 0, 1, 1, 0);

      return -1;
   }

   // success
   return 0;
}


/***********************************************************
 * Name: ilclient_disable_port_buffers
 *
 * Description: disables a port on a given component which has
 * buffers supplied by the client.
 *
 * Returns: void
 ***********************************************************/
void ilclient_disable_port_buffers(COMPONENT_T *comp, int portIndex,
                                   OMX_BUFFERHEADERTYPE *bufferList,
                                   ILCLIENT_FREE_T ilclient_free,
                                   void *private)
{
   OMX_ERRORTYPE error;
   OMX_BUFFERHEADERTYPE *list = bufferList;
   OMX_BUFFERHEADERTYPE **head, *clist, *prev;
   OMX_PARAM_PORTDEFINITIONTYPE portdef;
   int num;

   // get the buffers off the relevant queue
   memset(&portdef, 0, sizeof(OMX_PARAM_PORTDEFINITIONTYPE));
   portdef.nSize = sizeof(OMX_PARAM_PORTDEFINITIONTYPE);
   portdef.nVersion.nVersion = OMX_VERSION;
   portdef.nPortIndex = portIndex;
   
   // work out buffer requirements, check port is in the right state
   error = OMX_GetParameter(comp->comp, OMX_IndexParamPortDefinition, &portdef);
   if(error != OMX_ErrorNone || portdef.bEnabled != OMX_TRUE || portdef.nBufferCountActual == 0 || portdef.nBufferSize == 0)
      return;
   
   num = portdef.nBufferCountActual;
   
   error = OMX_SendCommand(comp->comp, OMX_CommandPortDisable, portIndex, NULL);
   vc_assert(error == OMX_ErrorNone);
      
   while(num > 0)
   {
      VCOS_UNSIGNED set;

      if(list == NULL)
      {
         vcos_semaphore_wait(&comp->sema);
         
         // take buffers for this port off the relevant queue
         head = portdef.eDir == OMX_DirInput ? &comp->in_list : &comp->out_list;
         clist = *head;
         prev = NULL;
         
         while(clist)
         {
            if((portdef.eDir == OMX_DirInput ? clist->nInputPortIndex : clist->nOutputPortIndex) == portIndex)
            {
               OMX_BUFFERHEADERTYPE *pBuffer = clist;
               
               if(!prev)
                  clist = *head = (OMX_BUFFERHEADERTYPE *) pBuffer->pAppPrivate;
               else
                  clist = prev->pAppPrivate = (OMX_BUFFERHEADERTYPE *) pBuffer->pAppPrivate;
               
               pBuffer->pAppPrivate = list;
               list = pBuffer;
            }
            else
            {
               prev = clist;
               clist = (OMX_BUFFERHEADERTYPE *) &(clist->pAppPrivate);
            }
         }
         
         vcos_semaphore_post(&comp->sema);
      }

      while(list)
      {
         void *buf = list->pBuffer;
         OMX_BUFFERHEADERTYPE *next = list->pAppPrivate;
         
         error = OMX_FreeBuffer(comp->comp, portIndex, list);
         vc_assert(error == OMX_ErrorNone);
         
         if(ilclient_free)
            ilclient_free(private, buf);
         else
            vcos_free(buf);
         
         num--;
         list = next;
      }

      if(num)
      {
         OMX_U32 mask = ILCLIENT_PORT_DISABLED | ILCLIENT_EVENT_ERROR;
         mask |= (portdef.eDir == OMX_DirInput ? ILCLIENT_EMPTY_BUFFER_DONE : ILCLIENT_FILL_BUFFER_DONE);

         // also wait for command complete/error in case we didn't have all the buffers allocated
         vcos_event_flags_get(&comp->event, mask, VCOS_OR_CONSUME, -1, &set);

         if((set & ILCLIENT_EVENT_ERROR) && ilclient_remove_event(comp, OMX_EventError, 0, 1, 1, 0) >= 0)
            return;

         if((set & ILCLIENT_PORT_DISABLED) && ilclient_remove_event(comp, OMX_EventCmdComplete, OMX_CommandPortDisable, 0, portIndex, 0) >= 0)
            return;
      }            
   }
  
   if(ilclient_wait_for_command_complete(comp, OMX_CommandPortDisable, portIndex) < 0)
      vc_assert(0);
}


/***********************************************************
 * Name: ilclient_setup_tunnel
 *
 * Description: creates a tunnel between components that require that
 * ports be inititially disabled, then enabled after tunnel setup.  If
 * timeout is non-zero, it will initially wait until a port settings
 * changes message has been received by the output port.  If port
 * streams are supported by the output port, the requested port stream
 * will be selected.
 *
 * Returns: 0 indicates success, negative indicates failure.
 * -1: a timeout waiting for the parameter changed
 * -2: an error was returned instead of parameter changed
 * -3: no streams are available from this port
 * -4: requested stream is not available from this port
 * -5: the data format was not acceptable to the sink
 ***********************************************************/
int ilclient_setup_tunnel(TUNNEL_T *tunnel, unsigned int portStream, int timeout)
{
   OMX_ERRORTYPE error;
   OMX_PARAM_U32TYPE param;
   OMX_STATETYPE state;
   int32_t status;
   int enable_error;

   // source component must at least be idle, not loaded
   error = OMX_GetState(tunnel->source->comp, &state);
   vc_assert(error == OMX_ErrorNone);
   if (state == OMX_StateLoaded && ilclient_change_component_state(tunnel->source, OMX_StateIdle) < 0)
      return -2;

   // wait for the port parameter changed from the source port
   if(timeout)
   {
      status = ilclient_wait_for_event(tunnel->source, OMX_EventPortSettingsChanged,
                                       tunnel->source_port, 0, -1, 1,
                                       ILCLIENT_PARAMETER_CHANGED | ILCLIENT_EVENT_ERROR, timeout);
      
      if (status < 0)
      {
         ilclient_debug_output(
            "ilclient: timed out waiting for port settings changed on port %d", tunnel->source_port);
         return status;
      }
   }

   // disable ports
   ilclient_disable_tunnel(tunnel);

   // if this source port uses port streams, we need to select one of them before proceeding
   // if getparameter causes an error that's fine, nothing needs selecting
   param.nSize = sizeof(OMX_PARAM_U32TYPE);
   param.nVersion.nVersion = OMX_VERSION;
   param.nPortIndex = tunnel->source_port;
   if (OMX_GetParameter(tunnel->source->comp, OMX_IndexParamNumAvailableStreams, &param) == OMX_ErrorNone)
   {
      if (param.nU32 == 0)
      {
         // no streams available
         // leave the source port disabled, and return a failure
         return -3;
      }
      if (param.nU32 <= portStream)
      {
         // requested stream not available
         // no streams available
         // leave the source port disabled, and return a failure
         return -4;
      }

      param.nU32 = portStream;
      error = OMX_SetParameter(tunnel->source->comp, OMX_IndexParamActiveStream, &param);
      vc_assert(error == OMX_ErrorNone);
   }

   // now create the tunnel
   error = OMX_SetupTunnel(tunnel->source->comp, tunnel->source_port, tunnel->sink->comp, tunnel->sink_port);

   enable_error = 0;

   if (error != OMX_ErrorNone || (enable_error=ilclient_enable_tunnel(tunnel)) < 0)
   {
      // probably format not compatible
      error = OMX_SetupTunnel(tunnel->source->comp, tunnel->source_port, NULL, 0);
      vc_assert(error == OMX_ErrorNone);
      error = OMX_SetupTunnel(tunnel->sink->comp, tunnel->sink_port, NULL, 0);
      vc_assert(error == OMX_ErrorNone);
      
      if(enable_error)
      {
         //Clean up the errors. This does risk removing an error that was nothing to do with this tunnel :-/
         ilclient_remove_event(tunnel->sink, OMX_EventError, 0, 1, 0, 1);
         ilclient_remove_event(tunnel->source, OMX_EventError, 0, 1, 0, 1);
      }

      ilclient_debug_output("ilclient: could not setup/enable tunnel (setup=0x%x,enable=%d)",
                             error, enable_error);
      return -5;
   }

   return 0;
}

/***********************************************************
 * Name: ilclient_wait_for_event
 *
 * Description: waits for a given event to appear on a component event
 * list.  If not immediately present, will wait on that components
 * event group for the given event flag.
 *
 * Returns: 0 indicates success, negative indicates failure.
 * -1: a timeout was received.
 * -2: an error event was received.
 * -3: a config change event was received.
 ***********************************************************/
int ilclient_wait_for_event(COMPONENT_T *comp, OMX_EVENTTYPE event,
                            OMX_U32 nData1, int ignore1, OMX_IN OMX_U32 nData2, int ignore2,
                            int event_flag, int suspend)
{
   int32_t status;
   uint32_t set;

   while (ilclient_remove_event(comp, event, nData1, ignore1, nData2, ignore2) < 0)
   {
      // if we want to be notified of errors, check the list for an error now
      // before blocking, the event flag may have been cleared already.
      if(event_flag & ILCLIENT_EVENT_ERROR)
      {
         ILEVENT_T *cur;
         ilclient_lock_events(comp->client);
         cur = comp->list;
         while(cur && cur->eEvent != OMX_EventError)            
            cur = cur->next;
         
         if(cur)
         {
            // clear error flag
            vcos_event_flags_get(&comp->event, ILCLIENT_EVENT_ERROR, VCOS_OR_CONSUME, 0, &set);
            ilclient_unlock_events(comp->client);
            return -2;
         }

         ilclient_unlock_events(comp->client);
      }
      // check for config change event if we are asked to be notified of that
      if(event_flag & ILCLIENT_CONFIG_CHANGED)
      {
         ILEVENT_T *cur;
         ilclient_lock_events(comp->client);
         cur = comp->list;
         while(cur && cur->eEvent != OMX_EventParamOrConfigChanged)
            cur = cur->next;
         
         ilclient_unlock_events(comp->client);

         if(cur)
            return ilclient_remove_event(comp, event, nData1, ignore1, nData2, ignore2) == 0 ? 0 : -3;
      }

      status = vcos_event_flags_get(&comp->event, event_flag, VCOS_OR_CONSUME, 
                                    suspend, &set);
      if (status != 0)
         return -1;
      if (set & ILCLIENT_EVENT_ERROR)
         return -2;
      if (set & ILCLIENT_CONFIG_CHANGED)
         return ilclient_remove_event(comp, event, nData1, ignore1, nData2, ignore2) == 0 ? 0 : -3;
   }

   return 0;
}



/***********************************************************
 * Name: ilclient_wait_for_command_complete_dual
 *
 * Description: Waits for an event signalling command completion.  In
 * this version we may also return failure if there is an error event
 * that has terminated a command on a second component.
 *
 * Returns: 0 on success, -1 on failure of comp, -2 on failure of other
 ***********************************************************/
int ilclient_wait_for_command_complete_dual(COMPONENT_T *comp, OMX_COMMANDTYPE command, OMX_U32 nData2, COMPONENT_T *other)
{
   OMX_U32 mask = ILCLIENT_EVENT_ERROR;
   int ret = 0;

   switch(command) {
   case OMX_CommandStateSet:    mask |= ILCLIENT_STATE_CHANGED; break;
   case OMX_CommandPortDisable: mask |= ILCLIENT_PORT_DISABLED; break;
   case OMX_CommandPortEnable:  mask |= ILCLIENT_PORT_ENABLED;  break;
   default: return -1;
   }

   if(other)
      other->related = comp;

   while(1)
   {
      ILEVENT_T *cur, *prev = NULL;
      VCOS_UNSIGNED set;

      ilclient_lock_events(comp->client);

      cur = comp->list;
      while(cur &&
            !(cur->eEvent == OMX_EventCmdComplete && cur->nData1 == command && cur->nData2 == nData2) &&
            !(cur->eEvent == OMX_EventError && cur->nData2 == 1))
      {
         prev = cur;
         cur = cur->next;
      }

      if(cur)
      {
         if(prev == NULL)
            comp->list = cur->next;
         else
            prev->next = cur->next;

         // work out whether this was a success or a fail event
         ret = cur->eEvent == OMX_EventCmdComplete || cur->nData1 == OMX_ErrorSameState ? 0 : -1;

         if(cur->eEvent == OMX_EventError)
            vcos_event_flags_get(&comp->event, ILCLIENT_EVENT_ERROR, VCOS_OR_CONSUME, 0, &set);

         // add back into spare list
         cur->next = comp->client->event_list;
         comp->client->event_list = cur;
         cur->eEvent = -1; // mark as unused
         
         ilclient_unlock_events(comp->client);
         break;
      }
      else if(other != NULL)
      {
         // check the other component for an error event that terminates a command
         cur = other->list;
         while(cur && !(cur->eEvent == OMX_EventError && cur->nData2 == 1))
            cur = cur->next;

         if(cur)
         {
            // we don't remove the event in this case, since the user
            // can confirm that this event errored by calling wait_for_command on the
            // other component

            ret = -2;
            ilclient_unlock_events(comp->client);
            break;
         }
      }

      ilclient_unlock_events(comp->client);

      vcos_event_flags_get(&comp->event, mask, VCOS_OR_CONSUME, VCOS_SUSPEND, &set);
   }

   if(other)
      other->related = NULL;

   return ret;
}


/***********************************************************
 * Name: ilclient_wait_for_command_complete
 *
 * Description: Waits for an event signalling command completion.
 *
 * Returns: 0 on success, -1 on failure.
 ***********************************************************/
int ilclient_wait_for_command_complete(COMPONENT_T *comp, OMX_COMMANDTYPE command, OMX_U32 nData2)
{
   return ilclient_wait_for_command_complete_dual(comp, command, nData2, NULL);
}

/***********************************************************
 * Name: ilclient_get_output_buffer
 *
 * Description: Returns an output buffer returned from a component
 * using the OMX_FillBufferDone callback from the output list for the
 * given component and port index.
 *
 * Returns: pointer to buffer if available, otherwise NULL
 ***********************************************************/
OMX_BUFFERHEADERTYPE *ilclient_get_output_buffer(COMPONENT_T *comp, int portIndex, int block)
{
   OMX_BUFFERHEADERTYPE *ret = NULL, *prev = NULL;
   VCOS_UNSIGNED set;

   do {
      vcos_semaphore_wait(&comp->sema);
      ret = comp->out_list;
      while(ret != NULL && ret->nOutputPortIndex != portIndex)
      {
         prev = ret;
         ret = ret->pAppPrivate;
      }
      
      if(ret)
      {
         if(prev == NULL)
            comp->out_list = ret->pAppPrivate;
         else
            prev->pAppPrivate = ret->pAppPrivate;
         
         ret->pAppPrivate = NULL;
      }
      vcos_semaphore_post(&comp->sema);

      if(block && !ret)
         vcos_event_flags_get(&comp->event, ILCLIENT_FILL_BUFFER_DONE, VCOS_OR_CONSUME, -1, &set);

   } while(block && !ret);

   return ret;
}

/***********************************************************
 * Name: ilclient_get_input_buffer
 *
 * Description: Returns an input buffer return from a component using
 * the OMX_EmptyBufferDone callback from the output list for the given
 * component and port index.
 *
 * Returns: pointer to buffer if available, otherwise NULL
 ***********************************************************/
OMX_BUFFERHEADERTYPE *ilclient_get_input_buffer(COMPONENT_T *comp, int portIndex, int block)
{
   OMX_BUFFERHEADERTYPE *ret = NULL, *prev = NULL;

   do {
      VCOS_UNSIGNED set;

      vcos_semaphore_wait(&comp->sema);
      ret = comp->in_list;
      while(ret != NULL && ret->nInputPortIndex != portIndex)
      {
         prev = ret;
         ret = ret->pAppPrivate;
      }
      
      if(ret)
      {
         if(prev == NULL)
            comp->in_list = ret->pAppPrivate;
         else
            prev->pAppPrivate = ret->pAppPrivate;
         
         ret->pAppPrivate = NULL;
      }
      vcos_semaphore_post(&comp->sema);

      if(block && !ret)
         vcos_event_flags_get(&comp->event, ILCLIENT_EMPTY_BUFFER_DONE, VCOS_OR_CONSUME, -1, &set);

   } while(block && !ret);

   return ret;
}

/***********************************************************
 * Name: ilclient_debug_output
 *
 * Description: prints a varg message to the log or the debug screen
 * under win32
 *
 * Returns: void
 ***********************************************************/
void ilclient_debug_output(char *format, ...)
{
   va_list args;

   va_start(args, format);
   vcos_vlog_info(format, args);
   va_end(args);
}

/******************************************************************************
Static functions
******************************************************************************/

/***********************************************************
 * Name: ilclient_lock_events
 *
 * Description: locks the client event structure
 *
 * Returns: void
 ***********************************************************/
static void ilclient_lock_events(ILCLIENT_T *st)
{
   vcos_semaphore_wait(&st->event_sema);
}

/***********************************************************
 * Name: ilclient_unlock_events
 *
 * Description: unlocks the client event structure
 *
 * Returns: void
 ***********************************************************/
static void ilclient_unlock_events(ILCLIENT_T *st)
{
   vcos_semaphore_post(&st->event_sema);
}

/***********************************************************
 * Name: ilclient_event_handler
 *
 * Description: event handler passed to core to use as component
 * callback
 *
 * Returns: success
 ***********************************************************/
static OMX_ERRORTYPE ilclient_event_handler(OMX_IN OMX_HANDLETYPE hComponent,
                                            OMX_IN OMX_PTR pAppData,
                                            OMX_IN OMX_EVENTTYPE eEvent,
                                            OMX_IN OMX_U32 nData1,
                                            OMX_IN OMX_U32 nData2,
                                            OMX_IN OMX_PTR pEventData)
{
   COMPONENT_T *st = (COMPONENT_T *) pAppData;
   ILEVENT_T *event;
   OMX_ERRORTYPE error = OMX_ErrorNone;

   ilclient_lock_events(st->client);

   // go through the events on this component and remove any duplicates in the
   // existing list, since the client probably doesn't need them.  it's better
   // than asserting when we run out.
   event = st->list;
   while(event != NULL)
   {
      ILEVENT_T **list = &(event->next);
      while(*list != NULL)
      {
         if((*list)->eEvent == event->eEvent &&
            (*list)->nData1 == event->nData1 &&
            (*list)->nData2 == event->nData2)
         {
            // remove this duplicate
            ILEVENT_T *rem = *list;
            ilclient_debug_output("%s: removing %d/%d/%d", st->name, event->eEvent, event->nData1, event->nData2);            
            *list = rem->next;
            rem->eEvent = -1;
            rem->next = st->client->event_list;
            st->client->event_list = rem;
         }
         else
            list = &((*list)->next);
      }

      event = event->next;
   }

   vc_assert(st->client->event_list);
   event = st->client->event_list;

   switch (eEvent) {
   case OMX_EventCmdComplete:
      switch (nData1) {
      case OMX_CommandStateSet:
         ilclient_debug_output("%s: callback state changed (%s)", st->name, states[nData2]);
         vcos_event_flags_set(&st->event, ILCLIENT_STATE_CHANGED, VCOS_OR);
         break;
      case OMX_CommandPortDisable:
         ilclient_debug_output("%s: callback port disable %d", st->name, nData2);
         vcos_event_flags_set(&st->event, ILCLIENT_PORT_DISABLED, VCOS_OR);
         break;
      case OMX_CommandPortEnable:
         ilclient_debug_output("%s: callback port enable %d", st->name, nData2);
         vcos_event_flags_set(&st->event, ILCLIENT_PORT_ENABLED, VCOS_OR);
         break;
      case OMX_CommandFlush:
         ilclient_debug_output("%s: callback port flush %d", st->name, nData2);
         vcos_event_flags_set(&st->event, ILCLIENT_PORT_FLUSH, VCOS_OR);
         break;
      case OMX_CommandMarkBuffer:
         ilclient_debug_output("%s: callback mark buffer %d", st->name, nData2);
         vcos_event_flags_set(&st->event, ILCLIENT_MARKED_BUFFER, VCOS_OR);
         break;
      default:
         vc_assert(0);
      }
      break;
   case OMX_EventError:
      {
         // check if this component failed a command, and we have to notify another command
         // of this failure
         if(nData2 == 1 && st->related != NULL)
            vcos_event_flags_set(&st->related->event, ILCLIENT_EVENT_ERROR, VCOS_OR);

         error = nData1;
         switch (error) {
         case OMX_ErrorPortUnpopulated:
            if (st->error_mask & ILCLIENT_ERROR_UNPOPULATED)
            {
               ilclient_debug_output("%s: ignore error: port unpopulated (%d)", st->name, nData2);
               event = NULL;
               break;
            }
            ilclient_debug_output("%s: port unpopulated %x (%d)", st->name, error, nData2);
            vcos_event_flags_set(&st->event, ILCLIENT_EVENT_ERROR, VCOS_OR);
            break;
         case OMX_ErrorSameState:
            if (st->error_mask & ILCLIENT_ERROR_SAMESTATE)
            {
               ilclient_debug_output("%s: ignore error: same state (%d)", st->name, nData2);
               event = NULL;
               break;
            }
            ilclient_debug_output("%s: same state %x (%d)", st->name, error, nData2);
            vcos_event_flags_set(&st->event, ILCLIENT_EVENT_ERROR, VCOS_OR);
            break;
         case OMX_ErrorBadParameter:
            if (st->error_mask & ILCLIENT_ERROR_BADPARAMETER)
            {
               ilclient_debug_output("%s: ignore error: bad parameter (%d)", st->name, nData2);
               event = NULL;
               break;
            }
            ilclient_debug_output("%s: bad parameter %x (%d)", st->name, error, nData2);
            vcos_event_flags_set(&st->event, ILCLIENT_EVENT_ERROR, VCOS_OR);
            break;
         case OMX_ErrorIncorrectStateTransition:
            ilclient_debug_output("%s: incorrect state transition %x (%d)", st->name, error, nData2);
            vcos_event_flags_set(&st->event, ILCLIENT_EVENT_ERROR, VCOS_OR);
            break;
         case OMX_ErrorBadPortIndex:
            ilclient_debug_output("%s: bad port index %x (%d)", st->name, error, nData2);
            vcos_event_flags_set(&st->event, ILCLIENT_EVENT_ERROR, VCOS_OR);
            break;
         case OMX_ErrorStreamCorrupt:
            ilclient_debug_output("%s: stream corrupt %x (%d)", st->name, error, nData2);
            vcos_event_flags_set(&st->event, ILCLIENT_EVENT_ERROR, VCOS_OR);
            break;
         case OMX_ErrorInsufficientResources:
            ilclient_debug_output("%s: insufficient resources %x (%d)", st->name, error, nData2);
            vcos_event_flags_set(&st->event, ILCLIENT_EVENT_ERROR, VCOS_OR);
            break;
         case OMX_ErrorUnsupportedSetting:
            ilclient_debug_output("%s: unsupported setting %x (%d)", st->name, error, nData2);
            vcos_event_flags_set(&st->event, ILCLIENT_EVENT_ERROR, VCOS_OR);
            break;
         case OMX_ErrorOverflow:
            ilclient_debug_output("%s: overflow %x (%d)", st->name, error, nData2);
            vcos_event_flags_set(&st->event, ILCLIENT_EVENT_ERROR, VCOS_OR);
            break;
         case OMX_ErrorDiskFull:
            ilclient_debug_output("%s: disk full %x (%d)", st->name, error, nData2);
            //we do not set the error
            break;
         case OMX_ErrorMaxFileSize:
            ilclient_debug_output("%s: max file size %x (%d)", st->name, error, nData2);
            //we do not set the error
            break;
         case OMX_ErrorDrmUnauthorised:
            ilclient_debug_output("%s: drm file is unauthorised %x (%d)", st->name, error, nData2);
            vcos_event_flags_set(&st->event, ILCLIENT_EVENT_ERROR, VCOS_OR);
            break;
         case OMX_ErrorDrmExpired:
            ilclient_debug_output("%s: drm file has expired %x (%d)", st->name, error, nData2);
            vcos_event_flags_set(&st->event, ILCLIENT_EVENT_ERROR, VCOS_OR);
            break;
         case OMX_ErrorDrmGeneral:
            ilclient_debug_output("%s: drm library error %x (%d)", st->name, error, nData2);
            vcos_event_flags_set(&st->event, ILCLIENT_EVENT_ERROR, VCOS_OR);
            break;
         default:
            vc_assert(0);
            ilclient_debug_output("%s: unexpected error %x (%d)", st->name, error, nData2);
            vcos_event_flags_set(&st->event, ILCLIENT_EVENT_ERROR, VCOS_OR);
            break;
         }
      }
      break;
   case OMX_EventBufferFlag:
      ilclient_debug_output("%s: buffer flag %d/%x", st->name, nData1, nData2);
      if (nData2 & OMX_BUFFERFLAG_EOS)
      {
         vcos_event_flags_set(&st->event, ILCLIENT_BUFFER_FLAG_EOS, VCOS_OR);
         nData2 = OMX_BUFFERFLAG_EOS;
      }
      else
         vc_assert(0);
      break;
   case OMX_EventPortSettingsChanged:
      ilclient_debug_output("%s: port settings changed %d", st->name, nData1);
      vcos_event_flags_set(&st->event, ILCLIENT_PARAMETER_CHANGED, VCOS_OR);
      break;
   case OMX_EventMark:
      ilclient_debug_output("%s: buffer mark %p", st->name, pEventData);
      vcos_event_flags_set(&st->event, ILCLIENT_BUFFER_MARK, VCOS_OR);
      break;
   case OMX_EventParamOrConfigChanged:
      ilclient_debug_output("%s: param/config 0x%X on port %d changed", st->name, nData2, nData1);
      vcos_event_flags_set(&st->event, ILCLIENT_CONFIG_CHANGED, VCOS_OR);
      break;
   default:
      vc_assert(0);
      break;
   }

   if (event)
   {
      // fill in details
      event->eEvent = eEvent;
      event->nData1 = nData1;
      event->nData2 = nData2;
      event->pEventData = pEventData;

      // remove from top of spare list
      st->client->event_list = st->client->event_list->next;

      // put at head of component event queue
      event->next = st->list;
      st->list = event;
   }
   ilclient_unlock_events(st->client);

   // now call any callbacks without the event lock so the client can 
   // remove the event in context
   switch(eEvent) {
   case OMX_EventError:
      if(event && st->client->error_callback)
         st->client->error_callback(st->client->error_callback_data, st, error);
      break;
   case OMX_EventBufferFlag:
      if ((nData2 & OMX_BUFFERFLAG_EOS) && st->client->eos_callback)
         st->client->eos_callback(st->client->eos_callback_data, st, nData1);
      break;
   case OMX_EventPortSettingsChanged:
      if (st->client->port_settings_callback)
         st->client->port_settings_callback(st->client->port_settings_callback_data, st, nData1);
      break;
   case OMX_EventParamOrConfigChanged:
      if (st->client->configchanged_callback)
         st->client->configchanged_callback(st->client->configchanged_callback_data, st, nData2);
      break;
   default:
      // ignore
      break;
   }

   return OMX_ErrorNone;
}

/***********************************************************
 * Name: ilclient_empty_buffer_done
 *
 * Description: passed to core to use as component callback, puts
 * buffer on list
 *
 * Returns:
 ***********************************************************/
static OMX_ERRORTYPE ilclient_empty_buffer_done(OMX_IN OMX_HANDLETYPE hComponent,
      OMX_IN OMX_PTR pAppData,
      OMX_IN OMX_BUFFERHEADERTYPE* pBuffer)
{
   COMPONENT_T *st = (COMPONENT_T *) pAppData;
   OMX_BUFFERHEADERTYPE *list;

   ilclient_debug_output("%s: empty buffer done %p", st->name, pBuffer);

   vcos_semaphore_wait(&st->sema);
   // insert at end of the list, so we process buffers in
   // the same order
   list = st->in_list;
   while(list && list->pAppPrivate)
      list = list->pAppPrivate;

   if(!list)
      st->in_list = pBuffer;
   else
      list->pAppPrivate = pBuffer;

   pBuffer->pAppPrivate = NULL;
   vcos_semaphore_post(&st->sema);

   vcos_event_flags_set(&st->event, ILCLIENT_EMPTY_BUFFER_DONE, VCOS_OR);

   if (st->client->empty_buffer_done_callback)
      st->client->empty_buffer_done_callback(st->client->empty_buffer_done_callback_data, st);

   return OMX_ErrorNone;
}

/***********************************************************
 * Name: ilclient_empty_buffer_done_error
 *
 * Description: passed to core to use as component callback, asserts
 * on use as client not expecting component to use this callback.
 *
 * Returns:
 ***********************************************************/
static OMX_ERRORTYPE ilclient_empty_buffer_done_error(OMX_IN OMX_HANDLETYPE hComponent,
      OMX_IN OMX_PTR pAppData,
      OMX_IN OMX_BUFFERHEADERTYPE* pBuffer)
{
   vc_assert(0);
   return OMX_ErrorNone;
}

/***********************************************************
 * Name: ilclient_fill_buffer_done
 *
 * Description: passed to core to use as component callback, puts
 * buffer on list
 *
 * Returns:
 ***********************************************************/
static OMX_ERRORTYPE ilclient_fill_buffer_done(OMX_OUT OMX_HANDLETYPE hComponent,
      OMX_OUT OMX_PTR pAppData,
      OMX_OUT OMX_BUFFERHEADERTYPE* pBuffer)
{
   COMPONENT_T *st = (COMPONENT_T *) pAppData;
   OMX_BUFFERHEADERTYPE *list;

   ilclient_debug_output("%s: fill buffer done %p", st->name, pBuffer);

   vcos_semaphore_wait(&st->sema);
   // insert at end of the list, so we process buffers in
   // the correct order
   list = st->out_list;
   while(list && list->pAppPrivate)
      list = list->pAppPrivate;

   if(!list)
      st->out_list = pBuffer;
   else
      list->pAppPrivate = pBuffer;
      
   pBuffer->pAppPrivate = NULL;
   vcos_semaphore_post(&st->sema);

   vcos_event_flags_set(&st->event, ILCLIENT_FILL_BUFFER_DONE, VCOS_OR);

   if (st->client->fill_buffer_done_callback)
      st->client->fill_buffer_done_callback(st->client->fill_buffer_done_callback_data, st);

   return OMX_ErrorNone;
}

/***********************************************************
 * Name: ilclient_fill_buffer_done_error
 *
 * Description: passed to core to use as component callback, asserts
 * on use as client not expecting component to use this callback.
 *
 * Returns:
 ***********************************************************/
static OMX_ERRORTYPE ilclient_fill_buffer_done_error(OMX_OUT OMX_HANDLETYPE hComponent,
      OMX_OUT OMX_PTR pAppData,
      OMX_OUT OMX_BUFFERHEADERTYPE* pBuffer)
{
   vc_assert(0);
   return OMX_ErrorNone;
}



OMX_HANDLETYPE ilclient_get_handle(COMPONENT_T *comp)
{
   vcos_assert(comp);
   return comp->comp;
}


static struct {
   OMX_PORTDOMAINTYPE dom;
   int param;
} port_types[] = {
   { OMX_PortDomainVideo, OMX_IndexParamVideoInit },
   { OMX_PortDomainAudio, OMX_IndexParamAudioInit },
   { OMX_PortDomainImage, OMX_IndexParamImageInit },
   { OMX_PortDomainOther, OMX_IndexParamOtherInit },
};

int ilclient_get_port_index(COMPONENT_T *comp, OMX_DIRTYPE dir, OMX_PORTDOMAINTYPE type, int index)
{
   uint32_t i;
   // for each possible port type...
   for (i=0; i<sizeof(port_types)/sizeof(port_types[0]); i++)
   {
      if ((port_types[i].dom == type) || (type == (OMX_PORTDOMAINTYPE) -1))
      {
         OMX_PORT_PARAM_TYPE param;
         OMX_ERRORTYPE error;
         uint32_t j;

         param.nSize = sizeof(param);
         param.nVersion.nVersion = OMX_VERSION;
         error = OMX_GetParameter(ILC_GET_HANDLE(comp), port_types[i].param, &param);
         assert(error == OMX_ErrorNone);

         // for each port of this type...
         for (j=0; j<param.nPorts; j++)
         {
            int port = param.nStartPortNumber+j;

            OMX_PARAM_PORTDEFINITIONTYPE portdef;
            portdef.nSize = sizeof(portdef);
            portdef.nVersion.nVersion = OMX_VERSION;
            portdef.nPortIndex = port;

            error = OMX_GetParameter(ILC_GET_HANDLE(comp), OMX_IndexParamPortDefinition, &portdef);
            assert(error == OMX_ErrorNone);

            if (portdef.eDir == dir)
            {
               if (index-- == 0)
                  return port;
            }
         }
      }
   }
   return -1;
}

int ilclient_suggest_bufsize(COMPONENT_T *comp, OMX_U32 nBufSizeHint)
{
   OMX_PARAM_BRCMOUTPUTBUFFERSIZETYPE param;
   OMX_ERRORTYPE error;

   param.nSize = sizeof(param);
   param.nVersion.nVersion = OMX_VERSION;
   param.nBufferSize = nBufSizeHint;
   error = OMX_SetParameter(ILC_GET_HANDLE(comp), OMX_IndexParamBrcmOutputBufferSize,
                            &param);
   assert(error == OMX_ErrorNone);

   return (error == OMX_ErrorNone) ? 0 : -1;
}

unsigned int ilclient_stack_size(void)
{
   return ILCLIENT_THREAD_DEFAULT_STACK_SIZE;
}

                                                                                                                                                                                                                                                                                                  moonlight-embedded-2.1.1/third_party/ilclient/ilclient.h                                            0000664 0000000 0000000 00000127056 12563604362 0023374 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * \file
 *
 * \brief This API defines helper functions for writing IL clients.
 *
 * This file defines an IL client side library.  This is useful when
 * writing IL clients, since there tends to be much repeated and
 * common code across both single and multiple clients.  This library
 * seeks to remove that common code and abstract some of the
 * interactions with components.  There is a wrapper around a
 * component and tunnel, and some operations can be done on lists of
 * these.  The callbacks from components are handled, and specific
 * events can be checked or waited for.
 */

#ifndef _IL_CLIENT_H
#define _IL_CLIENT_H

#include "IL/OMX_Broadcom.h"
#include "interface/vcos/vcos.h"

/**
 * The <DFN>ILCLIENT_T</DFN> structure encapsulates the state needed for the IL
 * Client API.  It contains a set of callback functions used to
 * communicate with the user.  It also includes a linked list of free
 * event structures.
 ***********************************************************/
typedef struct _ILCLIENT_T ILCLIENT_T;


/**
 * Each <DFN>ILEVENT_T</DFN> structure stores the result of an <DFN>EventHandler</DFN>
 * callback from a component, storing the event message type and any
 * parameters returned.
 ***********************************************************/
typedef struct _ILEVENT_T ILEVENT_T;



struct _COMPONENT_T;

/**
 * The <DFN>COMPONENT_T</DFN> structure represents an IL component,
 * together with the necessary extra information required by the IL
 * Client API.  This structure stores the handle to the OMX component,
 * as well as the event list containing all events sent by this
 * component.  The component state structure also holds a pair of
 * buffer queues, for input and output buffers returned to the client
 * by the <DFN>FillBufferDone</DFN> and <DFN>EmptyBufferDone</DFN>
 * callbacks.  As some operations result in error callbacks that can
 * be ignored, an error mask is maintained to allow some errors to be
 * ignored.  A pointer to the client state structure is also added.
 ***********************************************************/
typedef struct _COMPONENT_T COMPONENT_T;


/**
 * The generic callback function is used for communicating events from
 * a particular component to the user.
 *
 * @param userdata The data returned from when the callback was registered.
 *
 * @param comp The component structure representing the component that
 * originated this event.
 *
 * @param data The relevant data field from the event.
 *
 * @return Void.
 ***********************************************************/
typedef void (*ILCLIENT_CALLBACK_T)(void *userdata, COMPONENT_T *comp, OMX_U32 data);


/**
 * The buffer callback function is used for indicating that a
 * component has returned a buffer on a port using client buffer
 * communication.
 *
 * @param data The data returned from when the callback was registered.
 *
 * @param comp The component from which the buffer originated.
 *
 * @return Void.
 ***********************************************************/
typedef void (*ILCLIENT_BUFFER_CALLBACK_T)(void *data, COMPONENT_T *comp);


/**
 * The malloc function is passed into
 * <DFN>ilclient_enable_port_buffers()</DFN> and used for allocating the
 * buffer payload.
 *
 * @param userdata Private pointer passed into
 * <DFN>ilclient_enable_port_buffers()</DFN> call.
 *
 * @param size Size in bytes of the requested memory region.
 *
 * @param align Alignment requirement in bytes for the base memory address.
 *
 * @param description Text description of the memory being allocated.
 *
 * @return The memory address on success, <DFN>NULL</DFN> on failure.
 ***********************************************************/
typedef void *(*ILCLIENT_MALLOC_T)(void *userdata, VCOS_UNSIGNED size, VCOS_UNSIGNED align, const char *description);


/**
 * The free function is passed into
 * <DFN>ilclient_enable_port_buffers()</DFN> and
 * <DFN>ilclient_disable_port_buffers()</DFN> and used for freeing the
 * buffer payload.
 *
 * @param userdata Private pointer passed into
 * <DFN>ilclient_enable_port_buffers()</DFN> and
 * <DFN>ilclient_disable_port_buffers()</DFN>.
 *
 * @param pointer Memory address to free, that was previously returned
 * from <DFN>ILCLIENT_MALLOC_T</DFN> function.
 *
 * @return Void.
 ***********************************************************/
typedef void (*ILCLIENT_FREE_T)(void *userdata, void *pointer);


/**
 * The event mask enumeration describes the possible events that the
 * user can ask to wait for when waiting for a particular event.
 ***********************************************************/
typedef enum {
   ILCLIENT_EMPTY_BUFFER_DONE  = 0x1,   /**< Set when a buffer is
                                           returned from an input
                                           port */

   ILCLIENT_FILL_BUFFER_DONE   = 0x2,   /**< Set when a buffer is
                                           returned from an output
                                           port */

   ILCLIENT_PORT_DISABLED      = 0x4,   /**< Set when a port indicates
                                           it has completed a disable
                                           command. */

   ILCLIENT_PORT_ENABLED       = 0x8,   /**< Set when a port indicates
                                           is has completed an enable
                                           command. */

   ILCLIENT_STATE_CHANGED      = 0x10,  /**< Set when a component
                                           indicates it has completed
                                           a state change command. */

   ILCLIENT_BUFFER_FLAG_EOS    = 0x20,  /**< Set when a port signals
                                           an EOS event. */

   ILCLIENT_PARAMETER_CHANGED  = 0x40,  /**< Set when a port signals a
                                           port settings changed
                                           event. */

   ILCLIENT_EVENT_ERROR        = 0x80,  /**< Set when a component
                                           indicates an error. */

   ILCLIENT_PORT_FLUSH         = 0x100, /**< Set when a port indicates
                                           is has completed a flush
                                           command. */

   ILCLIENT_MARKED_BUFFER      = 0x200, /**< Set when a port indicates
                                           it has marked a buffer. */

   ILCLIENT_BUFFER_MARK        = 0x400, /**< Set when a port indicates
                                           it has received a buffer
                                           mark. */

   ILCLIENT_CONFIG_CHANGED     = 0x800  /**< Set when a config parameter
                                           changed. */
} ILEVENT_MASK_T;


/**
 * On component creation the user can set flags to control the 
 * creation of that component.
 ***********************************************************/
typedef enum {
   ILCLIENT_FLAGS_NONE            = 0x0, /**< Used if no flags are
                                            set. */

   ILCLIENT_ENABLE_INPUT_BUFFERS  = 0x1, /**< If set we allow the
                                            client to communicate with
                                            input ports via buffer
                                            communication, rather than
                                            tunneling with another
                                            component. */

   ILCLIENT_ENABLE_OUTPUT_BUFFERS = 0x2, /**< If set we allow the
                                            client to communicate with
                                            output ports via buffer
                                            communication, rather than
                                            tunneling with another
                                            component. */

   ILCLIENT_DISABLE_ALL_PORTS     = 0x4, /**< If set we disable all
                                            ports on creation. */

   ILCLIENT_HOST_COMPONENT        = 0x8, /**< Create a host component.
                                            The default host ilcore
                                            only can create host components
                                            by being locally hosted
                                            so should only be used for testing
                                            purposes. */

   ILCLIENT_OUTPUT_ZERO_BUFFERS   = 0x10 /**< All output ports will have
                                            nBufferCountActual set to zero,
                                            if supported by the component. */                                            
} ILCLIENT_CREATE_FLAGS_T;
  

/**
 * \brief This structure represents a tunnel in the OpenMAX IL API.
 *
 * Some operations in this API act on a tunnel, so the tunnel state
 * structure (<DFN>TUNNEL_T</DFN>) is a convenient store of the source and sink
 * of the tunnel.  For each, a pointer to the relevant component state
 * structure and the port index is stored.
 ***********************************************************/
typedef struct {
   COMPONENT_T *source;  /**< The source component */
   int source_port;      /**< The output port index on the source component */
   COMPONENT_T *sink;    /**< The sink component */
   int sink_port;        /**< The input port index on the sink component */
} TUNNEL_T;


/**
 * The <DFN>set_tunnel</DFN> macro is a useful function that initialises a
 * <DFN>TUNNEL_T</DFN> structure.
 ***********************************************************/
#define set_tunnel(t,a,b,c,d)  do {TUNNEL_T *_ilct = (t); \
  _ilct->source = (a); _ilct->source_port = (b); \
  _ilct->sink = (c); _ilct->sink_port = (d);} while(0)

/**
 * For calling OpenMAX IL methods directory, we need to access the
 * <DFN>OMX_HANDLETYPE</DFN> corresponding to the <DFN>COMPONENT_T</DFN> structure.  This
 * macro enables this while keeping the <DFN>COMPONENT_T</DFN> structure opaque.
 * The parameter <DFN>x</DFN> should be of the type <DFN>*COMPONENT_T</DFN>.
 ***********************************************************/
#define ILC_GET_HANDLE(x) ilclient_get_handle(x)

/**
 * An IL Client structure is created by the <DFN>ilclient_init()</DFN>
 * method.  This structure is used when creating components, but
 * otherwise is not needed in other API functions as a pointer to this
 * structure is maintained in the <DFN>COMPONENT_T</DFN> structure.
 *
 * @return pointer to client structure
 ***********************************************************/
VCHPRE_ ILCLIENT_T VCHPOST_ *ilclient_init(void);

/**
 * When all components have been deleted, the IL Client structure can
 * be destroyed by calling the <DFN>ilclient_destroy()</DFN> function.
 *
 * @param handle The client handle.  After calling this function, this
 * handle should not be used.
 *
 * @return void
 ***********************************************************/
VCHPRE_ void VCHPOST_ ilclient_destroy(ILCLIENT_T *handle);

/**
 * The <DFN>ilclient_set_port_settings_callback()</DFN> function registers a
 * callback to be used when the <DFN>OMX_EventPortSettingsChanged</DFN> event is
 * received.  When the event is received, a pointer to the component
 * structure and port index is returned by the callback.
 *
 * @param handle The client handle
 *
 * @param func The callback function to use.  Calling this function
 * with a <DFN>NULL</DFN> function pointer will deregister any existing
 * registered callback.
 *
 * @param userdata Data to be passed back when calling the callback
 * function.
 *
 * @return void
 ***********************************************************/
VCHPRE_ void VCHPOST_ ilclient_set_port_settings_callback(ILCLIENT_T *handle,
                                                          ILCLIENT_CALLBACK_T func,
                                                          void *userdata);

/**
 * The <DFN>ilclient_set_eos_callback()</DFN> function registers a callback to be
 * used when the <DFN>OMX_EventBufferFlag</DFN> is received with the
 * <DFN>OMX_BUFFERFLAG_EOS</DFN> flag set. When the event is received, a pointer
 * to the component structure and port index is returned by the
 * callback.
 *
 * @param handle The client handle
 *
 * @param func The callback function to use.  Calling this function
 * with a <DFN>NULL</DFN> function pointer will deregister any existing
 * registered callback.
 *
 * @param userdata Data to be passed back when calling the callback
 * function.
 *
 * @return void
 ***********************************************************/
VCHPRE_ void VCHPOST_ ilclient_set_eos_callback(ILCLIENT_T *handle,
                                                ILCLIENT_CALLBACK_T func,
                                                void *userdata);

/**
 * The <DFN>ilclient_set_error_callback()</DFN> function registers a callback to be
 * used when the <DFN>OMX_EventError</DFN> is received from a component.  When
 * the event is received, a pointer to the component structure and the
 * error code are reported by the callback.
 *
 * @param handle The client handle
 *
 * @param func The callback function to use.  Calling this function
 * with a <DFN>NULL</DFN> function pointer will deregister any existing
 * registered callback.
 *
 * @param userdata Data to be passed back when calling the callback
 * function.
 *
 * @return void
 ***********************************************************/
VCHPRE_ void VCHPOST_ ilclient_set_error_callback(ILCLIENT_T *handle,
                                                  ILCLIENT_CALLBACK_T func,
                                                  void *userdata);

/**
 * The <DFN>ilclient_set_configchanged_callback()</DFN> function
 * registers a callback to be used when an
 * <DFN>OMX_EventParamOrConfigChanged</DFN> event occurs.  When the
 * event is received, a pointer to the component structure and the
 * index value that has changed are reported by the callback.  The
 * user may then use an <DFN>OMX_GetConfig</DFN> call with the index
 * as specified to retrieve the updated information.
 *
 * @param handle The client handle
 *
 * @param func The callback function to use.  Calling this function
 * with a <DFN>NULL</DFN> function pointer will deregister any existing
 * registered callback.
 *
 * @param userdata Data to be passed back when calling the callback
 * function.
 *
 * @return void
 ***********************************************************/
VCHPRE_ void VCHPOST_ ilclient_set_configchanged_callback(ILCLIENT_T *handle, 
                                                          ILCLIENT_CALLBACK_T func, 
                                                          void *userdata);


/**
 * The <DFN>ilclient_set_fill_buffer_done_callback()</DFN> function registers a
 * callback to be used when a buffer passed to an output port using the
 * <DFN>OMX_FillBuffer</DFN> call is returned with the <DFN>OMX_FillBufferDone</DFN>
 * callback.  When the event is received, a pointer to the component
 * structure is returned by the callback.  The user may then use the
 * <DFN>ilclient_get_output_buffer()</DFN> function to retrieve the buffer.
 *
 * @param handle The client handle
 *
 * @param func The callback function to use.  Calling this function
 * with a <DFN>NULL</DFN> function pointer will deregister any existing
 * registered callback.
 *
 * @param userdata Data to be passed back when calling the callback
 * function.
 *
 * @return void
 ***********************************************************/
VCHPRE_ void VCHPOST_ ilclient_set_fill_buffer_done_callback(ILCLIENT_T *handle,
                                                             ILCLIENT_BUFFER_CALLBACK_T func,
                                                             void *userdata);

/**
 * The <DFN>ilclient_set_empty_buffer_done_callback()</DFN> function registers a
 * callback to be used when a buffer passed to an input port using the
 * <DFN>OMX_EmptyBuffer</DFN> call is returned with the <DFN>OMX_EmptyBufferDone</DFN>
 * callback.  When the event is received, a pointer to the component
 * structure is returned by the callback.  The user may then use the
 * <DFN>ilclient_get_input_buffer()</DFN> function to retrieve the buffer.
 *
 * @param handle The client handle
 *
 * @param func The callback function to use.  Calling this function
 * with a <DFN>NULL</DFN> function pointer will deregister any existing
 * registered callback.
 *
 * @param userdata Data to be passed back when calling the callback
 * function.
 *
 * @return void
 ***********************************************************/
VCHPRE_ void VCHPOST_ ilclient_set_empty_buffer_done_callback(ILCLIENT_T *handle,
                                                              ILCLIENT_BUFFER_CALLBACK_T func,
                                                              void *userdata);


/**
 * Components are created using the <DFN>ilclient_create_component()</DFN>
 * function.  
 *
 * @param handle The client handle
 *
 * @param comp On successful creation, the component structure pointer
 * will be written back into <DFN>comp</DFN>.
 *
 * @param name The name of the component to be created.  Component
 * names as provided are automatically prefixed with
 * <DFN>"OMX.broadcom."</DFN> before passing to the IL core.  The name
 * provided will also be used in debugging messages added about this
 * component.
 *
 * @param flags The client can specify some creation behaviour by using
 * the <DFN>flags</DFN> field.  The meaning of each flag is defined 
 * by the <DFN>ILCLIENT_CREATE_FLAGS_T</DFN> type.
 *
 * @return 0 on success, -1 on failure
 ***********************************************************/
VCHPRE_ int VCHPOST_ ilclient_create_component(ILCLIENT_T *handle,
                                               COMPONENT_T **comp,
                                               char *name,
                                               ILCLIENT_CREATE_FLAGS_T flags);

/**
 * The <DFN>ilclient_cleanup_components()</DFN> function deallocates all
 * state associated with components and frees the OpenMAX component
 * handles. All tunnels connecting components should have been torn
 * down explicitly, and all components must be in loaded state.
 *
 * @param list A null-terminated list of component pointers to be
 * deallocated.
 * 
 * @return void
 ***********************************************************/
VCHPRE_ void VCHPOST_ ilclient_cleanup_components(COMPONENT_T *list[]);


/**
 * The <DFN>ilclient_change_component_state()</DFN> function changes the
 * state of an individual component.  This will trigger the state
 * change, and also wait for that state change to be completed.  It
 * should not be called if this state change has dependencies on other
 * components also changing states.  Trying to change a component to
 * its current state is treated as success.
 *
 * @param comp The component to change.
 *
 * @param state The new state to transition to.
 *
 * @return 0 on success, -1 on failure.
 ***********************************************************/
VCHPRE_ int VCHPOST_ ilclient_change_component_state(COMPONENT_T *comp,
                                                     OMX_STATETYPE state);


/**
 * The <DFN>ilclient_state_transition()</DFN> function transitions a set of
 * components that need to perform a simultaneous state transition; 
 * for example, when two components are tunnelled and the buffer
 * supplier port needs to allocate and pass buffers to a non-supplier
 * port.  All components are sent a command to change state, then the
 * function will wait for all components to signal that they have
 * changed state.
 *
 * @param list A null-terminated list of component pointers.
 *
 * @param state The new state to which to transition all components.
 *
 * @return void
 ***********************************************************/
VCHPRE_ void VCHPOST_  ilclient_state_transition(COMPONENT_T *list[],
                                                 OMX_STATETYPE state);


/**
 * The <DFN>ilclient_disable_port()</DFN> function disables a port on a
 * given component.  This function sends the disable port message to
 * the component and waits for the component to signal that this has
 * taken place.  If the port is already disabled, this is treated as a
 * sucess.
 *
 * @param comp The component containing the port to disable.
 *
 * @param portIndex The port index of the port to disable.  This must
 * be a named port index, rather than a <DFN>OMX_ALL</DFN> value.
 *
 * @return void
 ***********************************************************/
VCHPRE_ void VCHPOST_ ilclient_disable_port(COMPONENT_T *comp,
                                            int portIndex);


/**
 * The <DFN>ilclient_enable_port()</DFN> function enables a port on a
 * given component.  This function sends the enable port message to
 * the component and waits for the component to signal that this has
 * taken place.  If the port is already disabled, this is treated as a
 * sucess.
 *
 * @param comp The component containing the port to enable.
 *
 * @param portIndex The port index of the port to enable.  This must
 * be a named port index, rather than a <DFN>OMX_ALL</DFN> value.
 *
 * @return void
 ***********************************************************/
VCHPRE_ void VCHPOST_ ilclient_enable_port(COMPONENT_T *comp,
                                           int portIndex);



/**
 * The <DFN>ilclient_enable_port_buffers()</DFN> function enables a port
 * in base profile mode on a given component.  The port is not
 * tunneled, so requires buffers to be allocated.
 *
 * @param comp The component containing the port to enable.
 *
 * @param portIndex The port index of the port to enable.  This must
 * be a named port index, rather than a <DFN>OMX_ALL</DFN> value.
 *
 * @param ilclient_malloc This function will be used to allocate
 * buffer payloads.  If <DFN>NULL</DFN> then
 * <DFN>vcos_malloc_aligned</DFN> will be used.
 *
 * @param ilclient_free If an error occurs, this function is used to
 * free previously allocated payloads.  If <DFN>NULL</DFN> then
 * <DFN>vcos_free</DFN> will be used.
 *
 * @param userdata The first argument to calls to
 * <DFN>ilclient_malloc</DFN> and <DFN>ilclient_free</DFN>, if these
 * arguments are not <DFN>NULL</DFN>.
 *
 * @return 0 indicates success. -1 indicates failure.
 ***********************************************************/
VCHPRE_ int VCHPOST_ ilclient_enable_port_buffers(COMPONENT_T *comp,
                                                  int portIndex,
                                                  ILCLIENT_MALLOC_T ilclient_malloc,
                                                  ILCLIENT_FREE_T ilclient_free,
                                                  void *userdata);


/**
 * The <DFN>ilclient_disable_port_buffers()</DFN> function disables a
 * port in base profile mode on a given component.  The port is not
 * tunneled, and has been supplied with buffers by the client.
 *
 * @param comp The component containing the port to disable.
 *
 * @param portIndex The port index of the port to disable.  This must
 * be a named port index, rather than a <DFN>OMX_ALL</DFN> value.
 *
 * @param bufferList A list of buffers, using <DFN>pAppPrivate</DFN>
 * as the next pointer that were allocated on this port, and currently
 * held by the application.  If buffers on this port are held by IL
 * client or the component then these are automatically freed.
 *
 * @param ilclient_free This function is used to free the buffer payloads.
 * If <DFN>NULL</DFN> then <DFN>vcos_free</DFN> will be used.
 *
 * @param userdata The first argument to calls to
 * <DFN>ilclient_free</DFN>.
 *
 * @return void
 */
VCHPRE_ void VCHPOST_ ilclient_disable_port_buffers(COMPONENT_T *comp,
                                                    int portIndex,
                                                    OMX_BUFFERHEADERTYPE *bufferList,
                                                    ILCLIENT_FREE_T ilclient_free,
                                                    void *userdata);


/**
 * With a populated tunnel structure, the
 * <DFN>ilclient_setup_tunnel()</DFN> function connects the tunnel.  It
 * first transitions the source component to idle if currently in
 * loaded state, and then optionally checks the source event list for
 * a port settings changed event from the source port.  If this event
 * is not in the event queue then this function optionally waits for
 * it to arrive.  To disable this check for the port settings changed
 * event, set <DFN>timeout</DFN> to zero.
 *
 * Both ports are then disabled, and the source port is inspected for
 * a port streams parameter.  If this is supported, then the
 * <DFN>portStream</DFN> argument is used to select which port stream
 * to use.  The two ports are then tunnelled using the
 * <DFN>OMX_SetupTunnel</DFN> function.  If this is successful, then
 * both ports are enabled.  Note that for disabling and enabling the
 * tunnelled ports, the functions <DFN>ilclient_disable_tunnel()</DFN>
 * and <DFN>ilclient_enable_tunnel()</DFN> are used, so the relevant
 * documentation for those functions applies here.
 *
 * @param tunnel The tunnel structure representing the tunnel to
 * set up.
 *
 * @param portStream If port streams are supported on the output port
 * of the tunnel, then this parameter indicates the port stream to
 * select on this port.
 *
 * @param timeout The time duration in milliseconds to wait for the
 * output port to signal a port settings changed event before
 * returning a timeout failure.  If this is 0, then we do not check
 * for a port settings changed before setting up the tunnel.
 *
 * @return 0 indicates success, negative indicates failure:
 *  - -1: a timeout waiting for the parameter changed
 *  - -2: an error was returned instead of parameter changed
 *  - -3: no streams are available from this port
 *  - -4: requested stream is not available from this port
 *  - -5: the data format was not acceptable to the sink
 ***********************************************************/
VCHPRE_ int VCHPOST_ ilclient_setup_tunnel(TUNNEL_T *tunnel,
                                           unsigned int portStream,
                                           int timeout);


/**
 * The <DFN>ilclient_disable_tunnel()</DFN> function disables both ports listed in
 * the tunnel structure.  It will send a port disable command to each
 * port, then waits for both to indicate they have completed the
 * transition.  The errors <DFN>OMX_ErrorPortUnpopulated</DFN> and
 * <DFN>OMX_ErrorSameState</DFN> are both ignored by this function; the former
 * since the first port to disable may deallocate buffers before the
 * second port has been disabled, leading to the second port reporting
 * the unpopulated error.
 *
 * @param tunnel The tunnel to disable.
 *
 * @return void
 ***********************************************************/
VCHPRE_ void VCHPOST_ ilclient_disable_tunnel(TUNNEL_T *tunnel);


/**
 * The <DFN>ilclient_enable_tunnel()</DFN> function enables both ports listed in
 * the tunnel structure.  It will first send a port enable command to
 * each port.  It then checks whether the sink component is not in
 * loaded state - if so, the function waits for both ports to complete
 * the requested port enable.  If the sink component was in loaded
 * state, then this component is transitioned to idle to allow the
 * ports to exchange buffers and enable the ports.  This is since
 * typically this function is used when creating a tunnel between two
 * components, where the source component is processing data to enable
 * it to report the port settings changed event, and the sink port has
 * yet to be used.  Before transitioning the sink component to idle,
 * this function waits for the sink port to be enabled - since the
 * component is in loaded state, this will happen quickly.  If the
 * transition to idle fails, the sink component is transitioned back
 * to loaded and the source port disabled.  If the transition
 * succeeds, the function then waits for the source port to complete
 * the requested port enable.
 *
 * @param tunnel The tunnel to enable.
 *
 * @return 0 on success, -1 on failure.
 ***********************************************************/
VCHPRE_ int VCHPOST_ ilclient_enable_tunnel(TUNNEL_T *tunnel);


/**
 * The <DFN>ilclient_flush_tunnels()</DFN> function will flush a number of tunnels
 * from the list of tunnels presented.  For each tunnel that is to be
 * flushed, both source and sink ports are sent a flush command.  The
 * function then waits for both ports to report they have completed
 * the flush operation.
 *
 * @param tunnel List of tunnels.  The list must be terminated with a
 * tunnel structure with <DFN>NULL</DFN> component entries.
 *
 * @param max The maximum number of tunnels to flush from the list.
 * A value of 0 indicates that all tunnels in the list are flushed.
 *
 * @return void
 ***********************************************************/
VCHPRE_ void VCHPOST_ ilclient_flush_tunnels(TUNNEL_T *tunnel,
                                             int max);


/**
 * The <DFN>ilclient_teardown_tunnels()</DFN> function tears down all tunnels in
 * the list of tunnels presented.  For each tunnel in the list, the
 * <DFN>OMX_SetupTunnel</DFN> is called on the source port and on the sink port,
 * where for both calls the destination component is <DFN>NULL</DFN> and the
 * destination port is zero.  The VMCSX IL implementation requires
 * that all tunnels are torn down in this manner before components are
 * freed. 
 *
 * @param tunnels List of tunnels to teardown.  The list must be
 * terminated with a tunnel structure with <DFN>NULL</DFN> component entries.
 *
 * @return void
 ***********************************************************/
VCHPRE_ void VCHPOST_ ilclient_teardown_tunnels(TUNNEL_T *tunnels);


/**
 * The <DFN>ilclient_get_output_buffer()</DFN> function returns a buffer
 * that was sent to an output port and that has been returned from a
 * component using the <DFN>OMX_FillBufferDone</DFN> callback.
 *
 * @param comp The component that returned the buffer.
 *
 * @param portIndex The port index on the component that the buffer
 * was returned from.
 *
 * @param block If non-zero, the function will block until a buffer is available.
 *
 * @return Pointer to buffer if available, otherwise <DFN>NULL</DFN>.
 ***********************************************************/
VCHPRE_ OMX_BUFFERHEADERTYPE* VCHPOST_ ilclient_get_output_buffer(COMPONENT_T *comp,
                                                                  int portIndex,
                                                                  int block);


/**
 * The <DFN>ilclient_get_input_buffer()</DFN> function returns a buffer
 * that was sent to an input port and that has been returned from a
 * component using the <DFN>OMX_EmptyBufferDone</DFN> callback.
 *
 * @param comp The component that returned the buffer.
 *
 * @param portIndex The port index on the component from which the buffer
 * was returned.
 *
 * @param block If non-zero, the function will block until a buffer is available.
 *
 * @return pointer to buffer if available, otherwise <DFN>NULL</DFN>
 ***********************************************************/
VCHPRE_ OMX_BUFFERHEADERTYPE* VCHPOST_ ilclient_get_input_buffer(COMPONENT_T *comp,
                                                                 int portIndex,
                                                                 int block);


/**
 * The <DFN>ilclient_remove_event()</DFN> function queries the event list for the
 * given component, matching against the given criteria.  If a matching
 * event is found, it is removed and added to the free event list.
 *
 * @param comp The component that returned the matching event.
 *
 * @param event The event type of the matching event.
 *
 * @param nData1 The <DFN>nData1</DFN> field of the matching event.
 *
 * @param ignore1 Whether to ignore the <DFN>nData1</DFN> field when finding a
 * matching event.  A value of 0 indicates that <DFN>nData1</DFN> must match, a
 * value of 1 indicates that <DFN>nData1</DFN> does not have to match.
 *
 * @param nData2 The <DFN>nData2</DFN> field of the matching event.
 *
 * @param ignore2 Whether to ignore the <DFN>nData2</DFN> field when finding a
 * matching event.  A value of 0 indicates that <DFN>nData2</DFN> must match, a
 * value of 1 indicates that <DFN>nData2</DFN> does not have to match.
 *
 * @return 0 if the event was removed.  -1 if no matching event was
 * found.
 ***********************************************************/
VCHPRE_ int VCHPOST_ ilclient_remove_event(COMPONENT_T *comp,
                                           OMX_EVENTTYPE event,
                                           OMX_U32 nData1,
                                           int ignore1,
                                           OMX_U32 nData2,
                                           int ignore2);


/**
 * The <DFN>ilclient_return_events()</DFN> function removes all events
 * from a component event list and adds them to the IL client free
 * event list.  This function is automatically called when components
 * are freed.
 *
 * @param comp The component from which all events should be moved to
 * the free list.
 *
 * @return void
 ***********************************************************/
VCHPRE_ void VCHPOST_ ilclient_return_events(COMPONENT_T *comp);


/**
 * The <DFN>ilclient_wait_for_event()</DFN> function is similar to
 * <DFN>ilclient_remove_event()</DFN>, but allows the caller to block until that
 * event arrives.
 *
 * @param comp The component that returned the matching event.
 *
 * @param event The event type of the matching event.
 *
 * @param nData1 The <DFN>nData1</DFN> field of the matching event.
 *
 * @param ignore1 Whether to ignore the <DFN>nData1</DFN> field when finding a
 * matching event.  A value of 0 indicates that <DFN>nData1</DFN> must match, a
 * value of 1 indicates that <DFN>nData1</DFN> does not have to match.
 *
 * @param nData2 The <DFN>nData2</DFN> field of the matching event.
 *
 * @param ignore2 Whether to ignore the <DFN>nData2</DFN> field when finding a
 * matching event.  A value of 0 indicates that <DFN>nData2</DFN> must match, a
 * value of 1 indicates that <DFN>nData2</DFN> does not have to match.
 *
 * @param event_flag Specifies a bitfield of IL client events to wait
 * for, given in <DFN>ILEVENT_MASK_T</DFN>.  If any of these events
 * are signalled by the component, the event list is then re-checked
 * for a matching event.  If the <DFN>ILCLIENT_EVENT_ERROR</DFN> bit
 * is included, and an error is signalled by the component, then the
 * function will return an error code.  If the
 * <DFN>ILCLIENT_CONFIG_CHANGED</DFN> bit is included, and this bit is
 * signalled by the component, then the function will return an error
 * code.
 *
 * @param timeout Specifies how long to block for in milliseconds
 * before returning a failure.
 *
 * @return 0 indicates success, a matching event has been removed from
 * the component's event queue.  A negative return indicates failure,
 * in this case no events have been removed from the component's event
 * queue.
 *  - -1: a timeout was received.
 *  - -2: an error event was received.
 *  - -3: a config changed event was received.
 ***********************************************************/
VCHPRE_ int VCHPOST_ ilclient_wait_for_event(COMPONENT_T *comp,
                                             OMX_EVENTTYPE event,
                                             OMX_U32 nData1,
                                             int ignore1,
                                             OMX_U32 nData2,
                                             int ignore2,
                                             int event_flag,
                                             int timeout);


/**
 * The <DFN>ilclient_wait_for_command_complete()</DFN> function waits
 * for a message from a component that indicates that the command
 * has completed.  This is either a command success message, or an 
 * error message that signals the completion of an event.
 * 
 * @param comp The component currently processing a command.
 *
 * @param command The command being processed.  This must be either
 * <DFN>OMX_CommandStateSet</DFN>, <DFN>OMX_CommandPortDisable</DFN>
 * or <DFN>OMX_CommandPortEnable</DFN>.
 *
 * @param nData2 The expected value of <DFN>nData2</DFN> in the
 * command complete message.
 *
 * @return 0 indicates success, either the command successfully completed
 * or the <DFN>OMX_ErrorSameState</DFN> was returned.  -1 indicates
 * that the command terminated with a different error message.
 ***********************************************************/
VCHPRE_ int VCHPOST_ ilclient_wait_for_command_complete(COMPONENT_T *comp,
                                                        OMX_COMMANDTYPE command,
                                                        OMX_U32 nData2);


/**
 * The <DFN>ilclient_wait_for_command_complete_dual()</DFN> function
 * is similar to <DFN>ilclient_wait_for_command_complete()</DFN>.  The
 * difference is that while waiting for the component to complete the
 * event or raise an error, we can also report if another reports an
 * error that terminates a command.  This is useful if the two
 * components are tunneled, and we need to wait for one component to
 * enable a port, or change state to <DFN>OMX_StateIdle</DFN>.  If the
 * other component is the buffer supplier and reports an error, then
 * it will not allocate buffers, so our first component may stall.
 * 
 * @param comp The component currently processing a command.
 *
 * @param command The command being processed.  This must be either
 * <DFN>OMX_CommandStateSet</DFN>, <DFN>OMX_CommandPortDisable</DFN>
 * or <DFN>OMX_CommandPortEnable</DFN>.
 *
 * @param nData2 The expected value of <DFN>nData2</DFN> in the
 * command complete message.
 *
 * @param related Another component, where we will return if this
 * component raises an error that terminates a command.
 *
 * @return 0 indicates success, either the command successfully
 * completed or the <DFN>OMX_ErrorSameState</DFN> was returned.  -1
 * indicates that the command terminated with a different error
 * message. -2 indicates that the related component raised an error.
 * In this case, the error is not cleared from the related
 * component's event list.
 ***********************************************************/
VCHPRE_ int VCHPOST_ ilclient_wait_for_command_complete_dual(COMPONENT_T *comp,
                                                             OMX_COMMANDTYPE command,
                                                             OMX_U32 nData2,
                                                             COMPONENT_T *related);
                                                             

/**
 * The <DFN>ilclient_debug_output()</DFN> function adds a message to a 
 * host-specific debug display.  For a local VideoCore host the message is
 * added to the internal message log.  For a Win32 host the message is
 * printed to the debug display.  This function should be customised
 * when IL client is ported to another platform.
 * 
 * @param format A message to add, together with the variable
 * argument list similar to <DFN>printf</DFN> and other standard C functions.
 *
 * @return void
 ***********************************************************/
VCHPRE_ void VCHPOST_ ilclient_debug_output(char *format, ...);

/**
 * The <DFN>ilclient_get_handle()</DFN> function returns the
 * underlying OMX component held by an IL component handle.  This is
 * needed when calling methods such as <DFN>OMX_SetParameter</DFN> on
 * a component created using the IL client library.
 *
 * @param comp  IL component handle
 *
 * @return The <DFN>OMX_HANDLETYPE</DFN> value for the component.
 ***********************************************************/
VCHPRE_ OMX_HANDLETYPE VCHPOST_ ilclient_get_handle(COMPONENT_T *comp);


#ifndef OMX_SKIP64BIT

/**
 * Macro to return <DFN>OMX_TICKS</DFN> from a signed 64 bit value.
 * This is the version where <DFN>OMX_TICKS</DFN> is a signed 64 bit
 * value, an alternative definition is used when <DFN>OMX_TICKS</DFN>
 * is a structure.
 */
#define ilclient_ticks_from_s64(s) (s)

/**
 * Macro to return signed 64 bit value from <DFN>OMX_TICKS</DFN>.
 * This is the version where <DFN>OMX_TICKS</DFN> is a signed 64 bit
 * value, an alternative definition is used when <DFN>OMX_TICKS</DFN>
 * is a structure.
 */
#define ilclient_ticks_to_s64(t)   (t)

#else

/**
 * Inline function to return <DFN>OMX_TICKS</DFN> from a signed 64 bit
 * value.  This is the version where <DFN>OMX_TICKS</DFN> is a
 * structure, an alternative definition is used when
 * <DFN>OMX_TICKS</DFN> is a signed 64 bit value.
 */
static inline OMX_TICKS ilclient_ticks_from_s64(int64_t s) {
   OMX_TICKS ret;
   ret.nLowPart = s;
   ret.nHighPart = s>>32;
   return ret;
}

/**
 * Inline function to return signed 64 bit value from
 * <DFN>OMX_TICKS</DFN>.  This is the version where
 * <DFN>OMX_TICKS</DFN> is a structure, an alternative definition is
 * used when <DFN>OMX_TICKS</DFN> is a signed 64 bit value.
 */
static inline int64_t ilclient_ticks_to_s64(OMX_TICKS t) {
   uint64_t u = t.nLowPart | ((uint64_t)t.nHighPart << 32);
   return u;
}


#endif /* OMX_SKIP64BIT */

/**
 * The <DFN>ilclient_get_port_index()</DFN> function returns the n'th
 * port index of the specified type and direction for the given
 * component.
 *
 * @param comp    The component of interest
 * @param dir     The direction
 * @param type    The type, or -1 for any type.
 * @param index   Which port (counting from 0).
 *
 * @return        The port index, or -1 if not found.
 ***********************************************************/
VCHPRE_ int VCHPOST_ ilclient_get_port_index(COMPONENT_T *comp,
                                             OMX_DIRTYPE dir,
                                             OMX_PORTDOMAINTYPE type,
                                             int index);


/**
 * The <DFN>ilclient_suggest_bufsize()</DFN> function gives a
 * component a hint about the size of buffer it should use.  This size
 * is set on the component by setting the
 * <DFN>OMX_IndexParamBrcmOutputBufferSize</DFN> index on the given
 * component.
 *
 * @param comp         IL component handle
 * @param nBufSizeHint Size of buffer in bytes
 *
 * @return             0 indicates success, -1 indicates failure.
 ***********************************************************/
VCHPRE_ int VCHPOST_ ilclient_suggest_bufsize(COMPONENT_T *comp,
                                              OMX_U32 nBufSizeHint);


/**
 * The <DFN>ilclient_stack_size()</DFN> function suggests a minimum
 * stack size that tasks calling into with API will require.
 *
 * @return    Suggested stack size in bytes.
 ***********************************************************/
VCHPRE_ unsigned int VCHPOST_ ilclient_stack_size(void);

#endif /* ILCLIENT_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  moonlight-embedded-2.1.1/third_party/ilclient/ilcore.c                                              0000664 0000000 0000000 00000020275 12563604362 0023034 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * \file
 *
 * \brief Host core implementation.
 */

#include <stdio.h>
#include <stdarg.h>

//includes
#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <IL/OMX_Component.h>
#include <interface/vcos/vcos.h>

#include <interface/vmcs_host/vcilcs.h>
#include <interface/vmcs_host/vchost.h>
#include <interface/vmcs_host/vcilcs_common.h>

static int coreInit = 0;
static int nActiveHandles = 0;
static ILCS_SERVICE_T *ilcs_service = NULL;
static VCOS_MUTEX_T lock;
static VCOS_ONCE_T once = VCOS_ONCE_INIT;

/* Atomic creation of lock protecting shared state */
static void initOnce(void)
{
   VCOS_STATUS_T status;
   status = vcos_mutex_create(&lock, VCOS_FUNCTION);
   vcos_demand(status == VCOS_SUCCESS);
}

/* OMX_Init */
OMX_ERRORTYPE OMX_APIENTRY OMX_Init(void)
{
   VCOS_STATUS_T status;
   OMX_ERRORTYPE err = OMX_ErrorNone;

   status = vcos_once(&once, initOnce);
   vcos_demand(status == VCOS_SUCCESS);

   vcos_mutex_lock(&lock);
   
   if(coreInit == 0)
   {
      // we need to connect via an ILCS connection to VideoCore
      VCHI_INSTANCE_T initialise_instance;
      VCHI_CONNECTION_T *connection;
      ILCS_CONFIG_T config;

      vc_host_get_vchi_state(&initialise_instance, &connection);

      vcilcs_config(&config);

      ilcs_service = ilcs_init((VCHIQ_INSTANCE_T) initialise_instance, (void **) &connection, &config, 0);

      if(ilcs_service == NULL)
      {
         err = OMX_ErrorHardware;
         goto end;
      }

      coreInit = 1;
   }
   else
      coreInit++;

end:
   vcos_mutex_unlock(&lock);
   return err;
}

/* OMX_Deinit */
OMX_ERRORTYPE OMX_APIENTRY OMX_Deinit(void)
{
   if(coreInit == 0) // || (coreInit == 1 && nActiveHandles > 0))
      return OMX_ErrorNotReady;

   vcos_mutex_lock(&lock);

   coreInit--;

   if(coreInit == 0)
   {
      // we need to teardown the ILCS connection to VideoCore
      ilcs_deinit(ilcs_service);
      ilcs_service = NULL;
   }

   vcos_mutex_unlock(&lock);
   
   return OMX_ErrorNone;
}


/* OMX_ComponentNameEnum */
OMX_ERRORTYPE OMX_APIENTRY OMX_ComponentNameEnum(
   OMX_OUT OMX_STRING cComponentName,
   OMX_IN  OMX_U32 nNameLength,
   OMX_IN  OMX_U32 nIndex)
{
   if(ilcs_service == NULL)
      return OMX_ErrorBadParameter;

   return vcil_out_component_name_enum(ilcs_get_common(ilcs_service), cComponentName, nNameLength, nIndex);
}


/* OMX_GetHandle */
OMX_ERRORTYPE OMX_APIENTRY OMX_GetHandle(
   OMX_OUT OMX_HANDLETYPE* pHandle,
   OMX_IN  OMX_STRING cComponentName,
   OMX_IN  OMX_PTR pAppData,
   OMX_IN  OMX_CALLBACKTYPE* pCallBacks)
{
   OMX_ERRORTYPE eError;
   OMX_COMPONENTTYPE *pComp;
   OMX_HANDLETYPE hHandle = 0;

   if (pHandle == NULL || cComponentName == NULL || pCallBacks == NULL || ilcs_service == NULL)
   {
      if(pHandle)
         *pHandle = NULL;
      return OMX_ErrorBadParameter;
   }

   {
      pComp = (OMX_COMPONENTTYPE *)malloc(sizeof(OMX_COMPONENTTYPE));
      if (!pComp)
      {
         vcos_assert(0);
         return OMX_ErrorInsufficientResources;
      }
      memset(pComp, 0, sizeof(OMX_COMPONENTTYPE));
      hHandle = (OMX_HANDLETYPE)pComp;
      pComp->nSize = sizeof(OMX_COMPONENTTYPE);
      pComp->nVersion.nVersion = OMX_VERSION;
      eError = vcil_out_create_component(ilcs_get_common(ilcs_service), hHandle, cComponentName);

      if (eError == OMX_ErrorNone) {
         // Check that all function pointers have been filled in.
         // All fields should be non-zero.
         int i;
         uint32_t *p = (uint32_t *) pComp;
         for(i=0; i<sizeof(OMX_COMPONENTTYPE)>>2; i++)
            if(*p++ == 0)
               eError = OMX_ErrorInvalidComponent;

         if(eError != OMX_ErrorNone && pComp->ComponentDeInit)
            pComp->ComponentDeInit(hHandle);
      }      

      if (eError == OMX_ErrorNone) {
         eError = pComp->SetCallbacks(hHandle,pCallBacks,pAppData);
         if (eError != OMX_ErrorNone)
            pComp->ComponentDeInit(hHandle);
      }
      if (eError == OMX_ErrorNone) {
         *pHandle = hHandle;
      }
      else {
         *pHandle = NULL;
         free(pComp);
      }
   } 

   if (eError == OMX_ErrorNone) {
      vcos_mutex_lock(&lock);
      nActiveHandles++;
      vcos_mutex_unlock(&lock);
   }

   return eError;
}

/* OMX_FreeHandle */
OMX_ERRORTYPE OMX_APIENTRY OMX_FreeHandle(
   OMX_IN  OMX_HANDLETYPE hComponent)
{
   OMX_ERRORTYPE eError = OMX_ErrorNone;
   OMX_COMPONENTTYPE *pComp;

   if (hComponent == NULL || ilcs_service == NULL)
      return OMX_ErrorBadParameter;

   pComp = (OMX_COMPONENTTYPE*)hComponent;

   if (ilcs_service == NULL)
      return OMX_ErrorBadParameter;

   eError = (pComp->ComponentDeInit)(hComponent);
   if (eError == OMX_ErrorNone) {
      vcos_mutex_lock(&lock);
      --nActiveHandles;
      vcos_mutex_unlock(&lock);
      free(pComp);
   }

   vcos_assert(nActiveHandles >= 0);

   return eError;
}

/* OMX_SetupTunnel */
OMX_ERRORTYPE OMX_APIENTRY OMX_SetupTunnel(
   OMX_IN  OMX_HANDLETYPE hOutput,
   OMX_IN  OMX_U32 nPortOutput,
   OMX_IN  OMX_HANDLETYPE hInput,
   OMX_IN  OMX_U32 nPortInput)
{
   OMX_ERRORTYPE eError = OMX_ErrorNone;
   OMX_COMPONENTTYPE *pCompIn, *pCompOut;
   OMX_TUNNELSETUPTYPE oTunnelSetup;

   if ((hOutput == NULL && hInput == NULL) || ilcs_service == NULL)
      return OMX_ErrorBadParameter;

   oTunnelSetup.nTunnelFlags = 0;
   oTunnelSetup.eSupplier = OMX_BufferSupplyUnspecified;

   pCompOut = (OMX_COMPONENTTYPE*)hOutput;

   if (hOutput){
      eError = pCompOut->ComponentTunnelRequest(hOutput, nPortOutput, hInput, nPortInput, &oTunnelSetup);
   }

   if (eError == OMX_ErrorNone && hInput) {
      pCompIn = (OMX_COMPONENTTYPE*)hInput;
      eError = pCompIn->ComponentTunnelRequest(hInput, nPortInput, hOutput, nPortOutput, &oTunnelSetup);

      if (eError != OMX_ErrorNone && hOutput) {
         /* cancel tunnel request on output port since input port failed */
         pCompOut->ComponentTunnelRequest(hOutput, nPortOutput, NULL, 0, NULL);
      }
   }
   return eError;
}

/* OMX_GetComponentsOfRole */
OMX_ERRORTYPE OMX_GetComponentsOfRole (
   OMX_IN      OMX_STRING role,
   OMX_INOUT   OMX_U32 *pNumComps,
   OMX_INOUT   OMX_U8  **compNames)
{
   OMX_ERRORTYPE eError = OMX_ErrorNone;

   *pNumComps = 0;
   return eError;
}

/* OMX_GetRolesOfComponent */
OMX_ERRORTYPE OMX_GetRolesOfComponent (
   OMX_IN      OMX_STRING compName,
   OMX_INOUT   OMX_U32 *pNumRoles,
   OMX_OUT     OMX_U8 **roles)
{
   OMX_ERRORTYPE eError = OMX_ErrorNone;

   *pNumRoles = 0;
   return eError;
}

/* OMX_GetDebugInformation */
OMX_ERRORTYPE OMX_GetDebugInformation (
   OMX_OUT    OMX_STRING debugInfo,
   OMX_INOUT  OMX_S32 *pLen)
{
   if(ilcs_service == NULL)
      return OMX_ErrorBadParameter;

   return vcil_out_get_debug_information(ilcs_get_common(ilcs_service), debugInfo, pLen);
}



/* File EOF */

                                                                                                                                                                                                                                                                                                                                   moonlight-embedded-2.1.1/third_party/libcec/                                                        0000775 0000000 0000000 00000000000 12563604362 0021023 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        moonlight-embedded-2.1.1/third_party/libcec/ceccloader.h                                            0000664 0000000 0000000 00000062314 12563604362 0023266 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #pragma once
/*
 * This file is part of the libCEC(R) library.
 *
 * libCEC(R) is Copyright (C) 2011-2015 Pulse-Eight Limited.  All rights reserved.
 * libCEC(R) is an original work, containing original code.
 *
 * libCEC(R) is a trademark of Pulse-Eight Limited.
 *
 * This program is dual-licensed; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 *
 *
 * Alternatively, you can license this library under a commercial license,
 * please contact Pulse-Eight Licensing for more information.
 *
 * For more information contact:
 * Pulse-Eight Licensing       <license@pulse-eight.com>
 *     http://www.pulse-eight.com/
 *     http://www.pulse-eight.net/
 */

#include "cecc.h"

#include <stdio.h>
#if defined(_WIN32) || defined(_WIN64)
#include <windows.h>
#include <conio.h>
typedef HINSTANCE libcecc_lib_instance_t;
#else
#include <dlfcn.h>
typedef void* libcecc_lib_instance_t;
#ifndef CDECL
#define CDECL
#endif
#endif

static libcecc_lib_instance_t libcecc_load_library(const char* strLib);
static void libcecc_close_library(libcecc_lib_instance_t lib);
static void* libcecc_resolve(void* lib, const char* name);

#define _libcecc_resolve(lib, tar, name, method) \
  do { \
    tar = (method) libcecc_resolve(lib, name); \
    if (tar == NULL) \
    { \
      libcecc_close_library(lib); \
      return -1; \
    } \
  } while(0)

typedef struct {
  libcec_connection_t                 connection;
  libcecc_lib_instance_t              lib_instance;
  void                                (CDECL *destroy)(libcec_connection_t connection);
  int                                 (CDECL *open)(libcec_connection_t connection, const char* strPort, uint32_t iTimeout);
  void                                (CDECL *close)(libcec_connection_t connection);
  void                                (CDECL *clear_configuration)(CEC_NAMESPACE libcec_configuration* configuration);
  int                                 (CDECL *enable_callbacks)(libcec_connection_t connection, void* cbParam, CEC_NAMESPACE ICECCallbacks* callbacks);
  int8_t                              (CDECL *find_adapters)(libcec_connection_t connection, CEC_NAMESPACE cec_adapter* deviceList, uint8_t iBufSize, const char* strDevicePath);
  int                                 (CDECL *ping_adapters)(libcec_connection_t connection);
  int                                 (CDECL *start_bootloader)(libcec_connection_t connection);
  int                                 (CDECL *power_on_devices)(libcec_connection_t connection, CEC_NAMESPACE cec_logical_address address);
  int                                 (CDECL *standby_devices)(libcec_connection_t connection, CEC_NAMESPACE cec_logical_address address);
  int                                 (CDECL *set_active_source)(libcec_connection_t connection, CEC_NAMESPACE cec_device_type type);
  int                                 (CDECL *set_deck_control_mode)(libcec_connection_t connection, CEC_NAMESPACE cec_deck_control_mode mode, int bSendUpdate);
  int                                 (CDECL *set_deck_info)(libcec_connection_t connection, CEC_NAMESPACE cec_deck_info info, int bSendUpdate);
  int                                 (CDECL *set_inactive_view)(libcec_connection_t connection);
  int                                 (CDECL *set_menu_state)(libcec_connection_t connection, CEC_NAMESPACE cec_menu_state state, int bSendUpdate);
  int                                 (CDECL *transmit)(libcec_connection_t connection, const CEC_NAMESPACE cec_command* data);
  int                                 (CDECL *set_logical_address)(libcec_connection_t connection, CEC_NAMESPACE cec_logical_address iLogicalAddress);
  int                                 (CDECL *set_physical_address)(libcec_connection_t connection, uint16_t iPhysicalAddress);
  int                                 (CDECL *set_osd_string)(libcec_connection_t connection, CEC_NAMESPACE cec_logical_address iLogicalAddress, CEC_NAMESPACE cec_display_control duration, const char* strMessage);
  int                                 (CDECL *switch_monitoring)(libcec_connection_t connection, int bEnable);
  CEC_NAMESPACE cec_version           (CDECL *get_device_cec_version)(libcec_connection_t connection, CEC_NAMESPACE cec_logical_address iLogicalAddress);
  int                                 (CDECL *get_device_menu_language)(libcec_connection_t connection, CEC_NAMESPACE cec_logical_address iLogicalAddress, CEC_NAMESPACE cec_menu_language* language);
  uint64_t                            (CDECL *get_device_vendor_id)(libcec_connection_t connection, CEC_NAMESPACE cec_logical_address iLogicalAddress);
  uint16_t                            (CDECL *get_device_physical_address)(libcec_connection_t connection, CEC_NAMESPACE cec_logical_address iLogicalAddress);
  CEC_NAMESPACE cec_logical_address   (CDECL *get_active_source)(libcec_connection_t connection);
  int                                 (CDECL *is_active_source)(libcec_connection_t connection, CEC_NAMESPACE cec_logical_address iAddress);
  CEC_NAMESPACE cec_power_status      (CDECL *get_device_power_status)(libcec_connection_t connection, CEC_NAMESPACE cec_logical_address iLogicalAddress);
  int                                 (CDECL *poll_device)(libcec_connection_t connection, CEC_NAMESPACE cec_logical_address iLogicalAddress);
  CEC_NAMESPACE cec_logical_addresses (CDECL *get_active_devices)(libcec_connection_t connection);
  int                                 (CDECL *is_active_device)(libcec_connection_t connection, CEC_NAMESPACE cec_logical_address address);
  int                                 (CDECL *is_active_device_type)(libcec_connection_t connection, CEC_NAMESPACE cec_device_type type);
  int                                 (CDECL *set_hdmi_port)(libcec_connection_t connection, CEC_NAMESPACE cec_logical_address baseDevice, uint8_t iPort);
  int                                 (CDECL *volume_up)(libcec_connection_t connection, int bSendRelease);
  int                                 (CDECL *volume_down)(libcec_connection_t connection, int bSendRelease);
  int                                 (CDECL *mute_audio)(libcec_connection_t connection, int bSendRelease);
  int                                 (CDECL *send_keypress)(libcec_connection_t connection, CEC_NAMESPACE cec_logical_address iDestination, CEC_NAMESPACE cec_user_control_code key, int bWait);
  int                                 (CDECL *send_key_release)(libcec_connection_t connection, CEC_NAMESPACE cec_logical_address iDestination, int bWait);
  CEC_NAMESPACE cec_osd_name          (CDECL *get_device_osd_name)(libcec_connection_t connection, CEC_NAMESPACE cec_logical_address iAddress);
  int                                 (CDECL *set_stream_path_logical)(libcec_connection_t connection, CEC_NAMESPACE cec_logical_address iAddress);
  int                                 (CDECL *set_stream_path_physical)(libcec_connection_t connection, uint16_t iPhysicalAddress);
  CEC_NAMESPACE cec_logical_addresses (CDECL *get_logical_addresses)(libcec_connection_t connection);
  int                                 (CDECL *get_current_configuration)(libcec_connection_t connection, CEC_NAMESPACE libcec_configuration* configuration);
  int                                 (CDECL *can_persist_configuration)(libcec_connection_t connection);
  int                                 (CDECL *persist_configuration)(libcec_connection_t connection, CEC_NAMESPACE libcec_configuration* configuration);
  int                                 (CDECL *set_configuration)(libcec_connection_t connection, const CEC_NAMESPACE libcec_configuration* configuration);
  void                                (CDECL *rescan_devices)(libcec_connection_t connection);
  int                                 (CDECL *is_libcec_active_source)(libcec_connection_t connection);
  int                                 (CDECL *get_device_information)(libcec_connection_t connection, const char* strPort, CEC_NAMESPACE libcec_configuration* config, uint32_t iTimeoutMs);
  const char*                         (CDECL *get_lib_info)(libcec_connection_t connection);
  void                                (CDECL *init_video_standalone)(libcec_connection_t connection);
  uint16_t                            (CDECL *get_adapter_vendor_id)(libcec_connection_t connection);
  uint16_t                            (CDECL *get_adapter_product_id)(libcec_connection_t connection);
  uint8_t                             (CDECL *audio_toggle_mute)(libcec_connection_t connection);
  uint8_t                             (CDECL *audio_mute)(libcec_connection_t connection);
  uint8_t                             (CDECL *audio_unmute)(libcec_connection_t connection);
  uint8_t                             (CDECL *audio_get_status)(libcec_connection_t connection);
  int8_t                              (CDECL *detect_adapters)(libcec_connection_t connection, CEC_NAMESPACE cec_adapter_descriptor* deviceList, uint8_t iBufSize, const char* strDevicePath, int bQuickScan);
  void                                (CDECL *menu_state_to_string)(const CEC_NAMESPACE cec_menu_state state, char* buf, size_t bufsize);
  void                                (CDECL *cec_version_to_string)(const CEC_NAMESPACE cec_version version, char* buf, size_t bufsize);
  void                                (CDECL *power_status_to_string)(const CEC_NAMESPACE cec_power_status status, char* buf, size_t bufsize);
  void                                (CDECL *logical_address_to_string)(const CEC_NAMESPACE cec_logical_address address, char* buf, size_t bufsize);
  void                                (CDECL *deck_control_mode_to_string)(const CEC_NAMESPACE cec_deck_control_mode mode, char* buf, size_t bufsize);
  void                                (CDECL *deck_status_to_string)(const CEC_NAMESPACE cec_deck_info status, char* buf, size_t bufsize);
  void                                (CDECL *opcode_to_string)(const CEC_NAMESPACE cec_opcode opcode, char* buf, size_t bufsize);
  void                                (CDECL *system_audio_status_to_string)(const CEC_NAMESPACE cec_system_audio_status mode, char* buf, size_t bufsize);
  void                                (CDECL *audio_status_to_string)(const CEC_NAMESPACE cec_audio_status status, char* buf, size_t bufsize);
  void                                (CDECL *vendor_id_to_string)(const CEC_NAMESPACE cec_vendor_id vendor, char* buf, size_t bufsize);
  void                                (CDECL *user_control_key_to_string)(const CEC_NAMESPACE cec_user_control_code key, char* buf, size_t bufsize);
  void                                (CDECL *adapter_type_to_string)(const CEC_NAMESPACE cec_adapter_type type, char* buf, size_t bufsize);
  void                                (CDECL *version_to_string)(uint32_t version, char* buf, size_t bufsize);
} libcec_interface_t;

static int libcecc_resolve_all(void* lib, libcec_interface_t* iface)
{
  if (!lib || !iface)
    return -1;

  _libcecc_resolve(lib, iface->destroy,                       "libcec_destroy",                       void(CDECL *)(libcec_connection_t));
  _libcecc_resolve(lib, iface->open,                          "libcec_open",                          int(CDECL *)(libcec_connection_t, const char*, uint32_t));
  _libcecc_resolve(lib, iface->close,                         "libcec_close",                         void(CDECL *)(libcec_connection_t));
  _libcecc_resolve(lib, iface->clear_configuration,           "libcec_clear_configuration",           void(CDECL *)(CEC_NAMESPACE libcec_configuration*));
  _libcecc_resolve(lib, iface->enable_callbacks,              "libcec_enable_callbacks",              int(CDECL *)(libcec_connection_t, void*, CEC_NAMESPACE ICECCallbacks*));
  _libcecc_resolve(lib, iface->find_adapters,                 "libcec_find_adapters",                 int8_t(CDECL *)(libcec_connection_t, CEC_NAMESPACE cec_adapter*, uint8_t, const char*));
  _libcecc_resolve(lib, iface->ping_adapters,                 "libcec_ping_adapters",                 int(CDECL *)(libcec_connection_t));
  _libcecc_resolve(lib, iface->start_bootloader,              "libcec_start_bootloader",              int(CDECL *)(libcec_connection_t));
  _libcecc_resolve(lib, iface->power_on_devices,              "libcec_power_on_devices",              int(CDECL *)(libcec_connection_t, CEC_NAMESPACE cec_logical_address));
  _libcecc_resolve(lib, iface->standby_devices,               "libcec_standby_devices",               int(CDECL *)(libcec_connection_t, CEC_NAMESPACE cec_logical_address));
  _libcecc_resolve(lib, iface->set_active_source,             "libcec_set_active_source",             int(CDECL *)(libcec_connection_t, CEC_NAMESPACE cec_device_type));
  _libcecc_resolve(lib, iface->set_deck_control_mode,         "libcec_set_deck_control_mode",         int(CDECL *)(libcec_connection_t, CEC_NAMESPACE cec_deck_control_mode, int));
  _libcecc_resolve(lib, iface->set_deck_info,                 "libcec_set_deck_info",                 int(CDECL *)(libcec_connection_t, CEC_NAMESPACE cec_deck_info, int));
  _libcecc_resolve(lib, iface->set_inactive_view,             "libcec_set_inactive_view",             int(CDECL *)(libcec_connection_t));
  _libcecc_resolve(lib, iface->set_menu_state,                "libcec_set_menu_state",                int(CDECL *)(libcec_connection_t, CEC_NAMESPACE cec_menu_state, int));
  _libcecc_resolve(lib, iface->transmit,                      "libcec_transmit",                      int(CDECL *)(libcec_connection_t, const CEC_NAMESPACE cec_command*));
  _libcecc_resolve(lib, iface->set_logical_address,           "libcec_set_logical_address",           int(CDECL *)(libcec_connection_t, CEC_NAMESPACE cec_logical_address));
  _libcecc_resolve(lib, iface->set_physical_address,          "libcec_set_physical_address",          int(CDECL *)(libcec_connection_t, uint16_t));
  _libcecc_resolve(lib, iface->set_osd_string,                "libcec_set_osd_string",                int(CDECL *)(libcec_connection_t, CEC_NAMESPACE cec_logical_address, CEC_NAMESPACE cec_display_control, const char*));
  _libcecc_resolve(lib, iface->switch_monitoring,             "libcec_switch_monitoring",             int(CDECL *)(libcec_connection_t, int));
  _libcecc_resolve(lib, iface->get_device_cec_version,        "libcec_get_device_cec_version",        CEC_NAMESPACE cec_version(CDECL *)(libcec_connection_t, CEC_NAMESPACE cec_logical_address));
  _libcecc_resolve(lib, iface->get_device_menu_language,      "libcec_get_device_menu_language",      int(CDECL *)(libcec_connection_t, CEC_NAMESPACE cec_logical_address, CEC_NAMESPACE cec_menu_language*));
  _libcecc_resolve(lib, iface->get_device_vendor_id,          "libcec_get_device_vendor_id",          uint64_t(CDECL *)(libcec_connection_t, CEC_NAMESPACE cec_logical_address));
  _libcecc_resolve(lib, iface->get_device_physical_address,   "libcec_get_device_physical_address",   uint16_t(CDECL *)(libcec_connection_t, CEC_NAMESPACE cec_logical_address));
  _libcecc_resolve(lib, iface->get_active_source,             "libcec_get_active_source",             CEC_NAMESPACE cec_logical_address(CDECL *)(libcec_connection_t));
  _libcecc_resolve(lib, iface->is_active_source,              "libcec_is_active_source",              int(CDECL *)(libcec_connection_t, CEC_NAMESPACE cec_logical_address));
  _libcecc_resolve(lib, iface->get_device_power_status,       "libcec_get_device_power_status",       CEC_NAMESPACE cec_power_status(CDECL *)(libcec_connection_t, CEC_NAMESPACE cec_logical_address));
  _libcecc_resolve(lib, iface->poll_device,                   "libcec_poll_device",                   int(CDECL *)(libcec_connection_t, CEC_NAMESPACE cec_logical_address));
  _libcecc_resolve(lib, iface->get_active_devices,            "libcec_get_active_devices",            CEC_NAMESPACE cec_logical_addresses(CDECL *)(libcec_connection_t));
  _libcecc_resolve(lib, iface->is_active_device,              "libcec_is_active_device",              int(CDECL *)(libcec_connection_t, CEC_NAMESPACE cec_logical_address));
  _libcecc_resolve(lib, iface->is_active_device_type,         "libcec_is_active_device_type",         int(CDECL *)(libcec_connection_t, CEC_NAMESPACE cec_device_type));
  _libcecc_resolve(lib, iface->set_hdmi_port,                 "libcec_set_hdmi_port",                 int(CDECL *)(libcec_connection_t, CEC_NAMESPACE cec_logical_address, uint8_t));
  _libcecc_resolve(lib, iface->volume_up,                     "libcec_volume_up",                     int(CDECL *)(libcec_connection_t, int));
  _libcecc_resolve(lib, iface->volume_down,                   "libcec_volume_down",                   int(CDECL *)(libcec_connection_t, int));
  _libcecc_resolve(lib, iface->mute_audio,                    "libcec_mute_audio",                    int(CDECL *)(libcec_connection_t, int));
  _libcecc_resolve(lib, iface->send_keypress,                 "libcec_send_keypress",                 int(CDECL *)(libcec_connection_t, CEC_NAMESPACE cec_logical_address, CEC_NAMESPACE cec_user_control_code, int));
  _libcecc_resolve(lib, iface->send_key_release,              "libcec_send_key_release",              int(CDECL *)(libcec_connection_t, CEC_NAMESPACE cec_logical_address, int));
  _libcecc_resolve(lib, iface->get_device_osd_name,           "libcec_get_device_osd_name",           CEC_NAMESPACE cec_osd_name(CDECL *)(libcec_connection_t, CEC_NAMESPACE cec_logical_address));
  _libcecc_resolve(lib, iface->set_stream_path_logical,       "libcec_set_stream_path_logical",       int(CDECL *)(libcec_connection_t, CEC_NAMESPACE cec_logical_address));
  _libcecc_resolve(lib, iface->set_stream_path_physical,      "libcec_set_stream_path_physical",      int(CDECL *)(libcec_connection_t, uint16_t));
  _libcecc_resolve(lib, iface->get_logical_addresses,         "libcec_get_logical_addresses",         CEC_NAMESPACE cec_logical_addresses(CDECL *)(libcec_connection_t));
  _libcecc_resolve(lib, iface->get_current_configuration,     "libcec_get_current_configuration",     int(CDECL *)(libcec_connection_t, CEC_NAMESPACE libcec_configuration*));
  _libcecc_resolve(lib, iface->can_persist_configuration,     "libcec_can_persist_configuration",     int(CDECL *)(libcec_connection_t));
  _libcecc_resolve(lib, iface->persist_configuration,         "libcec_persist_configuration",         int(CDECL *)(libcec_connection_t, CEC_NAMESPACE libcec_configuration*));
  _libcecc_resolve(lib, iface->set_configuration,             "libcec_set_configuration",             int(CDECL *)(libcec_connection_t, const CEC_NAMESPACE libcec_configuration*));
  _libcecc_resolve(lib, iface->rescan_devices,                "libcec_rescan_devices",                void(CDECL *)(libcec_connection_t));
  _libcecc_resolve(lib, iface->is_libcec_active_source,       "libcec_is_libcec_active_source",       int(CDECL *)(libcec_connection_t));
  _libcecc_resolve(lib, iface->get_device_information,        "libcec_get_device_information",        int(CDECL *)(libcec_connection_t, const char*, CEC_NAMESPACE libcec_configuration*, uint32_t));
  _libcecc_resolve(lib, iface->get_lib_info,                  "libcec_get_lib_info",                  const char*(CDECL *)(libcec_connection_t));
  _libcecc_resolve(lib, iface->init_video_standalone,         "libcec_init_video_standalone",         void(CDECL *)(libcec_connection_t));
  _libcecc_resolve(lib, iface->get_adapter_vendor_id,         "libcec_get_adapter_vendor_id",         uint16_t(CDECL *)(libcec_connection_t));
  _libcecc_resolve(lib, iface->get_adapter_product_id,        "libcec_get_adapter_product_id",        uint16_t(CDECL *)(libcec_connection_t));
  _libcecc_resolve(lib, iface->audio_toggle_mute,             "libcec_audio_toggle_mute",             uint8_t(CDECL *)(libcec_connection_t));
  _libcecc_resolve(lib, iface->audio_mute,                    "libcec_audio_mute",                    uint8_t(CDECL *)(libcec_connection_t));
  _libcecc_resolve(lib, iface->audio_unmute,                  "libcec_audio_unmute",                  uint8_t(CDECL *)(libcec_connection_t));
  _libcecc_resolve(lib, iface->audio_get_status,              "libcec_audio_get_status",              uint8_t(CDECL *)(libcec_connection_t));
  _libcecc_resolve(lib, iface->detect_adapters,               "libcec_detect_adapters",               int8_t(CDECL *)(libcec_connection_t, CEC_NAMESPACE cec_adapter_descriptor*, uint8_t, const char*, int));
  _libcecc_resolve(lib, iface->menu_state_to_string,          "libcec_menu_state_to_string",          void(CDECL *)(const CEC_NAMESPACE cec_menu_state, char*, size_t));
  _libcecc_resolve(lib, iface->cec_version_to_string,         "libcec_cec_version_to_string",         void(CDECL *)(const CEC_NAMESPACE cec_version, char*, size_t));
  _libcecc_resolve(lib, iface->power_status_to_string,        "libcec_power_status_to_string",        void(CDECL *)(const CEC_NAMESPACE cec_power_status, char*, size_t));
  _libcecc_resolve(lib, iface->logical_address_to_string,     "libcec_logical_address_to_string",     void(CDECL *)(const CEC_NAMESPACE cec_logical_address, char*, size_t));
  _libcecc_resolve(lib, iface->deck_control_mode_to_string,   "libcec_deck_control_mode_to_string",   void(CDECL *)(const CEC_NAMESPACE cec_deck_control_mode, char*, size_t));
  _libcecc_resolve(lib, iface->deck_status_to_string,         "libcec_deck_status_to_string",         void(CDECL *)(const CEC_NAMESPACE cec_deck_info, char*, size_t));
  _libcecc_resolve(lib, iface->opcode_to_string,              "libcec_opcode_to_string",              void(CDECL *)(const CEC_NAMESPACE cec_opcode, char*, size_t));
  _libcecc_resolve(lib, iface->system_audio_status_to_string, "libcec_system_audio_status_to_string", void(CDECL *)(const CEC_NAMESPACE cec_system_audio_status, char*, size_t));
  _libcecc_resolve(lib, iface->audio_status_to_string,        "libcec_audio_status_to_string",        void(CDECL *)(const CEC_NAMESPACE cec_audio_status, char*, size_t));
  _libcecc_resolve(lib, iface->vendor_id_to_string,           "libcec_vendor_id_to_string",           void(CDECL *)(const CEC_NAMESPACE cec_vendor_id, char*, size_t));
  _libcecc_resolve(lib, iface->user_control_key_to_string,    "libcec_user_control_key_to_string",    void(CDECL *)(const CEC_NAMESPACE cec_user_control_code, char*, size_t));
  _libcecc_resolve(lib, iface->adapter_type_to_string,        "libcec_adapter_type_to_string",        void(CDECL *)(const CEC_NAMESPACE cec_adapter_type, char*, size_t));
  _libcecc_resolve(lib, iface->version_to_string,             "libcec_version_to_string",             void(CDECL *)(uint32_t, char*, size_t));

  return 1;
}

static libcecc_lib_instance_t libcecc_load_library(const char* strLib)
{
  libcecc_lib_instance_t lib;
#if defined(_WIN32) || defined(_WIN64)
  lib = LoadLibrary(strLib ? strLib : "cec.dll");
  if (lib == NULL)
    printf("failed to load cec.dll\n");
#else
  #if defined(__APPLE__)
    lib =  dlopen(strLib ? strLib : "libcec." CEC_LIB_VERSION_MAJOR_STR ".dylib", RTLD_LAZY);
  #else
    lib = dlopen(strLib ? strLib : "libcec.so." CEC_LIB_VERSION_MAJOR_STR ".0", RTLD_LAZY);
  #endif
  if (lib == NULL)
    printf("%s\n", dlerror());
#endif
  return lib;
}

static void libcecc_close_library(libcecc_lib_instance_t lib)
{
#if defined(_WIN32) || defined(_WIN64)
  FreeLibrary(lib);
#else
  dlclose(lib);
#endif
}

static void* libcecc_resolve(void* lib, const char* name)
{
#if defined(_WIN32) || defined(_WIN64)
  return GetProcAddress(lib, name);
#else
  return dlsym(lib, name);
#endif
}

void libcecc_reset_configuration(CEC_NAMESPACE libcec_configuration* configuration)
{
  void(CDECL * _clear_configuration)(CEC_NAMESPACE libcec_configuration*);
  libcecc_lib_instance_t lib;

  memset(configuration, 0, sizeof(CEC_NAMESPACE libcec_configuration));
  lib = libcecc_load_library(NULL);
  if (lib == NULL)
    return;

  _clear_configuration = (void(CDECL *)(CEC_NAMESPACE libcec_configuration*)) libcecc_resolve(lib, "libcec_clear_configuration");
  if (_clear_configuration)
    _clear_configuration(configuration);

  libcecc_close_library(lib);
}

/*!
 * @brief Create a new libCEC instance.
 * @param configuration The configuration to pass to libCEC
 * @param strLib The name of and/or path to libCEC
 * @return 1 when loaded, 0 if libCEC failed to initialise, -1 if methods failed to be resolved
 */
int libcecc_initialise(CEC_NAMESPACE libcec_configuration* configuration, libcec_interface_t* iface, const char* strLib)
{
  void* (CDECL *_cec_initialise)(CEC_NAMESPACE libcec_configuration*);

  libcecc_lib_instance_t lib;
  lib = libcecc_load_library(strLib);
  if (lib == NULL)
    return -1;

  _libcecc_resolve(lib, _cec_initialise, "libcec_initialise", void* (CDECL *)(CEC_NAMESPACE libcec_configuration*));

  iface->lib_instance = lib;
  iface->connection   = _cec_initialise(configuration);

  return iface->connection ?
      libcecc_resolve_all(lib, iface) :
      0;
}

/*!
 * @brief Destroy an instance of libCEC.
 * @param device The instance to destroy.
 */
void libcecc_destroy(libcec_interface_t* iface)
{
  if (iface->destroy)
    iface->destroy(iface->connection);
  libcecc_close_library(iface->lib_instance);
  memset(iface, 0, sizeof(libcec_interface_t));
}
                                                                                                                                                                                                                                                                                                                    moonlight-embedded-2.1.1/third_party/moonlight-common-c/                                            0000775 0000000 0000000 00000000000 12563604362 0023310 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        pax_global_header                                                                                   0000666 0000000 0000000 00000000064 12563577644 0014535 g                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        52 comment=4d9cbd3c3dbbd03aebc3bba1e3ea841f6f3dd09f
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            moonlight-embedded-2.1.1/third_party/moonlight-common-c/                                            0000775 0000000 0000000 00000000000 12563577644 0023324 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        moonlight-embedded-2.1.1/third_party/moonlight-common-c/.gitignore                                  0000664 0000000 0000000 00000000231 12563577644 0025310 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        limelight-common/ARM/
limelight-common/Debug/
Build/
**/xcuserdata/
limelight-common/Release/
*.sdf
*.suo
limelight-common/limelight-common.vcxproj.user
                                                                                                                                                                                                                                                                                                                                                                       moonlight-embedded-2.1.1/third_party/moonlight-common-c/README.md                                   0000664 0000000 0000000 00000000627 12563577644 0024610 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #Moonlight

Moonlight-common-c contains common C code between Moonlight clients, including 
[Moonlight Windows](https://github.com/moonlight-stream/moonlight-windows) and
[Moonlight iOS](https://github.com/moonlight-stream/moonlight-ios).

If you are implementing your own Moonlight game streaming client that can use a C library, you will need the code here.

It implements the actual GameStream protocol.
                                                                                                         moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/                           0000775 0000000 0000000 00000000000 12563577644 0026570 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/AudioStream.c              0000664 0000000 0000000 00000015364 12563577644 0031162 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include "Limelight-internal.h"
#include "PlatformSockets.h"
#include "PlatformThreads.h"
#include "LinkedBlockingQueue.h"
#include "RtpReorderQueue.h"

static SOCKET rtpSocket = INVALID_SOCKET;

static LINKED_BLOCKING_QUEUE packetQueue;
static RTP_REORDER_QUEUE rtpReorderQueue;

static PLT_THREAD udpPingThread;
static PLT_THREAD receiveThread;
static PLT_THREAD decoderThread;

static unsigned short lastSeq;

#define RTP_PORT 48000

#define MAX_PACKET_SIZE 100

// This is much larger than we should typically have buffered, but
// it needs to be. We need a cushion in case our thread gets blocked
// for longer than normal.
#define RTP_RECV_BUFFER (64 * MAX_PACKET_SIZE)

typedef struct _QUEUED_AUDIO_PACKET {
	// data must remain at the front
	char data[MAX_PACKET_SIZE];

	int size;
	union {
		RTP_QUEUE_ENTRY rentry;
		LINKED_BLOCKING_QUEUE_ENTRY lentry;
	} q;
} QUEUED_AUDIO_PACKET, *PQUEUED_AUDIO_PACKET;

/* Initialize the audio stream */
void initializeAudioStream(void) {
	if ((AudioCallbacks.capabilities & CAPABILITY_DIRECT_SUBMIT) == 0) {
		LbqInitializeLinkedBlockingQueue(&packetQueue, 30);
	}
	RtpqInitializeQueue(&rtpReorderQueue, RTPQ_DEFAULT_MAX_SIZE, RTPQ_DEFAULT_QUEUE_TIME);
    lastSeq = 0;
}

static void freePacketList(PLINKED_BLOCKING_QUEUE_ENTRY entry) {
	PLINKED_BLOCKING_QUEUE_ENTRY nextEntry;

	while (entry != NULL) {
		nextEntry = entry->flink;

		// The entry is stored within the data allocation
		free(entry->data);

		entry = nextEntry;
	}
}

/* Tear down the audio stream once we're done with it */
void destroyAudioStream(void) {
	if ((AudioCallbacks.capabilities & CAPABILITY_DIRECT_SUBMIT) == 0) {
		freePacketList(LbqDestroyLinkedBlockingQueue(&packetQueue));
	}
	RtpqCleanupQueue(&rtpReorderQueue);
}

static void UdpPingThreadProc(void *context) {
	/* Ping in ASCII */
	char pingData[] = { 0x50, 0x49, 0x4E, 0x47 };
	struct sockaddr_in6 saddr;
	SOCK_RET err;

    memcpy(&saddr, &RemoteAddr, sizeof(saddr));
	saddr.sin6_port = htons(RTP_PORT);

	/* Send PING every 500 milliseconds */
	while (!PltIsThreadInterrupted(&udpPingThread)) {
		err = sendto(rtpSocket, pingData, sizeof(pingData), 0, (struct sockaddr*)&saddr, RemoteAddrLen);
		if (err != sizeof(pingData)) {
			Limelog("Audio Ping: sendto() failed: %d\n", (int)LastSocketError());
			ListenerCallbacks.connectionTerminated(LastSocketError());
			return;
		}

		PltSleepMs(500);
	}
}

static int queuePacketToLbq(PQUEUED_AUDIO_PACKET *packet) {
	int err;

	err = LbqOfferQueueItem(&packetQueue, *packet, &(*packet)->q.lentry);
	if (err == LBQ_SUCCESS) {
		// The LBQ owns the buffer now
		*packet = NULL;
	}
	else if (err == LBQ_BOUND_EXCEEDED) {
		Limelog("Audio packet queue overflow\n");
		freePacketList(LbqFlushQueueItems(&packetQueue));
	}
	else if (err == LBQ_INTERRUPTED) {
		free(*packet);
		return 0;
	}

	return 1;
}

static void decodeInputData(PQUEUED_AUDIO_PACKET packet) {
	PRTP_PACKET rtp;

	rtp = (PRTP_PACKET) &packet->data[0];
	if (lastSeq != 0 && (unsigned short) (lastSeq + 1) != rtp->sequenceNumber) {
		Limelog("Received OOS audio data (expected %d, but got %d)\n", lastSeq + 1, rtp->sequenceNumber);

		AudioCallbacks.decodeAndPlaySample(NULL, 0);
	}

	lastSeq = rtp->sequenceNumber;

	AudioCallbacks.decodeAndPlaySample((char *) (rtp + 1), packet->size - sizeof(*rtp));
}

static void ReceiveThreadProc(void* context) {
	PRTP_PACKET rtp;
	PQUEUED_AUDIO_PACKET packet;
	int queueStatus;

	packet = NULL;

	while (!PltIsThreadInterrupted(&receiveThread)) {
		if (packet == NULL) {
			packet = (PQUEUED_AUDIO_PACKET) malloc(sizeof(*packet));
			if (packet == NULL) {
				Limelog("Audio Receive: malloc() failed\n");
				ListenerCallbacks.connectionTerminated(-1);
				return;
			}
		}

		packet->size = (int) recv(rtpSocket, &packet->data[0], MAX_PACKET_SIZE, 0);
		if (packet->size <= 0) {
			Limelog("Audio Receive: recv() failed: %d\n", (int)LastSocketError());
			free(packet);
			ListenerCallbacks.connectionTerminated(LastSocketError());
			return;
		}

		if (packet->size < sizeof(RTP_PACKET)) {
			// Runt packet
			continue;
		}

		rtp = (PRTP_PACKET) &packet->data[0];
		if (rtp->packetType != 97) {
			// Not audio
			continue;
		}
        
        // RTP sequence number must be in host order for the RTP queue
        rtp->sequenceNumber = htons(rtp->sequenceNumber);

		queueStatus = RtpqAddPacket(&rtpReorderQueue, (PRTP_PACKET) packet, &packet->q.rentry);
		if (queueStatus == RTPQ_RET_HANDLE_IMMEDIATELY) {
			if ((AudioCallbacks.capabilities & CAPABILITY_DIRECT_SUBMIT) == 0) {
				if (!queuePacketToLbq(&packet)) {
					// An exit signal was received
					return;
				}
			} else {
				decodeInputData(packet);
			}
		}
		else {
			if (queueStatus != RTPQ_RET_REJECTED) {
				// The queue consumed our packet, so we must allocate a new one
				packet = NULL;
			}

			if (queueStatus == RTPQ_RET_QUEUED_PACKETS_READY) {
				// If packets are ready, pull them and send them to the decoder
				while ((packet = (PQUEUED_AUDIO_PACKET) RtpqGetQueuedPacket(&rtpReorderQueue)) != NULL) {
					if ((AudioCallbacks.capabilities & CAPABILITY_DIRECT_SUBMIT) == 0) {
						if (!queuePacketToLbq(&packet)) {
							// An exit signal was received
							return;
						}
					} else {
						decodeInputData(packet);
					}
				}
			}
		}
	}
}

static void DecoderThreadProc(void* context) {
	int err;
	PQUEUED_AUDIO_PACKET packet;

	while (!PltIsThreadInterrupted(&decoderThread)) {
		err = LbqWaitForQueueElement(&packetQueue, (void**) &packet);
		if (err != LBQ_SUCCESS) {
            // An exit signal was received
			return;
		}

		decodeInputData(packet);

		free(packet);
	}
}

void stopAudioStream(void) {
	PltInterruptThread(&udpPingThread);
	PltInterruptThread(&receiveThread);
	if ((AudioCallbacks.capabilities & CAPABILITY_DIRECT_SUBMIT) == 0) {
		PltInterruptThread(&decoderThread);
	}

	if (rtpSocket != INVALID_SOCKET) {
		closesocket(rtpSocket);
		rtpSocket = INVALID_SOCKET;
	}

	PltJoinThread(&udpPingThread);
	PltJoinThread(&receiveThread);
	if ((AudioCallbacks.capabilities & CAPABILITY_DIRECT_SUBMIT) == 0) {
		PltJoinThread(&decoderThread);
	}

	PltCloseThread(&udpPingThread);
	PltCloseThread(&receiveThread);
	if ((AudioCallbacks.capabilities & CAPABILITY_DIRECT_SUBMIT) == 0) {
		PltCloseThread(&decoderThread);
	}

    AudioCallbacks.cleanup();
}

int startAudioStream(void) {
	int err;
    
    AudioCallbacks.init();

	rtpSocket = bindUdpSocket(RemoteAddr.ss_family, RTP_RECV_BUFFER);
	if (rtpSocket == INVALID_SOCKET) {
		return LastSocketFail();
	}

	err = PltCreateThread(UdpPingThreadProc, NULL, &udpPingThread);
	if (err != 0) {
		return err;
	}

	err = PltCreateThread(ReceiveThreadProc, NULL, &receiveThread);
	if (err != 0) {
		return err;
	}

	if ((AudioCallbacks.capabilities & CAPABILITY_DIRECT_SUBMIT) == 0) {
		err = PltCreateThread(DecoderThreadProc, NULL, &decoderThread);
		if (err != 0) {
			return err;
		}
	}

	return 0;
}                                                                                                                                                                                                                                                                            moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/ByteBuffer.c               0000664 0000000 0000000 00000005705 12563577644 0031000 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include "ByteBuffer.h"

void BbInitializeWrappedBuffer(PBYTE_BUFFER buff, char* data, int offset, int length, int byteOrder) {
	buff->buffer = data;
	buff->offset = offset;
	buff->length = length;
	buff->position = 0;
	buff->byteOrder = byteOrder;
}

/* Get the long long in the correct byte order */
static long long byteSwapLongLong(PBYTE_BUFFER buff, long long l) {
	if (buff->byteOrder == BYTE_ORDER_BIG) {
		return HTONLL(l);
	}
	else {
		return l;
	}
}

/* Get the int in the correct byte order */
static int byteSwapInt(PBYTE_BUFFER buff, int i) {
	if (buff->byteOrder == BYTE_ORDER_BIG) {
		return htonl(i);
	}
	else {
		return i;
	}
}

/* Get the short in the correct byte order */
static int byteSwapShort(PBYTE_BUFFER buff, short s) {
	if (buff->byteOrder == BYTE_ORDER_BIG) {
		return htons(s);
	}
	else {
		return s;
	}
}

/* Get a byte from the byte buffer */
int BbGet(PBYTE_BUFFER buff, char *c) {
	if (buff->position + sizeof(*c) > buff->length) {
		return 0;
	}

	memcpy(c, &buff->buffer[buff->position], sizeof(*c));
	buff->position += sizeof(*c);

	return 1;
}

/* Get a short from the byte buffer */
int BbGetShort(PBYTE_BUFFER buff, short *s) {
	if (buff->position + sizeof(*s) >= buff->length) {
		return 0;
	}

	memcpy(s, &buff->buffer[buff->position], sizeof(*s));
	buff->position += sizeof(*s);

	*s = byteSwapShort(buff, *s);

	return 1;
}

/* Get an int from the byte buffer */
int BbGetInt(PBYTE_BUFFER buff, int *i) {
	if (buff->position + sizeof(*i) > buff->length) {
		return 0;
	}

	memcpy(i, &buff->buffer[buff->position], sizeof(*i));
	buff->position += sizeof(*i);

	*i = byteSwapInt(buff, *i);

	return 1;
}

/* Get a long from the byte buffer */
int BbGetLong(PBYTE_BUFFER buff, long long *l) {
	if (buff->position + sizeof(*l) > buff->length) {
		return 0;
	}

	memcpy(l, &buff->buffer[buff->position], sizeof(*l));
	buff->position += sizeof(*l);

	*l = byteSwapLongLong(buff, *l);

	return 1;
}

/* Put an int into the byte buffer */
int BbPutInt(PBYTE_BUFFER buff, int i) {
	if (buff->position + sizeof(i) > buff->length) {
		return 0;
	}

	i = byteSwapInt(buff, i);

	memcpy(&buff->buffer[buff->position], &i, sizeof(i));
	buff->position += sizeof(i);

	return 1;
}

/* Put a long into the byte buffer */
int BbPutLong(PBYTE_BUFFER buff, long long l) {
	if (buff->position + sizeof(l) > buff->length) {
		return 0;
	}

	l = byteSwapLongLong(buff, l);

	memcpy(&buff->buffer[buff->position], &l, sizeof(l));
	buff->position += sizeof(l);

	return 1;
}

/* Put a short into the byte buffer */
int BbPutShort(PBYTE_BUFFER buff, short s) {
	if (buff->position + sizeof(s) > buff->length) {
		return 0;
	}

	s = byteSwapShort(buff, s);

	memcpy(&buff->buffer[buff->position], &s, sizeof(s));
	buff->position += sizeof(s);

	return 1;
}

/* Put a byte into the buffer */
int BbPut(PBYTE_BUFFER buff, char c) {
	if (buff->position + sizeof(c) > buff->length) {
		return 0;
	}

	memcpy(&buff->buffer[buff->position], &c, sizeof(c));
	buff->position += sizeof(c);
	
	return 1;
}
                                                           moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/ByteBuffer.h               0000664 0000000 0000000 00000002200 12563577644 0030770 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #pragma once

#include "Platform.h"

#define BYTE_ORDER_LITTLE 1
#define BYTE_ORDER_BIG 2

#ifndef HTONLL
#define HTONLL(x) \
	((((x) & 0xff00000000000000ull) >> 56)				      \
	| (((x) & 0x00ff000000000000ull) >> 40)				      \
	| (((x) & 0x0000ff0000000000ull) >> 24)				      \
	| (((x) & 0x000000ff00000000ull) >> 8)				      \
	| (((x) & 0x00000000ff000000ull) << 8)				      \
	| (((x) & 0x0000000000ff0000ull) << 24)				      \
	| (((x) & 0x000000000000ff00ull) << 40)				      \
	| (((x) & 0x00000000000000ffull) << 56))
#endif

typedef struct _BYTE_BUFFER {
	char* buffer;
	unsigned int offset;
	unsigned int length;
	unsigned int position;
	unsigned int byteOrder;
} BYTE_BUFFER, *PBYTE_BUFFER;

void BbInitializeWrappedBuffer(PBYTE_BUFFER buff, char* data, int offset, int length, int byteOrder);

int BbGet(PBYTE_BUFFER buff, char *c);
int BbGetShort(PBYTE_BUFFER buff, short *s);
int BbGetInt(PBYTE_BUFFER buff, int *i);
int BbGetLong(PBYTE_BUFFER buff, long long *l);

int BbPutInt(PBYTE_BUFFER buff, int i);
int BbPutShort(PBYTE_BUFFER buff, short s);
int BbPut(PBYTE_BUFFER buff, char c);
int BbPutLong(PBYTE_BUFFER buff, long long l);
                                                                                                                                                                                                                                                                                                                                                                                                moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/Connection.c               0000664 0000000 0000000 00000023461 12563577644 0031041 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include "Limelight-internal.h"
#include "Platform.h"

static int stage = STAGE_NONE;
static ConnListenerConnectionTerminated originalTerminationCallback;
static int alreadyTerminated;
static PLT_THREAD terminationCallbackThread;
static long terminationCallbackErrorCode;

// Common globals
struct sockaddr_storage RemoteAddr;
SOCKADDR_LEN RemoteAddrLen;
int ServerMajorVersion;
STREAM_CONFIGURATION StreamConfig;
CONNECTION_LISTENER_CALLBACKS ListenerCallbacks;
DECODER_RENDERER_CALLBACKS VideoCallbacks;
AUDIO_RENDERER_CALLBACKS AudioCallbacks;

/* Connection stages */
static const char* stageNames[STAGE_MAX] = {
	"none",
	"platform initialization",
    "name resolution",
	"RTSP handshake",
	"control stream initialization",
	"video stream initialization",
	"audio stream initialization",
	"input stream initialization",
	"control stream establishment",
	"video stream establishment",
	"audio stream establishment",
	"input stream establishment"
};

/* Get the name of the current stage based on its number */
const char* LiGetStageName(int stage) {
	return stageNames[stage];
}

/* Stop the connection by undoing the step at the current stage and those before it */
void LiStopConnection(void) {
    // Disable termination callbacks now
    alreadyTerminated = 1;
    
	if (stage == STAGE_INPUT_STREAM_START) {
		Limelog("Stopping input stream...");
		stopInputStream();
		stage--;
		Limelog("done\n");
	}
	if (stage == STAGE_AUDIO_STREAM_START) {
		Limelog("Stopping audio stream...");
		stopAudioStream();
		stage--;
		Limelog("done\n");
	}
	if (stage == STAGE_VIDEO_STREAM_START) {
		Limelog("Stopping video stream...");
		stopVideoStream();
		stage--;
		Limelog("done\n");
	}
	if (stage == STAGE_CONTROL_STREAM_START) {
		Limelog("Stopping control stream...");
		stopControlStream();
		stage--;
		Limelog("done\n");
	}
	if (stage == STAGE_INPUT_STREAM_INIT) {
		Limelog("Cleaning up input stream...");
		destroyInputStream();
		stage--;
		Limelog("done\n");
	}
	if (stage == STAGE_AUDIO_STREAM_INIT) {
		Limelog("Cleaning up audio stream...");
		destroyAudioStream();
		stage--;
		Limelog("done\n");
	}
	if (stage == STAGE_VIDEO_STREAM_INIT) {
		Limelog("Cleaning up video stream...");
		destroyVideoStream();
		stage--;
		Limelog("done\n");
	}
	if (stage == STAGE_CONTROL_STREAM_INIT) {
		Limelog("Cleaning up control stream...");
		destroyControlStream();
		stage--;
		Limelog("done\n");
	}
	if (stage == STAGE_RTSP_HANDSHAKE) {
		Limelog("Terminating RTSP handshake...");
		terminateRtspHandshake();
		stage--;
		Limelog("done\n");
	}
    if (stage == STAGE_NAME_RESOLUTION) {
        // Nothing to do
        stage--;
    }
	if (stage == STAGE_PLATFORM_INIT) {
		Limelog("Cleaning up platform...");
		cleanupPlatform();
		stage--;
		Limelog("done\n");
	}
	LC_ASSERT(stage == STAGE_NONE);
}

static void terminationCallbackThreadFunc(void* context)
{
    // Invoke the client's termination callback
    originalTerminationCallback(terminationCallbackErrorCode);
}

// This shim callback runs the client's connectionTerminated() callback on a
// separate thread. This is neccessary because other internal threads directly
// invoke this callback. That can result in a deadlock if the client
// calls LiStopConnection() in the callback when the cleanup code
// attempts to join the thread that the termination callback (and LiStopConnection)
// is running on.
static void ClInternalConnectionTerminated(long errorCode)
{
    int err;

    // Avoid recursion and issuing multiple callbacks
    if (alreadyTerminated) {
        return;
    }

    alreadyTerminated = 1;

    // Invoke the termination callback on a separate thread
    err = PltCreateThread(terminationCallbackThreadFunc, NULL, &terminationCallbackThread);
    if (err != 0) {
        // Nothing we can safely do here, so we'll just assert on debug builds
        Limelog("Failed to create termination thread: %d\n", err);
        LC_ASSERT(err == 0);
    }

    // Close the thread handle since we can never wait on it
    PltCloseThread(&terminationCallbackThread);
}

static int resolveHostName(const char *host)
{
    struct addrinfo hints, *res;
    int err;
    
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_UNSPEC;
    hints.ai_flags = AI_ADDRCONFIG;
    err = getaddrinfo(host, NULL, &hints, &res);
    if (err != 0) {
        Limelog("getaddrinfo() failed: %d\n", err);
        return err;
    }
    
    if (res == NULL) {
        Limelog("getaddrinfo() returned success without addresses\n");
        return -1;
    }
    
    // Use the first address in the list
    memcpy(&RemoteAddr, res->ai_addr, res->ai_addrlen);
    RemoteAddrLen = res->ai_addrlen;
    
    freeaddrinfo(res);
    return 0;
}

/* Starts the connection to the streaming machine */
int LiStartConnection(const char* host, PSTREAM_CONFIGURATION streamConfig, PCONNECTION_LISTENER_CALLBACKS clCallbacks,
	PDECODER_RENDERER_CALLBACKS drCallbacks, PAUDIO_RENDERER_CALLBACKS arCallbacks,
	void* renderContext, int drFlags, int _serverMajorVersion) {
	int err;

    ServerMajorVersion = _serverMajorVersion;
    memcpy(&StreamConfig, streamConfig, sizeof(StreamConfig));

	// Replace missing callbacks with placeholders
	fixupMissingCallbacks(&drCallbacks, &arCallbacks, &clCallbacks);
    memcpy(&VideoCallbacks, drCallbacks, sizeof(VideoCallbacks));
    memcpy(&AudioCallbacks, arCallbacks, sizeof(AudioCallbacks));

	// Hook the termination callback so we can avoid issuing a termination callback
	// after LiStopConnection() is called
	originalTerminationCallback = clCallbacks->connectionTerminated;
	memcpy(&ListenerCallbacks, clCallbacks, sizeof(ListenerCallbacks));
    ListenerCallbacks.connectionTerminated = ClInternalConnectionTerminated;
    
    alreadyTerminated = 0;

	Limelog("Initializing platform...");
	ListenerCallbacks.stageStarting(STAGE_PLATFORM_INIT);
	err = initializePlatform();
	if (err != 0) {
		Limelog("failed: %d\n", err);
		ListenerCallbacks.stageFailed(STAGE_PLATFORM_INIT, err);
		goto Cleanup;
	}
	stage++;
	LC_ASSERT(stage == STAGE_PLATFORM_INIT);
	ListenerCallbacks.stageComplete(STAGE_PLATFORM_INIT);
	Limelog("done\n");
    
    Limelog("Resolving host name...");
    ListenerCallbacks.stageStarting(STAGE_NAME_RESOLUTION);
    err = resolveHostName(host);
    if (err != 0) {
        Limelog("failed: %d\n", err);
        ListenerCallbacks.stageFailed(STAGE_NAME_RESOLUTION, err);
        goto Cleanup;
    }
    stage++;
    LC_ASSERT(stage == STAGE_NAME_RESOLUTION);
    ListenerCallbacks.stageComplete(STAGE_NAME_RESOLUTION);
    Limelog("done\n");

	Limelog("Starting RTSP handshake...");
	ListenerCallbacks.stageStarting(STAGE_RTSP_HANDSHAKE);
	err = performRtspHandshake();
	if (err != 0) {
		Limelog("failed: %d\n", err);
		ListenerCallbacks.stageFailed(STAGE_RTSP_HANDSHAKE, err);
		goto Cleanup;
	}
	stage++;
	LC_ASSERT(stage == STAGE_RTSP_HANDSHAKE);
	ListenerCallbacks.stageComplete(STAGE_RTSP_HANDSHAKE);
	Limelog("done\n");

	Limelog("Initializing control stream...");
	ListenerCallbacks.stageStarting(STAGE_CONTROL_STREAM_INIT);
	err = initializeControlStream();
	if (err != 0) {
		Limelog("failed: %d\n", err);
		ListenerCallbacks.stageFailed(STAGE_CONTROL_STREAM_INIT, err);
		goto Cleanup;
	}
	stage++;
	LC_ASSERT(stage == STAGE_CONTROL_STREAM_INIT);
	ListenerCallbacks.stageComplete(STAGE_CONTROL_STREAM_INIT);
	Limelog("done\n");

	Limelog("Initializing video stream...");
	ListenerCallbacks.stageStarting(STAGE_VIDEO_STREAM_INIT);
	initializeVideoStream();
	stage++;
	LC_ASSERT(stage == STAGE_VIDEO_STREAM_INIT);
	ListenerCallbacks.stageComplete(STAGE_VIDEO_STREAM_INIT);
	Limelog("done\n");

	Limelog("Initializing audio stream...");
	ListenerCallbacks.stageStarting(STAGE_AUDIO_STREAM_INIT);
	initializeAudioStream();
	stage++;
	LC_ASSERT(stage == STAGE_AUDIO_STREAM_INIT);
	ListenerCallbacks.stageComplete(STAGE_AUDIO_STREAM_INIT);
	Limelog("done\n");

	Limelog("Initializing input stream...");
	ListenerCallbacks.stageStarting(STAGE_INPUT_STREAM_INIT);
	initializeInputStream(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey),
		streamConfig->remoteInputAesIv, sizeof(streamConfig->remoteInputAesIv));
	stage++;
	LC_ASSERT(stage == STAGE_INPUT_STREAM_INIT);
	ListenerCallbacks.stageComplete(STAGE_INPUT_STREAM_INIT);
	Limelog("done\n");

	Limelog("Starting control stream...");
	ListenerCallbacks.stageStarting(STAGE_CONTROL_STREAM_START);
	err = startControlStream();
	if (err != 0) {
		Limelog("failed: %d\n", err);
		ListenerCallbacks.stageFailed(STAGE_CONTROL_STREAM_START, err);
		goto Cleanup;
	}
	stage++;
	LC_ASSERT(stage == STAGE_CONTROL_STREAM_START);
	ListenerCallbacks.stageComplete(STAGE_CONTROL_STREAM_START);
	Limelog("done\n");

	Limelog("Starting video stream...");
	ListenerCallbacks.stageStarting(STAGE_VIDEO_STREAM_START);
	err = startVideoStream(renderContext, drFlags);
	if (err != 0) {
		Limelog("Video stream start failed: %d\n", err);
		ListenerCallbacks.stageFailed(STAGE_VIDEO_STREAM_START, err);
		goto Cleanup;
	}
	stage++;
	LC_ASSERT(stage == STAGE_VIDEO_STREAM_START);
	ListenerCallbacks.stageComplete(STAGE_VIDEO_STREAM_START);
	Limelog("done\n");

	Limelog("Starting audio stream...");
	ListenerCallbacks.stageStarting(STAGE_AUDIO_STREAM_START);
	err = startAudioStream();
	if (err != 0) {
		Limelog("Audio stream start failed: %d\n", err);
		ListenerCallbacks.stageFailed(STAGE_AUDIO_STREAM_START, err);
		goto Cleanup;
	}
	stage++;
	LC_ASSERT(stage == STAGE_AUDIO_STREAM_START);
	ListenerCallbacks.stageComplete(STAGE_AUDIO_STREAM_START);
	Limelog("done\n");

	Limelog("Starting input stream...");
	ListenerCallbacks.stageStarting(STAGE_INPUT_STREAM_START);
	err = startInputStream();
	if (err != 0) {
		Limelog("Input stream start failed: %d\n", err);
		ListenerCallbacks.stageFailed(STAGE_INPUT_STREAM_START, err);
		goto Cleanup;
	}
	stage++;
	LC_ASSERT(stage == STAGE_INPUT_STREAM_START);
	ListenerCallbacks.stageComplete(STAGE_INPUT_STREAM_START);
	Limelog("done\n");

	ListenerCallbacks.connectionStarted();

Cleanup:
	return err;
}
                                                                                                                                                                                                               moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/ControlStream.c            0000664 0000000 0000000 00000030615 12563577644 0031535 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include "Limelight-internal.h"
#include "PlatformSockets.h"
#include "PlatformThreads.h"

#include "ByteBuffer.h"

/* NV control stream packet header */
typedef struct _NVCTL_PACKET_HEADER {
	unsigned short type;
	unsigned short payloadLength;
} NVCTL_PACKET_HEADER, *PNVCTL_PACKET_HEADER;

typedef struct _QUEUED_FRAME_INVALIDATION_TUPLE {
	int startFrame;
	int endFrame;
	LINKED_BLOCKING_QUEUE_ENTRY entry;
} QUEUED_FRAME_INVALIDATION_TUPLE, *PQUEUED_FRAME_INVALIDATION_TUPLE;

static SOCKET ctlSock = INVALID_SOCKET;
static PLT_THREAD lossStatsThread;
static PLT_THREAD invalidateRefFramesThread;
static PLT_EVENT invalidateRefFramesEvent;
static int lossCountSinceLastReport;
static long currentFrame;

static int idrFrameRequired;
static LINKED_BLOCKING_QUEUE invalidReferenceFrameTuples;

#define IDX_START_A 0
#define IDX_REQUEST_IDR_FRAME 0
#define IDX_START_B 1
#define IDX_INVALIDATE_REF_FRAMES 2
#define IDX_LOSS_STATS 3

static const short packetTypesGen3[] = {
    0x140b, // Start A
    0x1410, // Start B
    0x1404, // Invalidate reference frames
    0x140c, // Loss Stats
    0x1417, // Frame Stats (unused)
};
static const short packetTypesGen4[] = {
    0x0606, // Request IDR frame
    0x0609, // Start B
    0x0604, // Invalidate reference frames
    0x060a, // Loss Stats
    0x0611, // Frame Stats (unused)
};

static const char startAGen3[] = {0};
static const int startBGen3[] = {0, 0, 0, 0xa};

static const char requestIdrFrameGen4[] = {0, 0};
static const char startBGen4[] = {0};

static const short payloadLengthsGen3[] = {
    sizeof(startAGen3), // Start A
    sizeof(startBGen3), // Start B
    24, // Invalidate reference frames
    32, // Loss Stats
    64, // Frame Stats
};
static const short payloadLengthsGen4[] = {
    sizeof(requestIdrFrameGen4), // Request IDR frame
    sizeof(startBGen4), // Start B
    24, // Invalidate reference frames
    32, // Loss Stats
    64, // Frame Stats
};

static const char* preconstructedPayloadsGen3[] = {
    startAGen3,
    (char*)startBGen3
};
static const char* preconstructedPayloadsGen4[] = {
    requestIdrFrameGen4,
    startBGen4
};

static short *packetTypes;
static short *payloadLengths;
static char **preconstructedPayloads;

#define LOSS_REPORT_INTERVAL_MS 50

/* Initializes the control stream */
int initializeControlStream(void) {
	PltCreateEvent(&invalidateRefFramesEvent);
	LbqInitializeLinkedBlockingQueue(&invalidReferenceFrameTuples, 20);
    
    if (ServerMajorVersion == 3) {
        packetTypes = (short*)packetTypesGen3;
        payloadLengths = (short*)payloadLengthsGen3;
        preconstructedPayloads = (char**)preconstructedPayloadsGen3;
    }
    else {
        packetTypes = (short*)packetTypesGen4;
        payloadLengths = (short*)payloadLengthsGen4;
        preconstructedPayloads = (char**)preconstructedPayloadsGen4;
    }

    idrFrameRequired = 0;
    currentFrame = 0;
    lossCountSinceLastReport = 0;

	return 0;
}

void freeFrameInvalidationList(PLINKED_BLOCKING_QUEUE_ENTRY entry) {
	PLINKED_BLOCKING_QUEUE_ENTRY nextEntry;

	while (entry != NULL) {
		nextEntry = entry->flink;
		free(entry->data);
		entry = nextEntry;
	}
}

/* Cleans up control stream */
void destroyControlStream(void) {
    PltCloseEvent(&invalidateRefFramesEvent);
    freeFrameInvalidationList(LbqDestroyLinkedBlockingQueue(&invalidReferenceFrameTuples));
}

int getNextFrameInvalidationTuple(PQUEUED_FRAME_INVALIDATION_TUPLE *qfit) {
	int err = LbqPollQueueElement(&invalidReferenceFrameTuples, (void**) qfit);
	return (err == LBQ_SUCCESS);
}

void queueFrameInvalidationTuple(int startFrame, int endFrame) {

    if (VideoCallbacks.capabilities & CAPABILITY_REFERENCE_FRAME_INVALIDATION) {
        PQUEUED_FRAME_INVALIDATION_TUPLE qfit;
        qfit = malloc(sizeof(*qfit));
        if (qfit != NULL) {
            qfit->startFrame = startFrame;
            qfit->endFrame = endFrame;
            if (LbqOfferQueueItem(&invalidReferenceFrameTuples, qfit, &qfit->entry) == LBQ_BOUND_EXCEEDED) {
                // Too many invalidation tuples, so we need an IDR frame now
                free(qfit);
                idrFrameRequired = 1;
            }
        }
        else {
            idrFrameRequired = 1;
        }
    }
    else {
        idrFrameRequired = 1;
    }

    PltSetEvent(&invalidateRefFramesEvent);
}

/* Request an IDR frame on demand by the decoder */
void requestIdrOnDemand(void) {
    idrFrameRequired = 1;
    PltSetEvent(&invalidateRefFramesEvent);
}

/* Invalidate reference frames if the decoder is too slow */
void connectionSinkTooSlow(int startFrame, int endFrame) {
    queueFrameInvalidationTuple(startFrame, endFrame);
}

/* Invalidate reference frames lost by the network */
void connectionDetectedFrameLoss(int startFrame, int endFrame) {
    queueFrameInvalidationTuple(startFrame, endFrame);
}

/* When we receive a frame, update the number of our current frame */
void connectionReceivedFrame(int frameIndex) {
	currentFrame = frameIndex;
}

/* When we lose packets, update our packet loss count */
void connectionLostPackets(int lastReceivedPacket, int nextReceivedPacket) {
	lossCountSinceLastReport += (nextReceivedPacket - lastReceivedPacket) - 1;
}

/* Reads an NV control stream packet */
static PNVCTL_PACKET_HEADER readNvctlPacket(void) {
	NVCTL_PACKET_HEADER staticHeader;
	PNVCTL_PACKET_HEADER fullPacket;
	SOCK_RET err;

	err = recv(ctlSock, (char*) &staticHeader, sizeof(staticHeader), 0);
	if (err != sizeof(staticHeader)) {
		return NULL;
	}

	fullPacket = (PNVCTL_PACKET_HEADER) malloc(staticHeader.payloadLength + sizeof(staticHeader));
	if (fullPacket == NULL) {
		return NULL;
	}

	memcpy(fullPacket, &staticHeader, sizeof(staticHeader));
	if (staticHeader.payloadLength != 0) {
		err = recv(ctlSock, (char*) (fullPacket + 1), staticHeader.payloadLength, 0);
		if (err != staticHeader.payloadLength) {
			free(fullPacket);
			return NULL;
		}
	}

	return fullPacket;
}

static int sendMessageAndForget(short ptype, short paylen, const void* payload) {
	PNVCTL_PACKET_HEADER packet;
	SOCK_RET err;

	packet = malloc(sizeof(*packet) + paylen);
	if (packet == NULL) {
		return 0;
	}

	packet->type = ptype;
	packet->payloadLength = paylen;
	memcpy(&packet[1], payload, paylen);

	err = send(ctlSock, (char*) packet, sizeof(*packet) + paylen, 0);
	free(packet);

	if (err != sizeof(*packet) + paylen) {
		return 0;
	}

	return 1;
}

static PNVCTL_PACKET_HEADER sendMessage(short ptype, short paylen, const void* payload) {
    if (!sendMessageAndForget(ptype, paylen, payload)) {
        return NULL;
    }

	return readNvctlPacket();
}

static int sendMessageAndDiscardReply(short ptype, short paylen, const void* payload) {
    PNVCTL_PACKET_HEADER reply;
    
    reply = sendMessage(ptype, paylen, payload);
    if (reply == NULL) {
        return 0;
    }
    
    free(reply);
    return 1;
}

static void lossStatsThreadFunc(void* context) {
	char *lossStatsPayload;
	BYTE_BUFFER byteBuffer;

	lossStatsPayload = malloc(payloadLengths[IDX_LOSS_STATS]);
	if (lossStatsPayload == NULL) {
		Limelog("Loss Stats: malloc() failed\n");
		ListenerCallbacks.connectionTerminated(-1);
		return;
	}

	while (!PltIsThreadInterrupted(&lossStatsThread)) {
		// Construct the payload
		BbInitializeWrappedBuffer(&byteBuffer, lossStatsPayload, 0, payloadLengths[IDX_LOSS_STATS], BYTE_ORDER_LITTLE);
		BbPutInt(&byteBuffer, lossCountSinceLastReport);
		BbPutInt(&byteBuffer, LOSS_REPORT_INTERVAL_MS);
		BbPutInt(&byteBuffer, 1000);
		BbPutLong(&byteBuffer, currentFrame);
		BbPutInt(&byteBuffer, 0);
		BbPutInt(&byteBuffer, 0);
		BbPutInt(&byteBuffer, 0x14);

		// Send the message (and don't expect a response)
		if (!sendMessageAndForget(packetTypes[IDX_LOSS_STATS],
			payloadLengths[IDX_LOSS_STATS], lossStatsPayload)) {
			free(lossStatsPayload);
			Limelog("Loss Stats: Transaction failed: %d\n", (int)LastSocketError());
            ListenerCallbacks.connectionTerminated(LastSocketError());
			return;
		}

		// Clear the transient state
		lossCountSinceLastReport = 0;

		// Wait a bit
		PltSleepMs(LOSS_REPORT_INTERVAL_MS);
	}

	free(lossStatsPayload);
}

static void requestIdrFrame(void) {
    long long payload[3];

    if (ServerMajorVersion == 3) {
        // Form the payload
        payload[0] = 0;
        payload[1] = 0xFFFFF;
        payload[2] = 0;

        // Send the reference frame invalidation request and read the response
        if (!sendMessageAndDiscardReply(packetTypes[IDX_INVALIDATE_REF_FRAMES],
            payloadLengths[IDX_INVALIDATE_REF_FRAMES], payload)) {
            Limelog("Request IDR Frame: Transaction failed: %d\n", (int) LastSocketError());
            ListenerCallbacks.connectionTerminated(LastSocketError());
            return;
        }
    }
    else {
        // Send IDR frame request and read the response
        if (!sendMessageAndDiscardReply(packetTypes[IDX_REQUEST_IDR_FRAME],
            payloadLengths[IDX_REQUEST_IDR_FRAME], preconstructedPayloads[IDX_REQUEST_IDR_FRAME])) {
            Limelog("Request IDR Frame: Transaction failed: %d\n", (int) LastSocketError());
            ListenerCallbacks.connectionTerminated(LastSocketError());
            return;
        }
    }

    Limelog("IDR frame request sent\n");
}

static void requestInvalidateReferenceFrames(void) {
    long long payload[3];
    PQUEUED_FRAME_INVALIDATION_TUPLE qfit;

    LC_ASSERT(VideoCallbacks.capabilities & CAPABILITY_REFERENCE_FRAME_INVALIDATION);

    if (!getNextFrameInvalidationTuple(&qfit)) {
        return;
    }

    LC_ASSERT(qfit->startFrame <= qfit->endFrame);

    payload[0] = qfit->startFrame;
    payload[1] = qfit->endFrame;
    payload[2] = 0;

    // Aggregate all lost frames into one range
    do {
        LC_ASSERT(qfit->endFrame >= payload[1]);
        payload[1] = qfit->endFrame;
        free(qfit);
    } while (getNextFrameInvalidationTuple(&qfit));

    // Send the reference frame invalidation request and read the response
    if (!sendMessageAndDiscardReply(packetTypes[IDX_INVALIDATE_REF_FRAMES],
        payloadLengths[IDX_INVALIDATE_REF_FRAMES], payload)) {
        Limelog("Request Invaldiate Reference Frames: Transaction failed: %d\n", (int) LastSocketError());
        ListenerCallbacks.connectionTerminated(LastSocketError());
        return;
    }

    Limelog("Invalidate reference frame request sent\n");
}

static void invalidateRefFramesFunc(void* context) {
    while (!PltIsThreadInterrupted(&invalidateRefFramesThread)) {
        // Wait for a request to invalidate reference frames
        PltWaitForEvent(&invalidateRefFramesEvent);
        PltClearEvent(&invalidateRefFramesEvent);

        // Sometimes we absolutely need an IDR frame
        if (idrFrameRequired) {
            // Empty invalidate reference frames tuples
            PQUEUED_FRAME_INVALIDATION_TUPLE qfit;
            while (getNextFrameInvalidationTuple(&qfit)) {
                free(qfit);
            }

            // Send an IDR frame request
            idrFrameRequired = 0;
            requestIdrFrame();
        } else {
            // Otherwise invalidate reference frames
            requestInvalidateReferenceFrames();
        }
    }
}

/* Stops the control stream */
int stopControlStream(void) {
	PltInterruptThread(&lossStatsThread);
	PltInterruptThread(&invalidateRefFramesThread);

	if (ctlSock != INVALID_SOCKET) {
		closesocket(ctlSock);
		ctlSock = INVALID_SOCKET;
	}

	PltJoinThread(&lossStatsThread);
	PltJoinThread(&invalidateRefFramesThread);

	PltCloseThread(&lossStatsThread);
	PltCloseThread(&invalidateRefFramesThread);

	return 0;
}

/* Starts the control stream */
int startControlStream(void) {
	int err;

	ctlSock = connectTcpSocket(&RemoteAddr, RemoteAddrLen, 47995);
	if (ctlSock == INVALID_SOCKET) {
		return LastSocketFail();
	}

	enableNoDelay(ctlSock);

	// Send START A
	if (!sendMessageAndDiscardReply(packetTypes[IDX_START_A],
                                    payloadLengths[IDX_START_A],
                                    preconstructedPayloads[IDX_START_A])) {
        Limelog("Start A failed: %d\n", (int)LastSocketError());
        return LastSocketFail();
    }

	// Send START B
    if (!sendMessageAndDiscardReply(packetTypes[IDX_START_B],
                                    payloadLengths[IDX_START_B],
                                    preconstructedPayloads[IDX_START_B])) {
        Limelog("Start B failed: %d\n", (int)LastSocketError());
        return LastSocketFail();
    }

	err = PltCreateThread(lossStatsThreadFunc, NULL, &lossStatsThread);
	if (err != 0) {
		return err;
	}

	err = PltCreateThread(invalidateRefFramesFunc, NULL, &invalidateRefFramesThread);
	if (err != 0) {
		return err;
	}

	return 0;
}                                                                                                                   moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/FakeCallbacks.c            0000664 0000000 0000000 00000006225 12563577644 0031407 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include "Limelight-internal.h"

static void fakeDrSetup(int width, int height, int redrawRate, void* context, int drFlags) {}
static void fakeDrCleanup(void) {}
static int fakeDrSubmitDecodeUnit(PDECODE_UNIT decodeUnit) { return DR_OK; }

static DECODER_RENDERER_CALLBACKS fakeDrCallbacks = {
	.setup = fakeDrSetup,
	.cleanup = fakeDrCleanup,
	.submitDecodeUnit = fakeDrSubmitDecodeUnit,
};

static void fakeArInit(void) {}
static void fakeArCleanup(void) {}
static void fakeArDecodeAndPlaySample(char* sampleData, int sampleLength) {}

AUDIO_RENDERER_CALLBACKS fakeArCallbacks = {
	.init = fakeArInit,
	.cleanup = fakeArCleanup,
	.decodeAndPlaySample = fakeArDecodeAndPlaySample,
};

static void fakeClStageStarting(int stage) {}
static void fakeClStageComplete(int stage) {}
static void fakeClStageFailed(int stage, long errorCode) {}
static void fakeClConnectionStarted(void) {}
static void fakeClConnectionTerminated(long errorCode) {}
static void fakeClDisplayMessage(char* message) {}
static void fakeClDisplayTransientMessage(char* message) {}

static CONNECTION_LISTENER_CALLBACKS fakeClCallbacks = {
	.stageStarting = fakeClStageStarting,
	.stageComplete = fakeClStageComplete,
	.stageFailed = fakeClStageFailed,
	.connectionStarted = fakeClConnectionStarted,
	.connectionTerminated = fakeClConnectionTerminated,
	.displayMessage = fakeClDisplayMessage,
	.displayTransientMessage = fakeClDisplayTransientMessage,
};

void fixupMissingCallbacks(PDECODER_RENDERER_CALLBACKS *drCallbacks, PAUDIO_RENDERER_CALLBACKS *arCallbacks,
	PCONNECTION_LISTENER_CALLBACKS *clCallbacks)
{
	if (*drCallbacks == NULL) {
		*drCallbacks = &fakeDrCallbacks;
	}
	else {
		if ((*drCallbacks)->setup == NULL) {
			(*drCallbacks)->setup = fakeDrSetup;
		}
		if ((*drCallbacks)->cleanup == NULL) {
			(*drCallbacks)->cleanup = fakeDrCleanup;
		}
		if ((*drCallbacks)->submitDecodeUnit == NULL) {
			(*drCallbacks)->submitDecodeUnit = fakeDrSubmitDecodeUnit;
		}
	}

	if (*arCallbacks == NULL) {
		*arCallbacks = &fakeArCallbacks;
	}
	else {
		if ((*arCallbacks)->init == NULL) {
			(*arCallbacks)->init = fakeArInit;
		}
		if ((*arCallbacks)->cleanup == NULL) {
            (*arCallbacks)->cleanup = fakeArCleanup;
		}
		if ((*arCallbacks)->decodeAndPlaySample == NULL) {
			(*arCallbacks)->decodeAndPlaySample = fakeArDecodeAndPlaySample;
		}
	}

	if (*clCallbacks == NULL) {
		*clCallbacks = &fakeClCallbacks;
	}
	else {
		if ((*clCallbacks)->stageStarting == NULL) {
			(*clCallbacks)->stageStarting = fakeClStageStarting;
		}
		if ((*clCallbacks)->stageComplete == NULL) {
			(*clCallbacks)->stageComplete = fakeClStageComplete;
		}
		if ((*clCallbacks)->stageFailed == NULL) {
			(*clCallbacks)->stageFailed = fakeClStageFailed;
		}
		if ((*clCallbacks)->connectionStarted == NULL) {
			(*clCallbacks)->connectionStarted = fakeClConnectionStarted;
		}
		if ((*clCallbacks)->connectionTerminated == NULL) {
			(*clCallbacks)->connectionTerminated = fakeClConnectionTerminated;
		}
		if ((*clCallbacks)->displayMessage == NULL) {
			(*clCallbacks)->displayMessage = fakeClDisplayMessage;
		}
		if ((*clCallbacks)->displayTransientMessage == NULL) {
			(*clCallbacks)->displayTransientMessage = fakeClDisplayTransientMessage;
		}
	}
}                                                                                                                                                                                                                                                                                                                                                                           moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/Input.h                    0000664 0000000 0000000 00000004116 12563577644 0030042 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #pragma once

#pragma pack(push, 1)

typedef struct _NV_INPUT_HEADER {
	int packetType;
} NV_INPUT_HEADER, PNV_INPUT_HEADER;

#define PACKET_TYPE_KEYBOARD 0x0A
typedef struct _NV_KEYBOARD_PACKET {
	NV_INPUT_HEADER header;
	char keyAction;
	int zero1;
	short keyCode;
	char modifiers;
	short zero2;
} NV_KEYBOARD_PACKET, *PNV_KEYBOARD_PACKET;

#define PACKET_TYPE_MOUSE_MOVE 0x08
#define MOUSE_MOVE_MAGIC 0x06000000
typedef struct _NV_MOUSE_MOVE_PACKET {
	NV_INPUT_HEADER header;
	int magic;
	short deltaX;
	short deltaY;
} NV_MOUSE_MOVE_PACKET, *PNV_MOUSE_MOVE_PACKET;

#define PACKET_TYPE_MOUSE_BUTTON 0x05
typedef struct _NV_MOUSE_BUTTON_PACKET {
	NV_INPUT_HEADER header;
	char action;
	int button;
} NV_MOUSE_BUTTON_PACKET, *PNV_MOUSE_BUTTON_PACKET;

#define PACKET_TYPE_CONTROLLER 0x18
#define C_HEADER_A 0x0000000A
#define C_HEADER_B 0x1400
#define C_TAIL_A 0x0000009C
#define C_TAIL_B 0x0055
typedef struct _NV_CONTROLLER_PACKET {
	NV_INPUT_HEADER header;
	int headerA;
	short headerB;
	short buttonFlags;
	unsigned char leftTrigger;
	unsigned char rightTrigger;
	short leftStickX;
	short leftStickY;
	short rightStickX;
	short rightStickY;
	int tailA;
	short tailB;
} NV_CONTROLLER_PACKET, *PNV_CONTROLLER_PACKET;

#define PACKET_TYPE_MULTI_CONTROLLER 0x1E
#define MC_HEADER_A 0x0000000D
#define MC_HEADER_B 0x001A
#define MC_MID_A 0x0007
#define MC_MID_B 0x0014
#define MC_TAIL_A 0x0000009C
#define MC_TAIL_B 0x0055
typedef struct _NV_MULTI_CONTROLLER_PACKET {
    NV_INPUT_HEADER header;
    int headerA;
    short headerB;
    short controllerNumber;
    short midA;
    short midB;
    short buttonFlags;
    unsigned char leftTrigger;
    unsigned char rightTrigger;
    short leftStickX;
    short leftStickY;
    short rightStickX;
    short rightStickY;
    int tailA;
    short tailB;
} NV_MULTI_CONTROLLER_PACKET, *PNV_MULTI_CONTROLLER_PACKET;

#define PACKET_TYPE_SCROLL 0xA
#define MAGIC_A 0x09
typedef struct _NV_SCROLL_PACKET {
	NV_INPUT_HEADER header;
	char magicA;
	char zero1;
	short zero2;
	short scrollAmt1;
	short scrollAmt2;
	short zero3;
} NV_SCROLL_PACKET, *PNV_SCROLL_PACKET;

#pragma pack(pop)
                                                                                                                                                                                                                                                                                                                                                                                                                                                  moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/InputStream.c              0000664 0000000 0000000 00000037456 12563577644 0031226 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include "Limelight-internal.h"
#include "PlatformSockets.h"
#include "PlatformThreads.h"
#include "LinkedBlockingQueue.h"
#include "Input.h"

#include "OpenAES/oaes_lib.h"
#include "OpenAES/oaes_common.h"

static SOCKET inputSock = INVALID_SOCKET;
static int initialized;

static LINKED_BLOCKING_QUEUE packetQueue;
static PLT_THREAD inputSendThread;
static OAES_CTX* oaesContext;

#define MAX_INPUT_PACKET_SIZE 128

/* Contains input stream packets */
typedef struct _PACKET_HOLDER {
	int packetLength;
	union {
		NV_KEYBOARD_PACKET keyboard;
		NV_MOUSE_MOVE_PACKET mouseMove;
		NV_MOUSE_BUTTON_PACKET mouseButton;
		NV_CONTROLLER_PACKET controller;
        NV_MULTI_CONTROLLER_PACKET multiController;
		NV_SCROLL_PACKET scroll;
	} packet;
	LINKED_BLOCKING_QUEUE_ENTRY entry;
} PACKET_HOLDER, *PPACKET_HOLDER;

/* Initializes the input stream */
int initializeInputStream(char* aesKeyData, int aesKeyDataLength,
                          char* aesIv, int aesIvLength) {
	if (aesIvLength != OAES_BLOCK_SIZE)
	{
		Limelog("AES IV is incorrect length. Should be %d\n", aesIvLength);
		return -1;
	}

	oaesContext = oaes_alloc();
	if (oaesContext == NULL)
	{
		Limelog("Failed to allocate OpenAES context\n");
		return -1;
	}

	if (oaes_set_option(oaesContext, OAES_OPTION_CBC, aesIv) != OAES_RET_SUCCESS)
	{
		Limelog("Failed to set CBC and IV on OAES context\n");
		return -1;
	}

	if (oaes_key_import_data(oaesContext, (const unsigned char*)aesKeyData, aesKeyDataLength) != OAES_RET_SUCCESS)
	{
		Limelog("Failed to import AES key data\n");
		return -1;
	}

	LbqInitializeLinkedBlockingQueue(&packetQueue, 30);

	initialized = 1;
	return 0;
}

/* Destroys and cleans up the input stream */
void destroyInputStream(void) {
	PLINKED_BLOCKING_QUEUE_ENTRY entry, nextEntry;

	if (oaesContext != NULL)
	{
		// FIXME: This crashes trying to free ctx->key
        // oaes_free(oaesContext);
		oaesContext = NULL;
	}

	entry = LbqDestroyLinkedBlockingQueue(&packetQueue);

	while (entry != NULL) {
		nextEntry = entry->flink;

		// The entry is stored in the data buffer
		free(entry->data);

		entry = nextEntry;
	}

	initialized = 0;
}

// Checks if values are compatible with controller batching
static int checkDirs(short currentVal, short newVal, int* dir) {
    if (currentVal == newVal) {
        return 1;
    }
    
    // We want to send a new packet if we've now zeroed an axis
    if (newVal == 0) {
        return 0;
    }
    
    if (*dir == 0) {
        if (newVal < currentVal) {
            *dir = -1;
        }
        else {
            *dir = 1;
        }
    }
    else if (*dir == -1) {
        return newVal < currentVal;
    }
    else if (newVal < currentVal) {
        return 0;
    }
    
    return 1;
}

#define OAES_DATA_OFFSET 32

/* Input thread proc */
static void inputSendThreadProc(void* context) {
	SOCK_RET err;
	PPACKET_HOLDER holder;
	char encryptedBuffer[MAX_INPUT_PACKET_SIZE];
	size_t encryptedSize;

	while (!PltIsThreadInterrupted(&inputSendThread)) {
		int encryptedLengthPrefix;

		err = LbqWaitForQueueElement(&packetQueue, (void**) &holder);
		if (err != LBQ_SUCCESS) {
			return;
		}
        
        // If it's a multi-controller packet we can do batching
        if (holder->packet.multiController.header.packetType == htonl(PACKET_TYPE_MULTI_CONTROLLER)) {
            PPACKET_HOLDER controllerBatchHolder;
            PNV_MULTI_CONTROLLER_PACKET origPkt;
            int dirs[6];
            
            memset(dirs, 0, sizeof(dirs));
            
            origPkt = &holder->packet.multiController;
            for (;;) {
                PNV_MULTI_CONTROLLER_PACKET newPkt;
                
                // Peek at the next packet
                if (LbqPeekQueueElement(&packetQueue, (void**)&controllerBatchHolder) != LBQ_SUCCESS) {
                    break;
                }
                
                // If it's not a controller packet, we're done
                if (controllerBatchHolder->packet.multiController.header.packetType != htonl(PACKET_TYPE_MULTI_CONTROLLER)) {
                    break;
                }
                
                // Check if it's able to be batched
                newPkt = &controllerBatchHolder->packet.multiController;
                if (newPkt->buttonFlags != origPkt->buttonFlags ||
                    newPkt->controllerNumber != origPkt->controllerNumber ||
                    !checkDirs(origPkt->leftTrigger, newPkt->leftTrigger, &dirs[0]) ||
                    !checkDirs(origPkt->rightTrigger, newPkt->rightTrigger, &dirs[1]) ||
                    !checkDirs(origPkt->leftStickX, newPkt->leftStickX, &dirs[2]) ||
                    !checkDirs(origPkt->leftStickY, newPkt->leftStickY, &dirs[3]) ||
                    !checkDirs(origPkt->rightStickX, newPkt->rightStickX, &dirs[4]) ||
                    !checkDirs(origPkt->rightStickY, newPkt->rightStickY, &dirs[5])) {
                    // Batching not allowed
                    break;
                }
                
                // Remove the batchable controller packet
                if (LbqPollQueueElement(&packetQueue, (void**)&controllerBatchHolder) != LBQ_SUCCESS) {
                    break;
                }
                
                // Update the original packet
                origPkt->leftTrigger = newPkt->leftTrigger;
                origPkt->rightTrigger = newPkt->rightTrigger;
                origPkt->leftStickX = newPkt->leftStickX;
                origPkt->leftStickY = newPkt->leftStickY;
                origPkt->rightStickX = newPkt->rightStickX;
                origPkt->rightStickY = newPkt->rightStickY;
                
                // Free the batched packet holder
                free(controllerBatchHolder);
            }
        }
        // If it's a mouse move packet, we can also do batching
        else if (holder->packet.mouseMove.header.packetType == htonl(PACKET_TYPE_MOUSE_MOVE)) {
            PPACKET_HOLDER mouseBatchHolder;
            int totalDeltaX = (short)htons(holder->packet.mouseMove.deltaX);
            int totalDeltaY = (short)htons(holder->packet.mouseMove.deltaY);
            
            for (;;) {
                int partialDeltaX;
                int partialDeltaY;
                
                // Peek at the next packet
                if (LbqPeekQueueElement(&packetQueue, (void**)&mouseBatchHolder) != LBQ_SUCCESS) {
                    break;
                }
                
                // If it's not a mouse move packet, we're done
                if (mouseBatchHolder->packet.mouseMove.header.packetType != htonl(PACKET_TYPE_MOUSE_MOVE)) {
                    break;
                }
                
                partialDeltaX = (short)htons(mouseBatchHolder->packet.mouseMove.deltaX);
                partialDeltaY = (short)htons(mouseBatchHolder->packet.mouseMove.deltaY);
                
                // Check for overflow
                if (partialDeltaX + totalDeltaX > INT16_MAX ||
                    partialDeltaX + totalDeltaX < INT16_MIN ||
                    partialDeltaY + totalDeltaY > INT16_MAX ||
                    partialDeltaY + totalDeltaY < INT16_MIN) {
                    // Total delta would overflow our 16-bit short
                    break;
                }
                
                // Remove the batchable mouse move packet
                if (LbqPollQueueElement(&packetQueue, (void**)&mouseBatchHolder) != LBQ_SUCCESS) {
                    break;
                }
                
                totalDeltaX += partialDeltaX;
                totalDeltaY += partialDeltaY;
                
                // Free the batched packet holder
                free(mouseBatchHolder);
            }
            
            // Update the original packet
            holder->packet.mouseMove.deltaX = htons((short)totalDeltaX);
            holder->packet.mouseMove.deltaY = htons((short)totalDeltaY);
        }

		encryptedSize = sizeof(encryptedBuffer);
		err = oaes_encrypt(oaesContext, (const unsigned char*) &holder->packet, holder->packetLength,
			(unsigned char*) encryptedBuffer, &encryptedSize);
		free(holder);
		if (err != OAES_RET_SUCCESS) {
			Limelog("Input: Encryption failed: %d\n", (int)err);
			ListenerCallbacks.connectionTerminated(err);
			return;
		}

		// The first 32-bytes of the output are internal OAES stuff that we want to ignore
		encryptedSize -= OAES_DATA_OFFSET;

		// Overwrite the last 4 bytes before the encrypted data with the length so
		// we can send the message all at once. GFE can choke if it gets the header
		// before the rest of the message.
		encryptedLengthPrefix = htonl((unsigned long) encryptedSize);
		memcpy(&encryptedBuffer[OAES_DATA_OFFSET - sizeof(encryptedLengthPrefix)],
			&encryptedLengthPrefix, sizeof(encryptedLengthPrefix));

		// Send the encrypted payload
		err = send(inputSock, (const char*) &encryptedBuffer[OAES_DATA_OFFSET - sizeof(encryptedLengthPrefix)],
			(int)(encryptedSize + sizeof(encryptedLengthPrefix)), 0);
		if (err <= 0) {
			Limelog("Input: send() failed: %d\n", (int)LastSocketError());
			ListenerCallbacks.connectionTerminated(LastSocketError());
			return;
		}
	}
}

/* Begin the input stream */
int startInputStream(void) {
	int err;

	inputSock = connectTcpSocket(&RemoteAddr, RemoteAddrLen, 35043);
	if (inputSock == INVALID_SOCKET) {
		return LastSocketFail();
	}

	enableNoDelay(inputSock);

	err = PltCreateThread(inputSendThreadProc, NULL, &inputSendThread);
	if (err != 0) {
		return err;
	}

	return err;
}

/* Stops the input stream */
int stopInputStream(void) {
	PltInterruptThread(&inputSendThread);

	if (inputSock != INVALID_SOCKET) {
		closesocket(inputSock);
		inputSock = INVALID_SOCKET;
	}

	PltJoinThread(&inputSendThread);
	PltCloseThread(&inputSendThread);

	return 0;
}

/* Send a mouse move event to the streaming machine */
int LiSendMouseMoveEvent(short deltaX, short deltaY) {
	PPACKET_HOLDER holder;
	int err;

	if (!initialized) {
		return -2;
	}

	holder = malloc(sizeof(*holder));
	if (holder == NULL) {
		return -1;
	}

	holder->packetLength = sizeof(NV_MOUSE_MOVE_PACKET);
	holder->packet.mouseMove.header.packetType = htonl(PACKET_TYPE_MOUSE_MOVE);
	holder->packet.mouseMove.magic = htonl(MOUSE_MOVE_MAGIC);
	holder->packet.mouseMove.deltaX = htons(deltaX);
	holder->packet.mouseMove.deltaY = htons(deltaY);

	err = LbqOfferQueueItem(&packetQueue, holder, &holder->entry);
	if (err != LBQ_SUCCESS) {
		free(holder);
	}

	return err;
}

/* Send a mouse button event to the streaming machine */
int LiSendMouseButtonEvent(char action, int button) {
	PPACKET_HOLDER holder;
	int err;

	if (!initialized) {
		return -2;
	}

	holder = malloc(sizeof(*holder));
	if (holder == NULL) {
		return -1;
	}

	holder->packetLength = sizeof(NV_MOUSE_BUTTON_PACKET);
	holder->packet.mouseButton.header.packetType = htonl(PACKET_TYPE_MOUSE_BUTTON);
	holder->packet.mouseButton.action = action;
	holder->packet.mouseButton.button = htonl(button);

	err = LbqOfferQueueItem(&packetQueue, holder, &holder->entry);
	if (err != LBQ_SUCCESS) {
		free(holder);
	}

	return err;
}

/* Send a key press event to the streaming machine */
int LiSendKeyboardEvent(short keyCode, char keyAction, char modifiers) {
	PPACKET_HOLDER holder;
	int err;

	if (!initialized) {
		return -2;
	}

	holder = malloc(sizeof(*holder));
	if (holder == NULL) {
		return -1;
	}

	holder->packetLength = sizeof(NV_KEYBOARD_PACKET);
	holder->packet.keyboard.header.packetType = htonl(PACKET_TYPE_KEYBOARD);
	holder->packet.keyboard.keyAction = keyAction;
	holder->packet.keyboard.zero1 = 0;
	holder->packet.keyboard.keyCode = keyCode;
	holder->packet.keyboard.modifiers = modifiers;
	holder->packet.keyboard.zero2 = 0;

	err = LbqOfferQueueItem(&packetQueue, holder, &holder->entry);
	if (err != LBQ_SUCCESS) {
		free(holder);
	}

	return err;
}

static int sendControllerEventInternal(short controllerNumber, short buttonFlags, unsigned char leftTrigger, unsigned char rightTrigger,
                                       short leftStickX, short leftStickY, short rightStickX, short rightStickY)
{
    PPACKET_HOLDER holder;
    int err;
    
    if (!initialized) {
        return -2;
    }
    
    holder = malloc(sizeof(*holder));
    if (holder == NULL) {
        return -1;
    }
    
    if (ServerMajorVersion == 3) {
        // Generation 3 servers don't support multiple controllers so we send
        // the legacy packet
        holder->packetLength = sizeof(NV_CONTROLLER_PACKET);
        holder->packet.controller.header.packetType = htonl(PACKET_TYPE_CONTROLLER);
        holder->packet.controller.headerA = C_HEADER_A;
        holder->packet.controller.headerB = C_HEADER_B;
        holder->packet.controller.buttonFlags = buttonFlags;
        holder->packet.controller.leftTrigger = leftTrigger;
        holder->packet.controller.rightTrigger = rightTrigger;
        holder->packet.controller.leftStickX = leftStickX;
        holder->packet.controller.leftStickY = leftStickY;
        holder->packet.controller.rightStickX = rightStickX;
        holder->packet.controller.rightStickY = rightStickY;
        holder->packet.controller.tailA = C_TAIL_A;
        holder->packet.controller.tailB = C_TAIL_B;
    }
    else {
        // Generation 4+ servers support passing the controller number
        holder->packetLength = sizeof(NV_MULTI_CONTROLLER_PACKET);
        holder->packet.multiController.header.packetType = htonl(PACKET_TYPE_MULTI_CONTROLLER);
        holder->packet.multiController.headerA = MC_HEADER_A;
        holder->packet.multiController.headerB = MC_HEADER_B;
        holder->packet.multiController.controllerNumber = controllerNumber;
        holder->packet.multiController.midA = MC_MID_A;
        holder->packet.multiController.midB = MC_MID_B;
        holder->packet.multiController.buttonFlags = buttonFlags;
        holder->packet.multiController.leftTrigger = leftTrigger;
        holder->packet.multiController.rightTrigger = rightTrigger;
        holder->packet.multiController.leftStickX = leftStickX;
        holder->packet.multiController.leftStickY = leftStickY;
        holder->packet.multiController.rightStickX = rightStickX;
        holder->packet.multiController.rightStickY = rightStickY;
        holder->packet.multiController.tailA = MC_TAIL_A;
        holder->packet.multiController.tailB = MC_TAIL_B;
    }
    
	err = LbqOfferQueueItem(&packetQueue, holder, &holder->entry);
    if (err != LBQ_SUCCESS) {
        free(holder);
    }
    
    return err;
}

/* Send a controller event to the streaming machine */
int LiSendControllerEvent(short buttonFlags, unsigned char leftTrigger, unsigned char rightTrigger,
	short leftStickX, short leftStickY, short rightStickX, short rightStickY)
{
    return sendControllerEventInternal(0, buttonFlags, leftTrigger, rightTrigger,
                                       leftStickX, leftStickY, rightStickX, rightStickY);
}

/* Send a controller event to the streaming machine */
int LiSendMultiControllerEvent(short controllerNumber, short buttonFlags, unsigned char leftTrigger, unsigned char rightTrigger,
                          short leftStickX, short leftStickY, short rightStickX, short rightStickY)
{
    return sendControllerEventInternal(controllerNumber, buttonFlags, leftTrigger, rightTrigger,
                                       leftStickX, leftStickY, rightStickX, rightStickY);
}

/* Send a scroll event to the streaming machine */
int LiSendScrollEvent(signed char scrollClicks) {
	PPACKET_HOLDER holder;
	int err;

	if (!initialized) {
		return -2;
	}

	holder = malloc(sizeof(*holder));
	if (holder == NULL) {
		return -1;
	}

	holder->packetLength = sizeof(NV_SCROLL_PACKET);
	holder->packet.scroll.header.packetType = htonl(PACKET_TYPE_SCROLL);
	holder->packet.scroll.magicA = MAGIC_A;
	holder->packet.scroll.zero1 = 0;
	holder->packet.scroll.zero2 = 0;
	holder->packet.scroll.scrollAmt1 = htons(scrollClicks * 120);
	holder->packet.scroll.scrollAmt2 = holder->packet.scroll.scrollAmt1;
	holder->packet.scroll.zero3 = 0;

	err = LbqOfferQueueItem(&packetQueue, holder, &holder->entry);
	if (err != LBQ_SUCCESS) {
		free(holder);
	}

	return err;
}
                                                                                                                                                                                                                  moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/Limelight-internal.h       0000664 0000000 0000000 00000003541 12563577644 0032474 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #pragma once

#include "Limelight.h"
#include "Platform.h"
#include "PlatformSockets.h"
#include "PlatformThreads.h"
#include "Video.h"

// Common globals
extern struct sockaddr_storage RemoteAddr;
extern SOCKADDR_LEN RemoteAddrLen;
extern int ServerMajorVersion;
extern STREAM_CONFIGURATION StreamConfig;
extern CONNECTION_LISTENER_CALLBACKS ListenerCallbacks;
extern DECODER_RENDERER_CALLBACKS VideoCallbacks;
extern AUDIO_RENDERER_CALLBACKS AudioCallbacks;

int isBeforeSignedInt(int numA, int numB, int ambiguousCase);

void fixupMissingCallbacks(PDECODER_RENDERER_CALLBACKS *drCallbacks, PAUDIO_RENDERER_CALLBACKS *arCallbacks,
	PCONNECTION_LISTENER_CALLBACKS *clCallbacks);

char* getSdpPayloadForStreamConfig(int rtspClientVersion, int *length);

int initializeControlStream(void);
int startControlStream(void);
int stopControlStream(void);
void destroyControlStream(void);
void requestIdrOnDemand(void);
void connectionSinkTooSlow(int startFrame, int endFrame);
void connectionDetectedFrameLoss(int startFrame, int endFrame);
void connectionReceivedFrame(int frameIndex);
void connectionLostPackets(int lastReceivedPacket, int nextReceivedPacket);

int performRtspHandshake(void);
void terminateRtspHandshake(void);

void initializeVideoDepacketizer(int pktSize);
void destroyVideoDepacketizer(void);
void processRtpPayload(PNV_VIDEO_PACKET videoPacket, int length);
void queueRtpPacket(PRTP_PACKET rtpPacket, int length);

void initializeVideoStream(void);
void destroyVideoStream(void);
int startVideoStream(void* rendererContext, int drFlags);
void stopVideoStream(void);

void initializeAudioStream(void);
void destroyAudioStream(void);
int startAudioStream(void);
void stopAudioStream(void);

int initializeInputStream(char* aesKeyData, int aesKeyDataLength, char* aesIv, int aesIvLength);
void destroyInputStream(void);
int startInputStream(void);
int stopInputStream(void);
                                                                                                                                                               moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/Limelight.h                0000664 0000000 0000000 00000020307 12563577644 0030661 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
// This header exposes the public streaming API for client usage
//

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

// Enable this definition during debugging to enable assertions
//#define LC_DEBUG

typedef struct _STREAM_CONFIGURATION {
	// Dimensions in pixels of the desired video stream
	int width;
	int height;

	// FPS of the desired video stream
	int fps;

	// Bitrate of the desired video stream (audio adds another ~1 Mbps)
	int bitrate;

	// Max video packet size in bytes (use 1024 if unsure)
	int packetSize;

	// Enable remote optimizations
	int remote;

	// AES encryption data for the remote input stream. This must be
	// the same as what was passed as rikey and rikeyid 
	// in /launch and /resume requests.
	char remoteInputAesKey[16];
	char remoteInputAesIv[16];
} STREAM_CONFIGURATION, *PSTREAM_CONFIGURATION;

typedef struct _LENTRY {
	// Pointer to the next entry or NULL if this is the last entry
	struct _LENTRY *next;

	// Pointer to data (never NULL)
	char* data;

	// Size of data in bytes (never <= 0)
	int length;
} LENTRY, *PLENTRY;

// A decode unit describes a buffer chain of H264 data from multiple packets
typedef struct _DECODE_UNIT {
	// Length of the entire buffer chain in bytes
	int fullLength;

	// Head of the buffer chain (never NULL)
	PLENTRY bufferList;
} DECODE_UNIT, *PDECODE_UNIT;

// If set in the renderer capabilities field, this flag will cause audio/video data to
// be submitted directly from the receive thread. This should only be specified if the
// renderer is non-blocking. This flag is valid on both audio and video renderers.
#define CAPABILITY_DIRECT_SUBMIT 0x1

// !!! HIGHLY EXPERIMENTAL - DO NOT SET IN PRODUCTION CODE !!!
// If set in the video renderer capabilities field, this flag specifies that the renderer
// supports reference frame invalidation. This flag is only valid on video renderers.
#define CAPABILITY_REFERENCE_FRAME_INVALIDATION 0x2

// This callback is invoked to provide details about the video stream and allow configuration of the decoder
typedef void(*DecoderRendererSetup)(int width, int height, int redrawRate, void* context, int drFlags);

// This callback performs the teardown of the video decoder
typedef void(*DecoderRendererCleanup)(void);

// This callback provides Annex B formatted H264 elementary stream data to the
// decoder. If the decoder is unable to process the submitted data for some reason,
// it must return DR_NEED_IDR to generate a keyframe.
#define DR_OK 0
#define DR_NEED_IDR -1
typedef int(*DecoderRendererSubmitDecodeUnit)(PDECODE_UNIT decodeUnit);

typedef struct _DECODER_RENDERER_CALLBACKS {
	DecoderRendererSetup setup;
	DecoderRendererCleanup cleanup;
	DecoderRendererSubmitDecodeUnit submitDecodeUnit;
	int capabilities;
} DECODER_RENDERER_CALLBACKS, *PDECODER_RENDERER_CALLBACKS;

// This callback initializes the audio renderer
typedef void(*AudioRendererInit)(void);

// This callback performs the final teardown of the audio decoder
typedef void(*AudioRendererCleanup)(void);

// This callback provides Opus audio data to be decoded and played. sampleLength is in bytes.
typedef void(*AudioRendererDecodeAndPlaySample)(char* sampleData, int sampleLength);

typedef struct _AUDIO_RENDERER_CALLBACKS {
	AudioRendererInit init;
	AudioRendererCleanup cleanup;
	AudioRendererDecodeAndPlaySample decodeAndPlaySample;
	int capabilities;
} AUDIO_RENDERER_CALLBACKS, *PAUDIO_RENDERER_CALLBACKS;

// Subject to change in future releases
// Use LiGetStageName() for stable stage names
#define STAGE_NONE 0
#define STAGE_PLATFORM_INIT 1
#define STAGE_NAME_RESOLUTION 2
#define STAGE_RTSP_HANDSHAKE 3
#define STAGE_CONTROL_STREAM_INIT 4
#define STAGE_VIDEO_STREAM_INIT 5
#define STAGE_AUDIO_STREAM_INIT 6
#define STAGE_INPUT_STREAM_INIT 7
#define STAGE_CONTROL_STREAM_START 8
#define STAGE_VIDEO_STREAM_START 9
#define STAGE_AUDIO_STREAM_START 10
#define STAGE_INPUT_STREAM_START 11
#define STAGE_MAX 12

// This callback is invoked to indicate that a stage of initialization is about to begin
typedef void(*ConnListenerStageStarting)(int stage);

// This callback is invoked to indicate that a stage of initialization has completed
typedef void(*ConnListenerStageComplete)(int stage);

// This callback is invoked to indicate that a stage of initialization has failed
typedef void(*ConnListenerStageFailed)(int stage, long errorCode);

// This callback is invoked after initialization has finished
typedef void(*ConnListenerConnectionStarted)(void);

// This callback is invoked when a connection failure occurs. It will not
// occur as a result of a call to LiStopConnection()
typedef void(*ConnListenerConnectionTerminated)(long errorCode);

// This callback is invoked to display a dialog-type message to the user
typedef void(*ConnListenerDisplayMessage)(char* message);

// This callback is invoked to display a transient message for the user
// while streaming
typedef void(*ConnListenerDisplayTransientMessage)(char* message);

typedef struct _CONNECTION_LISTENER_CALLBACKS {
	ConnListenerStageStarting stageStarting;
	ConnListenerStageComplete stageComplete;
	ConnListenerStageFailed stageFailed;
	ConnListenerConnectionStarted connectionStarted;
	ConnListenerConnectionTerminated connectionTerminated;
	ConnListenerDisplayMessage displayMessage;
	ConnListenerDisplayTransientMessage displayTransientMessage;
} CONNECTION_LISTENER_CALLBACKS, *PCONNECTION_LISTENER_CALLBACKS;

// This function begins streaming.
//
// Callbacks are all optional. Pass NULL for individual callbacks within each struct or pass NULL for the entire struct
// to use the defaults for all callbacks.
//
// _serverMajorVersion is the major version number of the 'appversion' tag in the /serverinfo request
//
int LiStartConnection(const char* host, PSTREAM_CONFIGURATION streamConfig, PCONNECTION_LISTENER_CALLBACKS clCallbacks,
	PDECODER_RENDERER_CALLBACKS drCallbacks, PAUDIO_RENDERER_CALLBACKS arCallbacks, void* renderContext, int drFlags, int _serverMajorVersion);

// This function stops streaming.
void LiStopConnection(void);

// Use to get a user-visible string to display initialization progress
// from the integer passed to the ConnListenerStageXXX callbacks
const char* LiGetStageName(int stage);

// This function queues a mouse move event to be sent to the remote server.
int LiSendMouseMoveEvent(short deltaX, short deltaY);

// This function queues a mouse button event to be sent to the remote server.
#define BUTTON_ACTION_PRESS 0x07
#define BUTTON_ACTION_RELEASE 0x08
#define BUTTON_LEFT 0x01
#define BUTTON_MIDDLE 0x02
#define BUTTON_RIGHT 0x03
int LiSendMouseButtonEvent(char action, int button);

// This function queues a keyboard event to be sent to the remote server.
#define KEY_ACTION_DOWN 0x03
#define KEY_ACTION_UP 0x04
#define MODIFIER_SHIFT 0x01
#define MODIFIER_CTRL 0x02
#define MODIFIER_ALT 0x04
int LiSendKeyboardEvent(short keyCode, char keyAction, char modifiers);

// Button flags
#define A_FLAG     0x1000
#define B_FLAG     0x2000
#define X_FLAG     0x4000
#define Y_FLAG     0x8000
#define UP_FLAG    0x0001
#define DOWN_FLAG  0x0002
#define LEFT_FLAG  0x0004
#define RIGHT_FLAG 0x0008
#define LB_FLAG    0x0100
#define RB_FLAG    0x0200
#define PLAY_FLAG  0x0010
#define BACK_FLAG  0x0020
#define LS_CLK_FLAG  0x0040
#define RS_CLK_FLAG  0x0080
#define SPECIAL_FLAG 0x0400

// This function queues a controller event to be sent to the remote server. It will
// be seen by the computer as the first controller.
int LiSendControllerEvent(short buttonFlags, unsigned char leftTrigger, unsigned char rightTrigger,
	short leftStickX, short leftStickY, short rightStickX, short rightStickY);

// This function queues a controller event to be sent to the remote server. The controllerNumber
// parameter is a zero-based index of which controller this event corresponds to. The largest legal
// controller number is 3 (for a total of 4 controllers, the Xinput maximum). On generation 3 servers (GFE 2.1.x),
// these will be sent as controller 0 regardless of the controllerNumber parameter.
int LiSendMultiControllerEvent(short controllerNumber, short buttonFlags, unsigned char leftTrigger, unsigned char rightTrigger,
    short leftStickX, short leftStickY, short rightStickX, short rightStickY);

// This function queues a vertical scroll event to the remote server.
int LiSendScrollEvent(signed char scrollClicks);

#ifdef __cplusplus
}
#endif
                                                                                                                                                                                                                                                                                                                         moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/LinkedBlockingQueue.c      0000664 0000000 0000000 00000010151 12563577644 0032616 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include "LinkedBlockingQueue.h"

/* Destroy the linked blocking queue and associated mutex and event */
PLINKED_BLOCKING_QUEUE_ENTRY LbqDestroyLinkedBlockingQueue(PLINKED_BLOCKING_QUEUE queueHead) {
	PltDeleteMutex(&queueHead->mutex);
	PltCloseEvent(&queueHead->containsDataEvent);
	
	return queueHead->head;
}

/* Flush the queue */
PLINKED_BLOCKING_QUEUE_ENTRY LbqFlushQueueItems(PLINKED_BLOCKING_QUEUE queueHead) {
	PLINKED_BLOCKING_QUEUE_ENTRY head;
	
	PltLockMutex(&queueHead->mutex);

	// Save the old head
	head = queueHead->head;

	// Reinitialize the queue to empty
	queueHead->head = NULL;
	queueHead->tail = NULL;
	queueHead->currentSize = 0;
	PltClearEvent(&queueHead->containsDataEvent);

	PltUnlockMutex(&queueHead->mutex);

	return head;
}

/* Linked blocking queue init */
int LbqInitializeLinkedBlockingQueue(PLINKED_BLOCKING_QUEUE queueHead, int sizeBound) {
	int err;
	
	err = PltCreateEvent(&queueHead->containsDataEvent);
	if (err != 0) {
		return err;
	}

	err = PltCreateMutex(&queueHead->mutex);
	if (err != 0) {
		return err;
	}

	queueHead->head = NULL;
	queueHead->tail = NULL;
	queueHead->sizeBound = sizeBound;
	queueHead->currentSize = 0;

	return 0;
}

int LbqOfferQueueItem(PLINKED_BLOCKING_QUEUE queueHead, void* data, PLINKED_BLOCKING_QUEUE_ENTRY entry) {
	entry->flink = NULL;
	entry->data = data;

	PltLockMutex(&queueHead->mutex);

	if (queueHead->currentSize == queueHead->sizeBound) {
		PltUnlockMutex(&queueHead->mutex);
		return LBQ_BOUND_EXCEEDED;
	}

	if (queueHead->head == NULL) {
		LC_ASSERT(queueHead->currentSize == 0);
		LC_ASSERT(queueHead->tail == NULL);
		queueHead->head = entry;
		queueHead->tail = entry;
		entry->blink = NULL;
	}
	else {
		LC_ASSERT(queueHead->currentSize >= 1);
		LC_ASSERT(queueHead->head != NULL);
		queueHead->tail->flink = entry;
		entry->blink = queueHead->tail;
		queueHead->tail = entry;
	}

	queueHead->currentSize++;

	PltUnlockMutex(&queueHead->mutex);

	PltSetEvent(&queueHead->containsDataEvent);

	return LBQ_SUCCESS;
}

// This must be synchronized with LbqFlushQueueItems by the caller
int LbqPeekQueueElement(PLINKED_BLOCKING_QUEUE queueHead, void** data) {
    if (queueHead->head == NULL) {
        return LBQ_NO_ELEMENT;
    }
    
    PltLockMutex(&queueHead->mutex);
    
    if (queueHead->head == NULL) {
        PltUnlockMutex(&queueHead->mutex);
        return LBQ_NO_ELEMENT;
    }
    
    *data = queueHead->head->data;
    
    PltUnlockMutex(&queueHead->mutex);
    
    return LBQ_SUCCESS;
}

int LbqPollQueueElement(PLINKED_BLOCKING_QUEUE queueHead, void** data) {
    PLINKED_BLOCKING_QUEUE_ENTRY entry;
    
    if (queueHead->head == NULL) {
        return LBQ_NO_ELEMENT;
    }
    
    PltLockMutex(&queueHead->mutex);
    
    if (queueHead->head == NULL) {
        PltUnlockMutex(&queueHead->mutex);
        return LBQ_NO_ELEMENT;
    }
    
    entry = queueHead->head;
    queueHead->head = entry->flink;
    queueHead->currentSize--;
    if (queueHead->head == NULL) {
        LC_ASSERT(queueHead->currentSize == 0);
        queueHead->tail = NULL;
        PltClearEvent(&queueHead->containsDataEvent);
    }
    else {
        LC_ASSERT(queueHead->currentSize != 0);
        queueHead->head->blink = NULL;
    }
    
    *data = entry->data;
    
    PltUnlockMutex(&queueHead->mutex);
    
    return LBQ_SUCCESS;
}

int LbqWaitForQueueElement(PLINKED_BLOCKING_QUEUE queueHead, void** data) {
	PLINKED_BLOCKING_QUEUE_ENTRY entry;
	int err;

	for (;;) {
		err = PltWaitForEvent(&queueHead->containsDataEvent);
		if (err != PLT_WAIT_SUCCESS) {
			return LBQ_INTERRUPTED;
		}

		PltLockMutex(&queueHead->mutex);

		if (queueHead->head == NULL) {
			PltClearEvent(&queueHead->containsDataEvent);
			PltUnlockMutex(&queueHead->mutex);
			continue;
		}

		entry = queueHead->head;
		queueHead->head = entry->flink;
		queueHead->currentSize--;
		if (queueHead->head == NULL) {
			LC_ASSERT(queueHead->currentSize == 0);
			queueHead->tail = NULL;
			PltClearEvent(&queueHead->containsDataEvent);
		}
		else {
			LC_ASSERT(queueHead->currentSize != 0);
			queueHead->head->blink = NULL;
		}

		*data = entry->data;

		PltUnlockMutex(&queueHead->mutex);

		break;
	}

	return LBQ_SUCCESS;
}
                                                                                                                                                                                                                                                                                                                                                                                                                       moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/LinkedBlockingQueue.h      0000664 0000000 0000000 00000002276 12563577644 0032634 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #pragma once

#include "Platform.h"
#include "PlatformThreads.h"

#define LBQ_SUCCESS 0
#define LBQ_INTERRUPTED 1
#define LBQ_BOUND_EXCEEDED 2
#define LBQ_NO_ELEMENT 3

typedef struct _LINKED_BLOCKING_QUEUE_ENTRY {
	struct _LINKED_BLOCKING_QUEUE_ENTRY *flink;
	struct _LINKED_BLOCKING_QUEUE_ENTRY *blink;
	void* data;
} LINKED_BLOCKING_QUEUE_ENTRY, *PLINKED_BLOCKING_QUEUE_ENTRY;

typedef struct _LINKED_BLOCKING_QUEUE {
	PLT_MUTEX mutex;
	PLT_EVENT containsDataEvent;
	int sizeBound;
	int currentSize;
	PLINKED_BLOCKING_QUEUE_ENTRY head;
	PLINKED_BLOCKING_QUEUE_ENTRY tail;
} LINKED_BLOCKING_QUEUE, *PLINKED_BLOCKING_QUEUE;

int LbqInitializeLinkedBlockingQueue(PLINKED_BLOCKING_QUEUE queueHead, int sizeBound);
int LbqOfferQueueItem(PLINKED_BLOCKING_QUEUE queueHead, void* data, PLINKED_BLOCKING_QUEUE_ENTRY entry);
int LbqWaitForQueueElement(PLINKED_BLOCKING_QUEUE queueHead, void** data);
int LbqPollQueueElement(PLINKED_BLOCKING_QUEUE queueHead, void** data);
int LbqPeekQueueElement(PLINKED_BLOCKING_QUEUE queueHead, void** data);
PLINKED_BLOCKING_QUEUE_ENTRY LbqDestroyLinkedBlockingQueue(PLINKED_BLOCKING_QUEUE queueHead);
PLINKED_BLOCKING_QUEUE_ENTRY LbqFlushQueueItems(PLINKED_BLOCKING_QUEUE queueHead);
                                                                                                                                                                                                                                                                                                                                  moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/Misc.c                     0000664 0000000 0000000 00000000646 12563577644 0027635 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include "Limelight-internal.h"

int isBeforeSignedInt(int numA, int numB, int ambiguousCase) {
	// This should be the common case for most callers
	if (numA == numB) {
		return 0;
	}

	// If numA and numB have the same signs,
	// we can just do a regular comparison.
	if ((numA < 0 && numB < 0) || (numA >= 0 && numB >= 0)) {
		return numA < numB;
	}
	else {
		// The sign switch is ambiguous
		return ambiguousCase;
	}
}                                                                                          moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/OpenAES/                   0000775 0000000 0000000 00000000000 12563577644 0030022 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/OpenAES/LICENSE            0000664 0000000 0000000 00000003043 12563577644 0031027 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        ---------------------------------------------------------------------------
OpenAES Licence
---------------------------------------------------------------------------
Copyright (c) 2012, Nabil S. Al Ramli, www.nalramli.com
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

  - Redistributions of source code must retain the above copyright notice,
    this list of conditions and the following disclaimer.
  - Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/OpenAES/README             0000664 0000000 0000000 00000006041 12563577644 0030703 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        ---------------------------------------------------------------------------
OpenAES-0.9.0
Nabil S. Al Ramli
www.nalramli.com
---------------------------------------------------------------------------

License Terms
-------------

---------------------------------------------------------------------------
OpenAES Licence
---------------------------------------------------------------------------
Copyright (c) 2012, Nabil S. Al Ramli, www.nalramli.com
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

  - Redistributions of source code must retain the above copyright notice,
    this list of conditions and the following disclaimer.
  - Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------

Introduction
------------

OpenAES is an open source implementation of the Advanced Encryption
Standard.  It is distributed as a portable, lightweight C library that can
be easily integrated into applications.

Compiling
---------

OpenAES has been tested with the GCC as well as VC compilers.  It is
necessary to compile the source files located in ./src, and to add ./inc to
the include paths.

If you are building with OAES_HAVE_ISAAC defined (true by default), then
you also need to link in the source files under ./src/isaac and also add
./src/isaac to the include paths.

You may edit ./inc/oaes_config.h to modify build options.

CMake 2.8.0 can be used to build the test programs on different platforms.

In a Linux command line terminal type:

cmake .
make

In Windows, in a Visual Studio command line window type:

cmake . -G "NMake Makefiles"
nmake

Usage
-----

oaes_lib usage is described in the header file ./inc/oaes_lib.h.

The oaes command line application help manual can be obtained by using the
--help command line options.

The oaes_setup Windows installer integrates with the Windows shell.  It can be
used by right clicking a file in Windows Explorer and then selecting a
subcommand from the OpenAES menu.

Samples
-------

Samples applications are provided in the /test folder.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/OpenAES/VERSION            0000664 0000000 0000000 00000000015 12563577644 0031066 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        OpenAES-0.9.0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/OpenAES/oaes_base64.c      0000664 0000000 0000000 00000011647 12563577644 0032272 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* 
 * ---------------------------------------------------------------------------
 * OpenAES License
 * ---------------------------------------------------------------------------
 * Copyright (c) 2013, Nabil S. Al Ramli, www.nalramli.com
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   - Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   - Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * ---------------------------------------------------------------------------
 */
#if 0 // LIMELIGHT
static const char _NR[] = {
	0x4e,0x61,0x62,0x69,0x6c,0x20,0x53,0x2e,0x20,
	0x41,0x6c,0x20,0x52,0x61,0x6d,0x6c,0x69,0x00 };
#endif

#include <stdlib.h>
#include <string.h>

#include "oaes_config.h"
#include "oaes_base64.h"

static const char _oaes_base64_table[] =
	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

OAES_RET oaes_base64_encode(
	const uint8_t *in, size_t in_len, char *out, size_t *out_len)
{
  size_t _i = 0, _j = 0;
  unsigned char _buf1[3];
  unsigned char _buf2[4];
  size_t _out_len_req = 4 * ( in_len / 3 + ( in_len % 3 ? 1 : 0 ) ) + 1;

  if( NULL == in || 0 == in_len || NULL == out_len )
    return OAES_RET_ERROR;

  if( NULL == out )
  {
      *out_len = _out_len_req;
      return OAES_RET_SUCCESS;
  }

  if( _out_len_req > *out_len )
      return OAES_RET_ERROR;

  memset(out, 0, *out_len);
  *out_len = 0;
  while( in_len-- )
	{
    _buf1[_i++] = *(in++);
    if( _i == 3 )
		{
      _buf2[0] = (_buf1[0] & 0xfc) >> 2;
      _buf2[1] = ((_buf1[0] & 0x03) << 4) + ((_buf1[1] & 0xf0) >> 4);
      _buf2[2] = ((_buf1[1] & 0x0f) << 2) + ((_buf1[2] & 0xc0) >> 6);
      _buf2[3] = _buf1[2] & 0x3f;

      for( _i = 0; _i < 4; _i++ )
      {
        *(out++) = _oaes_base64_table[_buf2[_i]];
        (*out_len)++;
      }
      _i = 0;
    }
  }

  if( _i )
  {
    for( _j = _i; _j < 3; _j++ )
      _buf1[_j] = '\0';

    _buf2[0] = (_buf1[0] & 0xfc) >> 2;
    _buf2[1] = ((_buf1[0] & 0x03) << 4) + ((_buf1[1] & 0xf0) >> 4);
    _buf2[2] = ((_buf1[1] & 0x0f) << 2) + ((_buf1[2] & 0xc0) >> 6);
    _buf2[3] = _buf1[2] & 0x3f;

    for( _j = 0; (_j < _i + 1); _j++ )
    {
      *(out++) = _oaes_base64_table[_buf2[_j]];
      (*out_len)++;
    }

    while( _i++ < 3 )
    {
      *(out++) = '=';
      (*out_len)++;
    }
  }

  return OAES_RET_SUCCESS;

}

OAES_RET oaes_base64_decode(
	const char *in, size_t in_len, uint8_t *out, size_t *out_len )
{
  size_t _i = 0, _j = 0, _idx = 0;
  uint8_t _buf2[4], _buf1[3];
  size_t _out_len_req = 3 * ( in_len / 4 + ( in_len % 4 ? 1 : 0 ) );

  if( NULL == in || 0 == in_len || NULL == out_len )
    return OAES_RET_ERROR;

  if( NULL == out )
  {
      *out_len = _out_len_req;
      return OAES_RET_SUCCESS;
  }

  if( _out_len_req > *out_len )
      return OAES_RET_ERROR;

  memset(out, 0, *out_len);
  *out_len = 0;
  while( in_len-- && strchr(_oaes_base64_table, in[_idx++]) )
	{
    _buf2[_i++] = in[_idx - 1];
    if( _i ==4 )
		{
      for (_i = 0; _i < 4; _i++)
        _buf2[_i] = strchr(_oaes_base64_table, _buf2[_i]) - _oaes_base64_table;

      _buf1[0] = (_buf2[0] << 2) + ((_buf2[1] & 0x30) >> 4);
      _buf1[1] = ((_buf2[1] & 0xf) << 4) + ((_buf2[2] & 0x3c) >> 2);
      _buf1[2] = ((_buf2[2] & 0x3) << 6) + _buf2[3];

      for( _i = 0; (_i < 3); _i++ )
      {
        *(out++) = _buf1[_i];
        (*out_len)++;
      }
      _i = 0;
    }
  }

  if( _i )
	{
    for( _j = _i; _j <4; _j++ )
      _buf2[_j] = 0;

    for( _j = 0; _j <4; _j++ )
      _buf2[_j] = strchr(_oaes_base64_table, _buf2[_j]) - _oaes_base64_table;

    _buf1[0] = (_buf2[0] << 2) + ((_buf2[1] & 0x30) >> 4);
    _buf1[1] = ((_buf2[1] & 0xf) << 4) + ((_buf2[2] & 0x3c) >> 2);
    _buf1[2] = ((_buf2[2] & 0x3) << 6) + _buf2[3];

    for( _j = 0; (_j < _i - 1); _j++ )
    {
        *(out++) = _buf1[_j];
        (*out_len)++;
    }
  }

  return OAES_RET_SUCCESS;
}
                                                                                         moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/OpenAES/oaes_base64.h      0000664 0000000 0000000 00000003766 12563577644 0032302 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* 
 * ---------------------------------------------------------------------------
 * OpenAES License
 * ---------------------------------------------------------------------------
 * Copyright (c) 2013, Nabil S. Al Ramli, www.nalramli.com
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   - Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   - Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * ---------------------------------------------------------------------------
 */

#ifndef _OAES_BASE64_H
#define _OAES_BASE64_H

#include "oaes_common.h"

#ifdef __cplusplus 
extern "C" {
#endif

OAES_API OAES_RET oaes_base64_encode(
	const uint8_t *in, size_t in_len, char *out, size_t *out_len );

OAES_API OAES_RET oaes_base64_decode(
	const char *in, size_t in_len, uint8_t *out, size_t *out_len );

#ifdef __cplusplus 
}
#endif

#endif // _OAES_BASE64_H
          moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/OpenAES/oaes_common.h      0000664 0000000 0000000 00000004445 12563577644 0032501 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* 
 * ---------------------------------------------------------------------------
 * OpenAES License
 * ---------------------------------------------------------------------------
 * Copyright (c) 2013, Nabil S. Al Ramli, www.nalramli.com
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   - Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   - Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * ---------------------------------------------------------------------------
 */

#ifndef _OAES_COMMON_H
#define _OAES_COMMON_H

#include <stdint.h>

#ifdef __cplusplus 
extern "C" {
#endif

#ifdef _WIN32
#	ifdef OAES_SHARED
#		ifdef oaes_lib_EXPORTS
#			define OAES_API __declspec(dllexport)
#		else
#			define OAES_API __declspec(dllimport)
#		endif
#	else
#		define OAES_API
#	endif
#else
#	define OAES_API
#endif // WIN32

#define OAES_VERSION "0.9.0"

typedef enum
{
	OAES_RET_FIRST = 0,
	OAES_RET_SUCCESS = 0,
	OAES_RET_ERROR,
	OAES_RET_ARG1,
	OAES_RET_ARG2,
	OAES_RET_ARG3,
	OAES_RET_ARG4,
	OAES_RET_ARG5,
	OAES_RET_NOKEY,
	OAES_RET_MEM,
	OAES_RET_BUF,
	OAES_RET_HEADER,
	OAES_RET_COUNT
} OAES_RET;

#ifdef __cplusplus 
}
#endif

#endif // _OAES_COMMON_H
                                                                                                                                                                                                                           moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/OpenAES/oaes_config.h      0000664 0000000 0000000 00000003414 12563577644 0032451 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* 
 * ---------------------------------------------------------------------------
 * OpenAES License
 * ---------------------------------------------------------------------------
 * Copyright (c) 2012, Nabil S. Al Ramli, www.nalramli.com
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   - Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   - Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * ---------------------------------------------------------------------------
 */

#ifndef _OAES_CONFIG_H
#define _OAES_CONFIG_H

#ifdef __cplusplus 
extern "C" {
#endif

#ifdef __cplusplus 
}
#endif

#endif // _OAES_CONFIG_H
                                                                                                                                                                                                                                                    moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/OpenAES/oaes_lib.c         0000664 0000000 0000000 00000121770 12563577644 0031753 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* 
 * ---------------------------------------------------------------------------
 * OpenAES License
 * ---------------------------------------------------------------------------
 * Copyright (c) 2012, Nabil S. Al Ramli, www.nalramli.com
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   - Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   - Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * ---------------------------------------------------------------------------
 */
#if 0 // LIMELIGHT
static const char _NR[] = {
	0x4e,0x61,0x62,0x69,0x6c,0x20,0x53,0x2e,0x20,
	0x41,0x6c,0x20,0x52,0x61,0x6d,0x6c,0x69,0x00 };
#endif

#include <stdlib.h>
#include <stddef.h>
#include <time.h> 
#include <sys/timeb.h>
#include <string.h>
#include <stdio.h>

#ifdef WIN32
#include <process.h>
#endif

#include "oaes_config.h"
#include "oaes_lib.h"

#ifdef OAES_HAVE_ISAAC
#include "rand.h"
#define OAES_RAND(x) rand(x)
#else
#define OAES_RAND(x) rand()
#endif // OAES_HAVE_ISAAC

#define OAES_RKEY_LEN 4
#define OAES_COL_LEN 4
#define OAES_ROUND_BASE 7

// the block is padded
#define OAES_FLAG_PAD 0x01

#ifndef min
# define min(a,b) (((a)<(b)) ? (a) : (b))
#endif /* min */

typedef struct _oaes_key
{
	size_t data_len;
	uint8_t *data;
	size_t exp_data_len;
	uint8_t *exp_data;
	size_t num_keys;
	size_t key_base;
} oaes_key;

typedef struct _oaes_ctx
{
#ifdef OAES_HAVE_ISAAC
  randctx * rctx;
#endif // OAES_HAVE_ISAAC

#ifdef OAES_DEBUG
	oaes_step_cb step_cb;
#endif // OAES_DEBUG

	oaes_key * key;
	OAES_OPTION options;
	uint8_t iv[OAES_BLOCK_SIZE];
} oaes_ctx;

// "OAES<8-bit header version><8-bit type><16-bit options><8-bit flags><56-bit reserved>"
static uint8_t oaes_header[OAES_BLOCK_SIZE] = {
	// 		0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    a,    b,    c,    d,    e,    f,
	/*0*/	0x4f, 0x41, 0x45, 0x53, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
static uint8_t oaes_gf_8[] = {
	0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36 };

static uint8_t oaes_sub_byte_value[16][16] = {
	// 		0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    a,    b,    c,    d,    e,    f,
	/*0*/	0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
	/*1*/	0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
	/*2*/	0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
	/*3*/	0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
	/*4*/	0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
	/*5*/	0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
	/*6*/	0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
	/*7*/	0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
	/*8*/	0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
	/*9*/	0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
	/*a*/	0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
	/*b*/	0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
	/*c*/	0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
	/*d*/	0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
	/*e*/	0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
	/*f*/	0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,
};

static uint8_t oaes_inv_sub_byte_value[16][16] = {
	// 		0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    a,    b,    c,    d,    e,    f,
	/*0*/	0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
	/*1*/	0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
	/*2*/	0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
	/*3*/	0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
	/*4*/	0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
	/*5*/	0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
	/*6*/	0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
	/*7*/	0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
	/*8*/	0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
	/*9*/	0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
	/*a*/	0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
	/*b*/	0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
	/*c*/	0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
	/*d*/	0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
	/*e*/	0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
	/*f*/	0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d,
};

static uint8_t oaes_gf_mul_2[16][16] = {
	// 		0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    a,    b,    c,    d,    e,    f,
	/*0*/	0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e,
	/*1*/	0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e,
	/*2*/	0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e,
	/*3*/	0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e,
	/*4*/	0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e,
	/*5*/	0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe,
	/*6*/	0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde,
	/*7*/	0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe,
	/*8*/	0x1b, 0x19, 0x1f, 0x1d, 0x13, 0x11, 0x17, 0x15, 0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05,
	/*9*/	0x3b, 0x39, 0x3f, 0x3d, 0x33, 0x31, 0x37, 0x35, 0x2b, 0x29, 0x2f, 0x2d, 0x23, 0x21, 0x27, 0x25,
	/*a*/	0x5b, 0x59, 0x5f, 0x5d, 0x53, 0x51, 0x57, 0x55, 0x4b, 0x49, 0x4f, 0x4d, 0x43, 0x41, 0x47, 0x45,
	/*b*/	0x7b, 0x79, 0x7f, 0x7d, 0x73, 0x71, 0x77, 0x75, 0x6b, 0x69, 0x6f, 0x6d, 0x63, 0x61, 0x67, 0x65,
	/*c*/	0x9b, 0x99, 0x9f, 0x9d, 0x93, 0x91, 0x97, 0x95, 0x8b, 0x89, 0x8f, 0x8d, 0x83, 0x81, 0x87, 0x85,
	/*d*/	0xbb, 0xb9, 0xbf, 0xbd, 0xb3, 0xb1, 0xb7, 0xb5, 0xab, 0xa9, 0xaf, 0xad, 0xa3, 0xa1, 0xa7, 0xa5,
	/*e*/	0xdb, 0xd9, 0xdf, 0xdd, 0xd3, 0xd1, 0xd7, 0xd5, 0xcb, 0xc9, 0xcf, 0xcd, 0xc3, 0xc1, 0xc7, 0xc5,
	/*f*/	0xfb, 0xf9, 0xff, 0xfd, 0xf3, 0xf1, 0xf7, 0xf5, 0xeb, 0xe9, 0xef, 0xed, 0xe3, 0xe1, 0xe7, 0xe5,
};

static uint8_t oaes_gf_mul_3[16][16] = {
	// 		0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    a,    b,    c,    d,    e,    f,
	/*0*/	0x00, 0x03, 0x06, 0x05, 0x0c, 0x0f, 0x0a, 0x09, 0x18, 0x1b, 0x1e, 0x1d, 0x14, 0x17, 0x12, 0x11,
	/*1*/	0x30, 0x33, 0x36, 0x35, 0x3c, 0x3f, 0x3a, 0x39, 0x28, 0x2b, 0x2e, 0x2d, 0x24, 0x27, 0x22, 0x21,
	/*2*/	0x60, 0x63, 0x66, 0x65, 0x6c, 0x6f, 0x6a, 0x69, 0x78, 0x7b, 0x7e, 0x7d, 0x74, 0x77, 0x72, 0x71,
	/*3*/	0x50, 0x53, 0x56, 0x55, 0x5c, 0x5f, 0x5a, 0x59, 0x48, 0x4b, 0x4e, 0x4d, 0x44, 0x47, 0x42, 0x41,
	/*4*/	0xc0, 0xc3, 0xc6, 0xc5, 0xcc, 0xcf, 0xca, 0xc9, 0xd8, 0xdb, 0xde, 0xdd, 0xd4, 0xd7, 0xd2, 0xd1,
	/*5*/	0xf0, 0xf3, 0xf6, 0xf5, 0xfc, 0xff, 0xfa, 0xf9, 0xe8, 0xeb, 0xee, 0xed, 0xe4, 0xe7, 0xe2, 0xe1,
	/*6*/	0xa0, 0xa3, 0xa6, 0xa5, 0xac, 0xaf, 0xaa, 0xa9, 0xb8, 0xbb, 0xbe, 0xbd, 0xb4, 0xb7, 0xb2, 0xb1,
	/*7*/	0x90, 0x93, 0x96, 0x95, 0x9c, 0x9f, 0x9a, 0x99, 0x88, 0x8b, 0x8e, 0x8d, 0x84, 0x87, 0x82, 0x81,
	/*8*/	0x9b, 0x98, 0x9d, 0x9e, 0x97, 0x94, 0x91, 0x92, 0x83, 0x80, 0x85, 0x86, 0x8f, 0x8c, 0x89, 0x8a,
	/*9*/	0xab, 0xa8, 0xad, 0xae, 0xa7, 0xa4, 0xa1, 0xa2, 0xb3, 0xb0, 0xb5, 0xb6, 0xbf, 0xbc, 0xb9, 0xba,
	/*a*/	0xfb, 0xf8, 0xfd, 0xfe, 0xf7, 0xf4, 0xf1, 0xf2, 0xe3, 0xe0, 0xe5, 0xe6, 0xef, 0xec, 0xe9, 0xea,
	/*b*/	0xcb, 0xc8, 0xcd, 0xce, 0xc7, 0xc4, 0xc1, 0xc2, 0xd3, 0xd0, 0xd5, 0xd6, 0xdf, 0xdc, 0xd9, 0xda,
	/*c*/	0x5b, 0x58, 0x5d, 0x5e, 0x57, 0x54, 0x51, 0x52, 0x43, 0x40, 0x45, 0x46, 0x4f, 0x4c, 0x49, 0x4a,
	/*d*/	0x6b, 0x68, 0x6d, 0x6e, 0x67, 0x64, 0x61, 0x62, 0x73, 0x70, 0x75, 0x76, 0x7f, 0x7c, 0x79, 0x7a,
	/*e*/	0x3b, 0x38, 0x3d, 0x3e, 0x37, 0x34, 0x31, 0x32, 0x23, 0x20, 0x25, 0x26, 0x2f, 0x2c, 0x29, 0x2a,
	/*f*/	0x0b, 0x08, 0x0d, 0x0e, 0x07, 0x04, 0x01, 0x02, 0x13, 0x10, 0x15, 0x16, 0x1f, 0x1c, 0x19, 0x1a,
};

static uint8_t oaes_gf_mul_9[16][16] = {
	// 		0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    a,    b,    c,    d,    e,    f,
	/*0*/	0x00, 0x09, 0x12, 0x1b, 0x24, 0x2d, 0x36, 0x3f, 0x48, 0x41, 0x5a, 0x53, 0x6c, 0x65, 0x7e, 0x77,
	/*1*/	0x90, 0x99, 0x82, 0x8b, 0xb4, 0xbd, 0xa6, 0xaf, 0xd8, 0xd1, 0xca, 0xc3, 0xfc, 0xf5, 0xee, 0xe7,
	/*2*/	0x3b, 0x32, 0x29, 0x20, 0x1f, 0x16, 0x0d, 0x04, 0x73, 0x7a, 0x61, 0x68, 0x57, 0x5e, 0x45, 0x4c,
	/*3*/	0xab, 0xa2, 0xb9, 0xb0, 0x8f, 0x86, 0x9d, 0x94, 0xe3, 0xea, 0xf1, 0xf8, 0xc7, 0xce, 0xd5, 0xdc,
	/*4*/	0x76, 0x7f, 0x64, 0x6d, 0x52, 0x5b, 0x40, 0x49, 0x3e, 0x37, 0x2c, 0x25, 0x1a, 0x13, 0x08, 0x01,
	/*5*/	0xe6, 0xef, 0xf4, 0xfd, 0xc2, 0xcb, 0xd0, 0xd9, 0xae, 0xa7, 0xbc, 0xb5, 0x8a, 0x83, 0x98, 0x91,
	/*6*/	0x4d, 0x44, 0x5f, 0x56, 0x69, 0x60, 0x7b, 0x72, 0x05, 0x0c, 0x17, 0x1e, 0x21, 0x28, 0x33, 0x3a,
	/*7*/	0xdd, 0xd4, 0xcf, 0xc6, 0xf9, 0xf0, 0xeb, 0xe2, 0x95, 0x9c, 0x87, 0x8e, 0xb1, 0xb8, 0xa3, 0xaa,
	/*8*/	0xec, 0xe5, 0xfe, 0xf7, 0xc8, 0xc1, 0xda, 0xd3, 0xa4, 0xad, 0xb6, 0xbf, 0x80, 0x89, 0x92, 0x9b,
	/*9*/	0x7c, 0x75, 0x6e, 0x67, 0x58, 0x51, 0x4a, 0x43, 0x34, 0x3d, 0x26, 0x2f, 0x10, 0x19, 0x02, 0x0b,
	/*a*/	0xd7, 0xde, 0xc5, 0xcc, 0xf3, 0xfa, 0xe1, 0xe8, 0x9f, 0x96, 0x8d, 0x84, 0xbb, 0xb2, 0xa9, 0xa0,
	/*b*/	0x47, 0x4e, 0x55, 0x5c, 0x63, 0x6a, 0x71, 0x78, 0x0f, 0x06, 0x1d, 0x14, 0x2b, 0x22, 0x39, 0x30,
	/*c*/	0x9a, 0x93, 0x88, 0x81, 0xbe, 0xb7, 0xac, 0xa5, 0xd2, 0xdb, 0xc0, 0xc9, 0xf6, 0xff, 0xe4, 0xed,
	/*d*/	0x0a, 0x03, 0x18, 0x11, 0x2e, 0x27, 0x3c, 0x35, 0x42, 0x4b, 0x50, 0x59, 0x66, 0x6f, 0x74, 0x7d,
	/*e*/	0xa1, 0xa8, 0xb3, 0xba, 0x85, 0x8c, 0x97, 0x9e, 0xe9, 0xe0, 0xfb, 0xf2, 0xcd, 0xc4, 0xdf, 0xd6,
	/*f*/	0x31, 0x38, 0x23, 0x2a, 0x15, 0x1c, 0x07, 0x0e, 0x79, 0x70, 0x6b, 0x62, 0x5d, 0x54, 0x4f, 0x46,
};

static uint8_t oaes_gf_mul_b[16][16] = {
	// 		0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    a,    b,    c,    d,    e,    f,
	/*0*/	0x00, 0x0b, 0x16, 0x1d, 0x2c, 0x27, 0x3a, 0x31, 0x58, 0x53, 0x4e, 0x45, 0x74, 0x7f, 0x62, 0x69,
	/*1*/	0xb0, 0xbb, 0xa6, 0xad, 0x9c, 0x97, 0x8a, 0x81, 0xe8, 0xe3, 0xfe, 0xf5, 0xc4, 0xcf, 0xd2, 0xd9,
	/*2*/	0x7b, 0x70, 0x6d, 0x66, 0x57, 0x5c, 0x41, 0x4a, 0x23, 0x28, 0x35, 0x3e, 0x0f, 0x04, 0x19, 0x12,
	/*3*/	0xcb, 0xc0, 0xdd, 0xd6, 0xe7, 0xec, 0xf1, 0xfa, 0x93, 0x98, 0x85, 0x8e, 0xbf, 0xb4, 0xa9, 0xa2,
	/*4*/	0xf6, 0xfd, 0xe0, 0xeb, 0xda, 0xd1, 0xcc, 0xc7, 0xae, 0xa5, 0xb8, 0xb3, 0x82, 0x89, 0x94, 0x9f,
	/*5*/	0x46, 0x4d, 0x50, 0x5b, 0x6a, 0x61, 0x7c, 0x77, 0x1e, 0x15, 0x08, 0x03, 0x32, 0x39, 0x24, 0x2f,
	/*6*/	0x8d, 0x86, 0x9b, 0x90, 0xa1, 0xaa, 0xb7, 0xbc, 0xd5, 0xde, 0xc3, 0xc8, 0xf9, 0xf2, 0xef, 0xe4,
	/*7*/	0x3d, 0x36, 0x2b, 0x20, 0x11, 0x1a, 0x07, 0x0c, 0x65, 0x6e, 0x73, 0x78, 0x49, 0x42, 0x5f, 0x54,
	/*8*/	0xf7, 0xfc, 0xe1, 0xea, 0xdb, 0xd0, 0xcd, 0xc6, 0xaf, 0xa4, 0xb9, 0xb2, 0x83, 0x88, 0x95, 0x9e,
	/*9*/	0x47, 0x4c, 0x51, 0x5a, 0x6b, 0x60, 0x7d, 0x76, 0x1f, 0x14, 0x09, 0x02, 0x33, 0x38, 0x25, 0x2e,
	/*a*/	0x8c, 0x87, 0x9a, 0x91, 0xa0, 0xab, 0xb6, 0xbd, 0xd4, 0xdf, 0xc2, 0xc9, 0xf8, 0xf3, 0xee, 0xe5,
	/*b*/	0x3c, 0x37, 0x2a, 0x21, 0x10, 0x1b, 0x06, 0x0d, 0x64, 0x6f, 0x72, 0x79, 0x48, 0x43, 0x5e, 0x55,
	/*c*/	0x01, 0x0a, 0x17, 0x1c, 0x2d, 0x26, 0x3b, 0x30, 0x59, 0x52, 0x4f, 0x44, 0x75, 0x7e, 0x63, 0x68,
	/*d*/	0xb1, 0xba, 0xa7, 0xac, 0x9d, 0x96, 0x8b, 0x80, 0xe9, 0xe2, 0xff, 0xf4, 0xc5, 0xce, 0xd3, 0xd8,
	/*e*/	0x7a, 0x71, 0x6c, 0x67, 0x56, 0x5d, 0x40, 0x4b, 0x22, 0x29, 0x34, 0x3f, 0x0e, 0x05, 0x18, 0x13,
	/*f*/	0xca, 0xc1, 0xdc, 0xd7, 0xe6, 0xed, 0xf0, 0xfb, 0x92, 0x99, 0x84, 0x8f, 0xbe, 0xb5, 0xa8, 0xa3,
};

static uint8_t oaes_gf_mul_d[16][16] = {
	// 		0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    a,    b,    c,    d,    e,    f,
	/*0*/	0x00, 0x0d, 0x1a, 0x17, 0x34, 0x39, 0x2e, 0x23, 0x68, 0x65, 0x72, 0x7f, 0x5c, 0x51, 0x46, 0x4b,
	/*1*/	0xd0, 0xdd, 0xca, 0xc7, 0xe4, 0xe9, 0xfe, 0xf3, 0xb8, 0xb5, 0xa2, 0xaf, 0x8c, 0x81, 0x96, 0x9b,
	/*2*/	0xbb, 0xb6, 0xa1, 0xac, 0x8f, 0x82, 0x95, 0x98, 0xd3, 0xde, 0xc9, 0xc4, 0xe7, 0xea, 0xfd, 0xf0,
	/*3*/	0x6b, 0x66, 0x71, 0x7c, 0x5f, 0x52, 0x45, 0x48, 0x03, 0x0e, 0x19, 0x14, 0x37, 0x3a, 0x2d, 0x20,
	/*4*/	0x6d, 0x60, 0x77, 0x7a, 0x59, 0x54, 0x43, 0x4e, 0x05, 0x08, 0x1f, 0x12, 0x31, 0x3c, 0x2b, 0x26,
	/*5*/	0xbd, 0xb0, 0xa7, 0xaa, 0x89, 0x84, 0x93, 0x9e, 0xd5, 0xd8, 0xcf, 0xc2, 0xe1, 0xec, 0xfb, 0xf6,
	/*6*/	0xd6, 0xdb, 0xcc, 0xc1, 0xe2, 0xef, 0xf8, 0xf5, 0xbe, 0xb3, 0xa4, 0xa9, 0x8a, 0x87, 0x90, 0x9d,
	/*7*/	0x06, 0x0b, 0x1c, 0x11, 0x32, 0x3f, 0x28, 0x25, 0x6e, 0x63, 0x74, 0x79, 0x5a, 0x57, 0x40, 0x4d,
	/*8*/	0xda, 0xd7, 0xc0, 0xcd, 0xee, 0xe3, 0xf4, 0xf9, 0xb2, 0xbf, 0xa8, 0xa5, 0x86, 0x8b, 0x9c, 0x91,
	/*9*/	0x0a, 0x07, 0x10, 0x1d, 0x3e, 0x33, 0x24, 0x29, 0x62, 0x6f, 0x78, 0x75, 0x56, 0x5b, 0x4c, 0x41,
	/*a*/	0x61, 0x6c, 0x7b, 0x76, 0x55, 0x58, 0x4f, 0x42, 0x09, 0x04, 0x13, 0x1e, 0x3d, 0x30, 0x27, 0x2a,
	/*b*/	0xb1, 0xbc, 0xab, 0xa6, 0x85, 0x88, 0x9f, 0x92, 0xd9, 0xd4, 0xc3, 0xce, 0xed, 0xe0, 0xf7, 0xfa,
	/*c*/	0xb7, 0xba, 0xad, 0xa0, 0x83, 0x8e, 0x99, 0x94, 0xdf, 0xd2, 0xc5, 0xc8, 0xeb, 0xe6, 0xf1, 0xfc,
	/*d*/	0x67, 0x6a, 0x7d, 0x70, 0x53, 0x5e, 0x49, 0x44, 0x0f, 0x02, 0x15, 0x18, 0x3b, 0x36, 0x21, 0x2c,
	/*e*/	0x0c, 0x01, 0x16, 0x1b, 0x38, 0x35, 0x22, 0x2f, 0x64, 0x69, 0x7e, 0x73, 0x50, 0x5d, 0x4a, 0x47,
	/*f*/	0xdc, 0xd1, 0xc6, 0xcb, 0xe8, 0xe5, 0xf2, 0xff, 0xb4, 0xb9, 0xae, 0xa3, 0x80, 0x8d, 0x9a, 0x97,
};

static uint8_t oaes_gf_mul_e[16][16] = {
	// 		0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    a,    b,    c,    d,    e,    f,
	/*0*/	0x00, 0x0e, 0x1c, 0x12, 0x38, 0x36, 0x24, 0x2a, 0x70, 0x7e, 0x6c, 0x62, 0x48, 0x46, 0x54, 0x5a,
	/*1*/	0xe0, 0xee, 0xfc, 0xf2, 0xd8, 0xd6, 0xc4, 0xca, 0x90, 0x9e, 0x8c, 0x82, 0xa8, 0xa6, 0xb4, 0xba,
	/*2*/	0xdb, 0xd5, 0xc7, 0xc9, 0xe3, 0xed, 0xff, 0xf1, 0xab, 0xa5, 0xb7, 0xb9, 0x93, 0x9d, 0x8f, 0x81,
	/*3*/	0x3b, 0x35, 0x27, 0x29, 0x03, 0x0d, 0x1f, 0x11, 0x4b, 0x45, 0x57, 0x59, 0x73, 0x7d, 0x6f, 0x61,
	/*4*/	0xad, 0xa3, 0xb1, 0xbf, 0x95, 0x9b, 0x89, 0x87, 0xdd, 0xd3, 0xc1, 0xcf, 0xe5, 0xeb, 0xf9, 0xf7,
	/*5*/	0x4d, 0x43, 0x51, 0x5f, 0x75, 0x7b, 0x69, 0x67, 0x3d, 0x33, 0x21, 0x2f, 0x05, 0x0b, 0x19, 0x17,
	/*6*/	0x76, 0x78, 0x6a, 0x64, 0x4e, 0x40, 0x52, 0x5c, 0x06, 0x08, 0x1a, 0x14, 0x3e, 0x30, 0x22, 0x2c,
	/*7*/	0x96, 0x98, 0x8a, 0x84, 0xae, 0xa0, 0xb2, 0xbc, 0xe6, 0xe8, 0xfa, 0xf4, 0xde, 0xd0, 0xc2, 0xcc,
	/*8*/	0x41, 0x4f, 0x5d, 0x53, 0x79, 0x77, 0x65, 0x6b, 0x31, 0x3f, 0x2d, 0x23, 0x09, 0x07, 0x15, 0x1b,
	/*9*/	0xa1, 0xaf, 0xbd, 0xb3, 0x99, 0x97, 0x85, 0x8b, 0xd1, 0xdf, 0xcd, 0xc3, 0xe9, 0xe7, 0xf5, 0xfb,
	/*a*/	0x9a, 0x94, 0x86, 0x88, 0xa2, 0xac, 0xbe, 0xb0, 0xea, 0xe4, 0xf6, 0xf8, 0xd2, 0xdc, 0xce, 0xc0,
	/*b*/	0x7a, 0x74, 0x66, 0x68, 0x42, 0x4c, 0x5e, 0x50, 0x0a, 0x04, 0x16, 0x18, 0x32, 0x3c, 0x2e, 0x20,
	/*c*/	0xec, 0xe2, 0xf0, 0xfe, 0xd4, 0xda, 0xc8, 0xc6, 0x9c, 0x92, 0x80, 0x8e, 0xa4, 0xaa, 0xb8, 0xb6,
	/*d*/	0x0c, 0x02, 0x10, 0x1e, 0x34, 0x3a, 0x28, 0x26, 0x7c, 0x72, 0x60, 0x6e, 0x44, 0x4a, 0x58, 0x56,
	/*e*/	0x37, 0x39, 0x2b, 0x25, 0x0f, 0x01, 0x13, 0x1d, 0x47, 0x49, 0x5b, 0x55, 0x7f, 0x71, 0x63, 0x6d,
	/*f*/	0xd7, 0xd9, 0xcb, 0xc5, 0xef, 0xe1, 0xf3, 0xfd, 0xa7, 0xa9, 0xbb, 0xb5, 0x9f, 0x91, 0x83, 0x8d,
};

static OAES_RET oaes_sub_byte( uint8_t * byte )
{
	size_t _x, _y;
	
	if( NULL == byte )
		return OAES_RET_ARG1;

	_x = _y = *byte;
	_x &= 0x0f;
	_y &= 0xf0;
	_y >>= 4;
	*byte = oaes_sub_byte_value[_y][_x];
	
	return OAES_RET_SUCCESS;
}

static OAES_RET oaes_inv_sub_byte( uint8_t * byte )
{
	size_t _x, _y;
	
	if( NULL == byte )
		return OAES_RET_ARG1;

	_x = _y = *byte;
	_x &= 0x0f;
	_y &= 0xf0;
	_y >>= 4;
	*byte = oaes_inv_sub_byte_value[_y][_x];
	
	return OAES_RET_SUCCESS;
}

#if 0 // LIMELIGHT
static OAES_RET oaes_word_rot_right( uint8_t word[OAES_COL_LEN] )
{
	uint8_t _temp[OAES_COL_LEN];
	
	if( NULL == word )
		return OAES_RET_ARG1;

	memcpy( _temp + 1, word, OAES_COL_LEN - 1 );
	_temp[0] = word[OAES_COL_LEN - 1];
	memcpy( word, _temp, OAES_COL_LEN );
	
	return OAES_RET_SUCCESS;
}
#endif

static OAES_RET oaes_word_rot_left( uint8_t word[OAES_COL_LEN] )
{
	uint8_t _temp[OAES_COL_LEN];
	
	if( NULL == word )
		return OAES_RET_ARG1;

	memcpy( _temp, word + 1, OAES_COL_LEN - 1 );
	_temp[OAES_COL_LEN - 1] = word[0];
	memcpy( word, _temp, OAES_COL_LEN );
	
	return OAES_RET_SUCCESS;
}

static OAES_RET oaes_shift_rows( uint8_t block[OAES_BLOCK_SIZE] )
{
	uint8_t _temp[OAES_BLOCK_SIZE];

	if( NULL == block )
		return OAES_RET_ARG1;

	_temp[0x00] = block[0x00];
	_temp[0x01] = block[0x05];
	_temp[0x02] = block[0x0a];
	_temp[0x03] = block[0x0f];
	_temp[0x04] = block[0x04];
	_temp[0x05] = block[0x09];
	_temp[0x06] = block[0x0e];
	_temp[0x07] = block[0x03];
	_temp[0x08] = block[0x08];
	_temp[0x09] = block[0x0d];
	_temp[0x0a] = block[0x02];
	_temp[0x0b] = block[0x07];
	_temp[0x0c] = block[0x0c];
	_temp[0x0d] = block[0x01];
	_temp[0x0e] = block[0x06];
	_temp[0x0f] = block[0x0b];
	memcpy( block, _temp, OAES_BLOCK_SIZE );
	
	return OAES_RET_SUCCESS;
}

static OAES_RET oaes_inv_shift_rows( uint8_t block[OAES_BLOCK_SIZE] )
{
	uint8_t _temp[OAES_BLOCK_SIZE];

	if( NULL == block )
		return OAES_RET_ARG1;

	_temp[0x00] = block[0x00];
	_temp[0x01] = block[0x0d];
	_temp[0x02] = block[0x0a];
	_temp[0x03] = block[0x07];
	_temp[0x04] = block[0x04];
	_temp[0x05] = block[0x01];
	_temp[0x06] = block[0x0e];
	_temp[0x07] = block[0x0b];
	_temp[0x08] = block[0x08];
	_temp[0x09] = block[0x05];
	_temp[0x0a] = block[0x02];
	_temp[0x0b] = block[0x0f];
	_temp[0x0c] = block[0x0c];
	_temp[0x0d] = block[0x09];
	_temp[0x0e] = block[0x06];
	_temp[0x0f] = block[0x03];
	memcpy( block, _temp, OAES_BLOCK_SIZE );
	
	return OAES_RET_SUCCESS;
}

static uint8_t oaes_gf_mul(uint8_t left, uint8_t right)
{
	size_t _x, _y;
	
	_x = _y = left;
	_x &= 0x0f;
	_y &= 0xf0;
	_y >>= 4;
	
	switch( right )
	{
		case 0x02:
			return oaes_gf_mul_2[_y][_x];
			break;
		case 0x03:
			return oaes_gf_mul_3[_y][_x];
			break;
		case 0x09:
			return oaes_gf_mul_9[_y][_x];
			break;
		case 0x0b:
			return oaes_gf_mul_b[_y][_x];
			break;
		case 0x0d:
			return oaes_gf_mul_d[_y][_x];
			break;
		case 0x0e:
			return oaes_gf_mul_e[_y][_x];
			break;
		default:
			return left;
			break;
	}
}

static OAES_RET oaes_mix_cols( uint8_t word[OAES_COL_LEN] )
{
	uint8_t _temp[OAES_COL_LEN];

	if( NULL == word )
		return OAES_RET_ARG1;
	
	_temp[0] = oaes_gf_mul(word[0], 0x02) ^ oaes_gf_mul( word[1], 0x03 ) ^
			word[2] ^ word[3];
	_temp[1] = word[0] ^ oaes_gf_mul( word[1], 0x02 ) ^
			oaes_gf_mul( word[2], 0x03 ) ^ word[3];
	_temp[2] = word[0] ^ word[1] ^
			oaes_gf_mul( word[2], 0x02 ) ^ oaes_gf_mul( word[3], 0x03 );
	_temp[3] = oaes_gf_mul( word[0], 0x03 ) ^ word[1] ^
			word[2] ^ oaes_gf_mul( word[3], 0x02 );
	memcpy( word, _temp, OAES_COL_LEN );
	
	return OAES_RET_SUCCESS;
}

static OAES_RET oaes_inv_mix_cols( uint8_t word[OAES_COL_LEN] )
{
	uint8_t _temp[OAES_COL_LEN];

	if( NULL == word )
		return OAES_RET_ARG1;
	
	_temp[0] = oaes_gf_mul( word[0], 0x0e ) ^ oaes_gf_mul( word[1], 0x0b ) ^
			oaes_gf_mul( word[2], 0x0d ) ^ oaes_gf_mul( word[3], 0x09 );
	_temp[1] = oaes_gf_mul( word[0], 0x09 ) ^ oaes_gf_mul( word[1], 0x0e ) ^
			oaes_gf_mul( word[2], 0x0b ) ^ oaes_gf_mul( word[3], 0x0d );
	_temp[2] = oaes_gf_mul( word[0], 0x0d ) ^ oaes_gf_mul( word[1], 0x09 ) ^
			oaes_gf_mul( word[2], 0x0e ) ^ oaes_gf_mul( word[3], 0x0b );
	_temp[3] = oaes_gf_mul( word[0], 0x0b ) ^ oaes_gf_mul( word[1], 0x0d ) ^
			oaes_gf_mul( word[2], 0x09 ) ^ oaes_gf_mul( word[3], 0x0e );
	memcpy( word, _temp, OAES_COL_LEN );
	
	return OAES_RET_SUCCESS;
}

OAES_RET oaes_sprintf(
		char * buf, size_t * buf_len, const uint8_t * data, size_t data_len )
{
	size_t _i, _buf_len_in;
	char _temp[4];
	
	if( NULL == buf_len )
		return OAES_RET_ARG2;

	_buf_len_in = *buf_len;
	*buf_len = data_len * 3 + data_len / OAES_BLOCK_SIZE + 1;
	
	if( NULL == buf )
		return OAES_RET_SUCCESS;

	if( *buf_len > _buf_len_in )
		return OAES_RET_BUF;

	if( NULL == data )
		return OAES_RET_ARG3;

	strcpy( buf, "" );
	
	for( _i = 0; _i < data_len; _i++ )
	{
		sprintf( _temp, "%02x ", data[_i] );
		strcat( buf, _temp );
		if( _i && 0 == ( _i + 1 ) % OAES_BLOCK_SIZE )
			strcat( buf, "\n" );
	}
	
	return OAES_RET_SUCCESS;
}

#ifdef OAES_HAVE_ISAAC
static void oaes_get_seed( char buf[RANDSIZ + 1] )
{
	struct timeb timer;
	struct tm *gmTimer;
	char * _test = NULL;
	
	ftime (&timer);
	gmTimer = gmtime( &timer.time );
	_test = (char *) calloc( sizeof( char ), timer.millitm );
	sprintf( buf, "%04d%02d%02d%02d%02d%02d%03d%p%d",
		gmTimer->tm_year + 1900, gmTimer->tm_mon + 1, gmTimer->tm_mday,
		gmTimer->tm_hour, gmTimer->tm_min, gmTimer->tm_sec, timer.millitm,
		_test + timer.millitm, getpid() );
	
	if( _test )
		free( _test );
}
#else
static uint32_t oaes_get_seed()
{
	struct timeb timer;
	struct tm *gmTimer;
	char * _test = NULL;
	uint32_t _ret = 0;
	
	ftime (&timer);
	gmTimer = gmtime( &timer.time );
	_test = (char *) calloc( sizeof( char ), timer.millitm );
	_ret = gmTimer->tm_year + 1900 + gmTimer->tm_mon + 1 + gmTimer->tm_mday +
			gmTimer->tm_hour + gmTimer->tm_min + gmTimer->tm_sec + timer.millitm +
			(uint32_t) ( _test + timer.millitm );

	if( _test )
		free( _test );
	
	return _ret;
}
#endif // OAES_HAVE_ISAAC

static OAES_RET oaes_key_destroy( oaes_key ** key )
{
	if( NULL == *key )
		return OAES_RET_SUCCESS;
	
	if( (*key)->data )
	{
		free( (*key)->data );
		(*key)->data = NULL;
	}
	
	if( (*key)->exp_data )
	{
		free( (*key)->exp_data );
		(*key)->exp_data = NULL;
	}
	
	(*key)->data_len = 0;
	(*key)->exp_data_len = 0;
	(*key)->num_keys = 0;
	(*key)->key_base = 0;
	free( *key );
	*key = NULL;
	
	return OAES_RET_SUCCESS;
}

static OAES_RET oaes_key_expand( OAES_CTX * ctx )
{
	size_t _i, _j;
	oaes_ctx * _ctx = (oaes_ctx *) ctx;
	
	if( NULL == _ctx )
		return OAES_RET_ARG1;
	
	if( NULL == _ctx->key )
		return OAES_RET_NOKEY;
	
	_ctx->key->key_base = _ctx->key->data_len / OAES_RKEY_LEN;
	_ctx->key->num_keys =  _ctx->key->key_base + OAES_ROUND_BASE;
					
	_ctx->key->exp_data_len = _ctx->key->num_keys * OAES_RKEY_LEN * OAES_COL_LEN;
	_ctx->key->exp_data = (uint8_t *)
			calloc( _ctx->key->exp_data_len, sizeof( uint8_t ));
	
	if( NULL == _ctx->key->exp_data )
		return OAES_RET_MEM;
	
	// the first _ctx->key->data_len are a direct copy
	memcpy( _ctx->key->exp_data, _ctx->key->data, _ctx->key->data_len );

	// apply ExpandKey algorithm for remainder
	for( _i = _ctx->key->key_base; _i < _ctx->key->num_keys * OAES_RKEY_LEN; _i++ )
	{
		uint8_t _temp[OAES_COL_LEN];
		
		memcpy( _temp,
				_ctx->key->exp_data + ( _i - 1 ) * OAES_RKEY_LEN, OAES_COL_LEN );
		
		// transform key column
		if( 0 == _i % _ctx->key->key_base )
		{
			oaes_word_rot_left( _temp );

			for( _j = 0; _j < OAES_COL_LEN; _j++ )
				oaes_sub_byte( _temp + _j );

			_temp[0] = _temp[0] ^ oaes_gf_8[ _i / _ctx->key->key_base - 1 ];
		}
		else if( _ctx->key->key_base > 6 && 4 == _i % _ctx->key->key_base )
		{
			for( _j = 0; _j < OAES_COL_LEN; _j++ )
				oaes_sub_byte( _temp + _j );
		}
		
		for( _j = 0; _j < OAES_COL_LEN; _j++ )
		{
			_ctx->key->exp_data[ _i * OAES_RKEY_LEN + _j ] =
					_ctx->key->exp_data[ ( _i - _ctx->key->key_base ) *
					OAES_RKEY_LEN + _j ] ^ _temp[_j];
		}
	}
	
	return OAES_RET_SUCCESS;
}

static OAES_RET oaes_key_gen( OAES_CTX * ctx, size_t key_size )
{
	size_t _i;
	oaes_key * _key = NULL;
	oaes_ctx * _ctx = (oaes_ctx *) ctx;
	OAES_RET _rc = OAES_RET_SUCCESS;
	
	if( NULL == _ctx )
		return OAES_RET_ARG1;
	
	_key = (oaes_key *) calloc( sizeof( oaes_key ), 1 );
	
	if( NULL == _key )
		return OAES_RET_MEM;
	
	if( _ctx->key )
		oaes_key_destroy( &(_ctx->key) );
	
	_key->data_len = key_size;
	_key->data = (uint8_t *) calloc( key_size, sizeof( uint8_t ));
	
	if( NULL == _key->data )
    {
        free(_key);
		return OAES_RET_MEM;
    }
    
	
	for( _i = 0; _i < key_size; _i++ )
		_key->data[_i] = (uint8_t) OAES_RAND(_ctx->rctx);
	
	_ctx->key = _key;
	_rc = _rc || oaes_key_expand( ctx );
	
	if( _rc != OAES_RET_SUCCESS )
	{
		oaes_key_destroy( &(_ctx->key) );
		return _rc;
	}
	
	return OAES_RET_SUCCESS;
}

OAES_RET oaes_key_gen_128( OAES_CTX * ctx )
{
	return oaes_key_gen( ctx, 16 );
}

OAES_RET oaes_key_gen_192( OAES_CTX * ctx )
{
	return oaes_key_gen( ctx, 24 );
}

OAES_RET oaes_key_gen_256( OAES_CTX * ctx )
{
	return oaes_key_gen( ctx, 32 );
}

OAES_RET oaes_key_export( OAES_CTX * ctx,
		uint8_t * data, size_t * data_len )
{
	size_t _data_len_in;
	oaes_ctx * _ctx = (oaes_ctx *) ctx;
	
	if( NULL == _ctx )
		return OAES_RET_ARG1;
	
	if( NULL == _ctx->key )
		return OAES_RET_NOKEY;
	
	if( NULL == data_len )
		return OAES_RET_ARG3;

	_data_len_in = *data_len;
	// data + header
	*data_len = _ctx->key->data_len + OAES_BLOCK_SIZE;

	if( NULL == data )
		return OAES_RET_SUCCESS;
	
	if( _data_len_in < *data_len )
		return OAES_RET_BUF;
	
	// header
	memcpy( data, oaes_header, OAES_BLOCK_SIZE );
	data[5] = 0x01;
	data[7] = _ctx->key->data_len;
	memcpy( data + OAES_BLOCK_SIZE, _ctx->key->data, _ctx->key->data_len );
	
	return OAES_RET_SUCCESS;
}

OAES_RET oaes_key_export_data( OAES_CTX * ctx,
		uint8_t * data, size_t * data_len )
{
	size_t _data_len_in;
	oaes_ctx * _ctx = (oaes_ctx *) ctx;
	
	if( NULL == _ctx )
		return OAES_RET_ARG1;
	
	if( NULL == _ctx->key )
		return OAES_RET_NOKEY;
	
	if( NULL == data_len )
		return OAES_RET_ARG3;

	_data_len_in = *data_len;
	*data_len = _ctx->key->data_len;

	if( NULL == data )
		return OAES_RET_SUCCESS;
	
	if( _data_len_in < *data_len )
		return OAES_RET_BUF;
	
	memcpy( data, _ctx->key->data, *data_len );
	
	return OAES_RET_SUCCESS;
}

OAES_RET oaes_key_import( OAES_CTX * ctx,
		const uint8_t * data, size_t data_len )
{
	oaes_ctx * _ctx = (oaes_ctx *) ctx;
	OAES_RET _rc = OAES_RET_SUCCESS;
	int _key_length;
	
	if( NULL == _ctx )
		return OAES_RET_ARG1;
	
	if( NULL == data )
		return OAES_RET_ARG2;
	
	switch( data_len )
	{
		case 16 + OAES_BLOCK_SIZE:
		case 24 + OAES_BLOCK_SIZE:
		case 32 + OAES_BLOCK_SIZE:
			break;
		default:
			return OAES_RET_ARG3;
	}
	
	// header
	if( 0 != memcmp( data, oaes_header, 4 ) )
		return OAES_RET_HEADER;

	// header version
	switch( data[4] )
	{
		case 0x01:
			break;
		default:
			return OAES_RET_HEADER;
	}
	
	// header type
	switch( data[5] )
	{
		case 0x01:
			break;
		default:
			return OAES_RET_HEADER;
	}
	
	// options
	_key_length = data[7];
	switch( _key_length )
	{
		case 16:
		case 24:
		case 32:
			break;
		default:
			return OAES_RET_HEADER;
	}
	
	if( data_len != _key_length + OAES_BLOCK_SIZE )
			return OAES_RET_ARG3;
	
	if( _ctx->key )
		oaes_key_destroy( &(_ctx->key) );
	
	_ctx->key = (oaes_key *) calloc( sizeof( oaes_key ), 1 );
	
	if( NULL == _ctx->key )
		return OAES_RET_MEM;
	
	_ctx->key->data_len = _key_length;
	_ctx->key->data = (uint8_t *)
			calloc( _key_length, sizeof( uint8_t ));
	
	if( NULL == _ctx->key->data )
	{
		oaes_key_destroy( &(_ctx->key) );
		return OAES_RET_MEM;
	}

	memcpy( _ctx->key->data, data + OAES_BLOCK_SIZE, _key_length );
	_rc = _rc || oaes_key_expand( ctx );
	
	if( _rc != OAES_RET_SUCCESS )
	{
		oaes_key_destroy( &(_ctx->key) );
		return _rc;
	}
	
	return OAES_RET_SUCCESS;
}

OAES_RET oaes_key_import_data( OAES_CTX * ctx,
		const uint8_t * data, size_t data_len )
{
	oaes_ctx * _ctx = (oaes_ctx *) ctx;
	OAES_RET _rc = OAES_RET_SUCCESS;
	
	if( NULL == _ctx )
		return OAES_RET_ARG1;
	
	if( NULL == data )
		return OAES_RET_ARG2;
	
	switch( data_len )
	{
		case 16:
		case 24:
		case 32:
			break;
		default:
			return OAES_RET_ARG3;
	}
	
	if( _ctx->key )
		oaes_key_destroy( &(_ctx->key) );
	
	_ctx->key = (oaes_key *) calloc( sizeof( oaes_key ), 1 );
	
	if( NULL == _ctx->key )
		return OAES_RET_MEM;
	
	_ctx->key->data_len = data_len;
	_ctx->key->data = (uint8_t *)
			calloc( data_len, sizeof( uint8_t ));
	
	if( NULL == _ctx->key->data )
	{
		oaes_key_destroy( &(_ctx->key) );
		return OAES_RET_MEM;
	}

	memcpy( _ctx->key->data, data, data_len );
	_rc = _rc || oaes_key_expand( ctx );
	
	if( _rc != OAES_RET_SUCCESS )
	{
		oaes_key_destroy( &(_ctx->key) );
		return _rc;
	}
	
	return OAES_RET_SUCCESS;
}

OAES_CTX * oaes_alloc()
{
	oaes_ctx * _ctx = (oaes_ctx *) calloc( sizeof( oaes_ctx ), 1 );
	
	if( NULL == _ctx )
		return NULL;

#ifdef OAES_HAVE_ISAAC
	{
	  ub4 _i = 0;
		char _seed[RANDSIZ + 1];
		
		_ctx->rctx = (randctx *) calloc( sizeof( randctx ), 1 );

		if( NULL == _ctx->rctx )
		{
			free( _ctx );
			return NULL;
		}

		oaes_get_seed( _seed );
		memset( _ctx->rctx->randrsl, 0, RANDSIZ );
		memcpy( _ctx->rctx->randrsl, _seed, RANDSIZ );
		randinit( _ctx->rctx, TRUE);
	}
#else
		srand( oaes_get_seed() );
#endif // OAES_HAVE_ISAAC

	_ctx->key = NULL;
	oaes_set_option( _ctx, OAES_OPTION_CBC, NULL );

#ifdef OAES_DEBUG
	_ctx->step_cb = NULL;
	oaes_set_option( _ctx, OAES_OPTION_STEP_OFF, NULL );
#endif // OAES_DEBUG

	return (OAES_CTX *) _ctx;
}

OAES_RET oaes_free( OAES_CTX ** ctx )
{
	oaes_ctx ** _ctx = (oaes_ctx **) ctx;

	if( NULL == _ctx )
		return OAES_RET_ARG1;
	
	if( NULL == *_ctx )
		return OAES_RET_SUCCESS;
	
	if( (*_ctx)->key )
		oaes_key_destroy( &((*_ctx)->key) );

#ifdef OAES_HAVE_ISAAC
	if( (*_ctx)->rctx )
	{
		free( (*_ctx)->rctx );
		(*_ctx)->rctx = NULL;
	}
#endif // OAES_HAVE_ISAAC
	
	free( *_ctx );
	*_ctx = NULL;

	return OAES_RET_SUCCESS;
}

OAES_RET oaes_set_option( OAES_CTX * ctx,
		OAES_OPTION option, const void * value )
{
	size_t _i;
	oaes_ctx * _ctx = (oaes_ctx *) ctx;
	
	if( NULL == _ctx )
		return OAES_RET_ARG1;

	switch( option )
	{
		case OAES_OPTION_ECB:
			_ctx->options &= ~OAES_OPTION_CBC;
			memset( _ctx->iv, 0, OAES_BLOCK_SIZE );
			break;

		case OAES_OPTION_CBC:
			_ctx->options &= ~OAES_OPTION_ECB;
			if( value )
				memcpy( _ctx->iv, value, OAES_BLOCK_SIZE );
			else
			{
				for( _i = 0; _i < OAES_BLOCK_SIZE; _i++ )
					_ctx->iv[_i] = (uint8_t) OAES_RAND(_ctx->rctx);
			}
			break;

#ifdef OAES_DEBUG

		case OAES_OPTION_STEP_ON:
			if( value )
			{
				_ctx->options &= ~OAES_OPTION_STEP_OFF;
				_ctx->step_cb = value;
			}
			else
			{
				_ctx->options &= ~OAES_OPTION_STEP_ON;
				_ctx->options |= OAES_OPTION_STEP_OFF;
				_ctx->step_cb = NULL;
				return OAES_RET_ARG3;
			}
			break;

		case OAES_OPTION_STEP_OFF:
			_ctx->options &= ~OAES_OPTION_STEP_ON;
			_ctx->step_cb = NULL;
			break;

#endif // OAES_DEBUG

		default:
			return OAES_RET_ARG2;
	}

	_ctx->options |= option;

	return OAES_RET_SUCCESS;
}

static OAES_RET oaes_encrypt_block(
		OAES_CTX * ctx, uint8_t * c, size_t c_len )
{
	size_t _i, _j;
	oaes_ctx * _ctx = (oaes_ctx *) ctx;
	
	if( NULL == _ctx )
		return OAES_RET_ARG1;
	
	if( NULL == c )
		return OAES_RET_ARG2;
	
	if( c_len != OAES_BLOCK_SIZE )
		return OAES_RET_ARG3;
	
	if( NULL == _ctx->key )
		return OAES_RET_NOKEY;
	
#ifdef OAES_DEBUG
	if( _ctx->step_cb )
		_ctx->step_cb( c, "input", 1, NULL );
#endif // OAES_DEBUG

	// AddRoundKey(State, K0)
	for( _i = 0; _i < c_len; _i++ )
		c[_i] = c[_i] ^ _ctx->key->exp_data[_i];
	
#ifdef OAES_DEBUG
	if( _ctx->step_cb )
	{
		_ctx->step_cb( _ctx->key->exp_data, "k_sch", 1, NULL );
		_ctx->step_cb( c, "k_add", 1, NULL );
	}
#endif // OAES_DEBUG

	// for round = 1 step 1 to Nr1
	for( _i = 1; _i < _ctx->key->num_keys - 1; _i++ )
	{
		// SubBytes(state)
		for( _j = 0; _j < c_len; _j++ )
			oaes_sub_byte( c + _j );

#ifdef OAES_DEBUG
		if( _ctx->step_cb )
			_ctx->step_cb( c, "s_box", _i, NULL );
#endif // OAES_DEBUG

		// ShiftRows(state)
		oaes_shift_rows( c );
		
#ifdef OAES_DEBUG
		if( _ctx->step_cb )
			_ctx->step_cb( c, "s_row", _i, NULL );
#endif // OAES_DEBUG

		// MixColumns(state)
		oaes_mix_cols( c );
		oaes_mix_cols( c + 4 );
		oaes_mix_cols( c + 8 );
		oaes_mix_cols( c + 12 );
		
#ifdef OAES_DEBUG
		if( _ctx->step_cb )
			_ctx->step_cb( c, "m_col", _i, NULL );
#endif // OAES_DEBUG

		// AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])
		for( _j = 0; _j < c_len; _j++ )
			c[_j] = c[_j] ^
					_ctx->key->exp_data[_i * OAES_RKEY_LEN * OAES_COL_LEN + _j];

#ifdef OAES_DEBUG
	if( _ctx->step_cb )
	{
		_ctx->step_cb( _ctx->key->exp_data + _i * OAES_RKEY_LEN * OAES_COL_LEN,
				"k_sch", _i, NULL );
		_ctx->step_cb( c, "k_add", _i, NULL );
	}
#endif // OAES_DEBUG

	}
	
	// SubBytes(state)
	for( _i = 0; _i < c_len; _i++ )
		oaes_sub_byte( c + _i );
	
#ifdef OAES_DEBUG
	if( _ctx->step_cb )
		_ctx->step_cb( c, "s_box", _ctx->key->num_keys - 1, NULL );
#endif // OAES_DEBUG

	// ShiftRows(state)
	oaes_shift_rows( c );

#ifdef OAES_DEBUG
	if( _ctx->step_cb )
		_ctx->step_cb( c, "s_row", _ctx->key->num_keys - 1, NULL );
#endif // OAES_DEBUG

	// AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
	for( _i = 0; _i < c_len; _i++ )
		c[_i] = c[_i] ^ _ctx->key->exp_data[
				( _ctx->key->num_keys - 1 ) * OAES_RKEY_LEN * OAES_COL_LEN + _i ];

#ifdef OAES_DEBUG
	if( _ctx->step_cb )
	{
		_ctx->step_cb( _ctx->key->exp_data +
				( _ctx->key->num_keys - 1 ) * OAES_RKEY_LEN * OAES_COL_LEN,
				"k_sch", _ctx->key->num_keys - 1, NULL );
		_ctx->step_cb( c, "output", _ctx->key->num_keys - 1, NULL );
	}
#endif // OAES_DEBUG

	return OAES_RET_SUCCESS;
}

static OAES_RET oaes_decrypt_block(
		OAES_CTX * ctx, uint8_t * c, size_t c_len )
{
	size_t _i, _j;
	oaes_ctx * _ctx = (oaes_ctx *) ctx;
	
	if( NULL == _ctx )
		return OAES_RET_ARG1;
	
	if( NULL == c )
		return OAES_RET_ARG2;
	
	if( c_len != OAES_BLOCK_SIZE )
		return OAES_RET_ARG3;
	
	if( NULL == _ctx->key )
		return OAES_RET_NOKEY;
	
#ifdef OAES_DEBUG
	if( _ctx->step_cb )
		_ctx->step_cb( c, "iinput", _ctx->key->num_keys - 1, NULL );
#endif // OAES_DEBUG

	// AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
	for( _i = 0; _i < c_len; _i++ )
		c[_i] = c[_i] ^ _ctx->key->exp_data[
				( _ctx->key->num_keys - 1 ) * OAES_RKEY_LEN * OAES_COL_LEN + _i ];

#ifdef OAES_DEBUG
	if( _ctx->step_cb )
	{
		_ctx->step_cb( _ctx->key->exp_data +
				( _ctx->key->num_keys - 1 ) * OAES_RKEY_LEN * OAES_COL_LEN,
				"ik_sch", _ctx->key->num_keys - 1, NULL );
		_ctx->step_cb( c, "ik_add", _ctx->key->num_keys - 1, NULL );
	}
#endif // OAES_DEBUG

	for( _i = _ctx->key->num_keys - 2; _i > 0; _i-- )
	{
		// InvShiftRows(state)
		oaes_inv_shift_rows( c );

#ifdef OAES_DEBUG
	if( _ctx->step_cb )
		_ctx->step_cb( c, "is_row", _i, NULL );
#endif // OAES_DEBUG

		// InvSubBytes(state)
		for( _j = 0; _j < c_len; _j++ )
			oaes_inv_sub_byte( c + _j );
	
#ifdef OAES_DEBUG
	if( _ctx->step_cb )
		_ctx->step_cb( c, "is_box", _i, NULL );
#endif // OAES_DEBUG

		// AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])
		for( _j = 0; _j < c_len; _j++ )
			c[_j] = c[_j] ^
					_ctx->key->exp_data[_i * OAES_RKEY_LEN * OAES_COL_LEN + _j];
		
#ifdef OAES_DEBUG
	if( _ctx->step_cb )
	{
		_ctx->step_cb( _ctx->key->exp_data + _i * OAES_RKEY_LEN * OAES_COL_LEN,
				"ik_sch", _i, NULL );
		_ctx->step_cb( c, "ik_add", _i, NULL );
	}
#endif // OAES_DEBUG

		// InvMixColums(state)
		oaes_inv_mix_cols( c );
		oaes_inv_mix_cols( c + 4 );
		oaes_inv_mix_cols( c + 8 );
		oaes_inv_mix_cols( c + 12 );

#ifdef OAES_DEBUG
	if( _ctx->step_cb )
		_ctx->step_cb( c, "im_col", _i, NULL );
#endif // OAES_DEBUG

	}

	// InvShiftRows(state)
	oaes_inv_shift_rows( c );

#ifdef OAES_DEBUG
	if( _ctx->step_cb )
		_ctx->step_cb( c, "is_row", 1, NULL );
#endif // OAES_DEBUG

	// InvSubBytes(state)
	for( _i = 0; _i < c_len; _i++ )
		oaes_inv_sub_byte( c + _i );

#ifdef OAES_DEBUG
	if( _ctx->step_cb )
		_ctx->step_cb( c, "is_box", 1, NULL );
#endif // OAES_DEBUG

	// AddRoundKey(state, w[0, Nb-1])
	for( _i = 0; _i < c_len; _i++ )
		c[_i] = c[_i] ^ _ctx->key->exp_data[_i];
	
#ifdef OAES_DEBUG
	if( _ctx->step_cb )
	{
		_ctx->step_cb( _ctx->key->exp_data, "ik_sch", 1, NULL );
		_ctx->step_cb( c, "ioutput", 1, NULL );
	}
#endif // OAES_DEBUG

	return OAES_RET_SUCCESS;
}

OAES_RET oaes_encrypt( OAES_CTX * ctx,
		const uint8_t * m, size_t m_len, uint8_t * c, size_t * c_len )
{
	size_t _i, _j, _c_len_in, _c_data_len;
	size_t _pad_len = m_len % OAES_BLOCK_SIZE == 0 ?
			0 : OAES_BLOCK_SIZE - m_len % OAES_BLOCK_SIZE;
	oaes_ctx * _ctx = (oaes_ctx *) ctx;
	OAES_RET _rc = OAES_RET_SUCCESS;
	uint8_t _flags = _pad_len ? OAES_FLAG_PAD : 0;
	
	if( NULL == _ctx )
		return OAES_RET_ARG1;
	
	if( NULL == m )
		return OAES_RET_ARG2;
	
	if( NULL == c_len )
		return OAES_RET_ARG5;
	
	_c_len_in = *c_len;
	// data + pad
	_c_data_len = m_len + _pad_len;
	// header + iv + data + pad
	*c_len = 2 * OAES_BLOCK_SIZE + m_len + _pad_len;

	if( NULL == c )
		return OAES_RET_SUCCESS;
	
	if( _c_len_in < *c_len )
		return OAES_RET_BUF;
	
	if( NULL == _ctx->key )
		return OAES_RET_NOKEY;
	
	// fill with random data first
	for( _i = 0; _i < OAES_BLOCK_SIZE; _i++ )
		c[_i] = (uint8_t) OAES_RAND(_ctx->rctx);
	// header
	memcpy(c + 6, &_ctx->options, sizeof(_ctx->options));
	memcpy(c + 8, &_flags, sizeof(_flags));
	// iv
	memcpy(c + OAES_BLOCK_SIZE, _ctx->iv, OAES_BLOCK_SIZE );
	// data
	memcpy(c + 2 * OAES_BLOCK_SIZE, m, m_len );
	
	for( _i = 0; _i < _c_data_len; _i += OAES_BLOCK_SIZE )
	{
		uint8_t _block[OAES_BLOCK_SIZE];
		size_t _block_size = min( m_len - _i, OAES_BLOCK_SIZE );

		memcpy( _block, c + 2 * OAES_BLOCK_SIZE + _i, _block_size );
		
		// insert pad
		for( _j = 0; _j < OAES_BLOCK_SIZE - _block_size; _j++ )
			_block[ _block_size + _j ] = _j + 1;
	
		// CBC
		if( _ctx->options & OAES_OPTION_CBC )
		{
			for( _j = 0; _j < OAES_BLOCK_SIZE; _j++ )
				_block[_j] = _block[_j] ^ _ctx->iv[_j];
		}

		_rc = _rc ||
				oaes_encrypt_block( ctx, _block, OAES_BLOCK_SIZE );
		memcpy( c + 2 * OAES_BLOCK_SIZE + _i, _block, OAES_BLOCK_SIZE );
		
		if( _ctx->options & OAES_OPTION_CBC )
			memcpy( _ctx->iv, _block, OAES_BLOCK_SIZE );
	}
	
	return _rc;
}

OAES_RET oaes_decrypt( OAES_CTX * ctx,
		const uint8_t * c, size_t c_len, uint8_t * m, size_t * m_len )
{
	size_t _i, _j, _m_len_in;
	oaes_ctx * _ctx = (oaes_ctx *) ctx;
	OAES_RET _rc = OAES_RET_SUCCESS;
	uint8_t _iv[OAES_BLOCK_SIZE];
	uint8_t _flags;
	OAES_OPTION _options;
	
	if( NULL == ctx )
		return OAES_RET_ARG1;
	
	if( NULL == c )
		return OAES_RET_ARG2;
	
	if( c_len % OAES_BLOCK_SIZE )
		return OAES_RET_ARG3;
	
	if( NULL == m_len )
		return OAES_RET_ARG5;
	
	_m_len_in = *m_len;
	*m_len = c_len - 2 * OAES_BLOCK_SIZE;
	
	if( NULL == m )
		return OAES_RET_SUCCESS;
	
	if( _m_len_in < *m_len )
		return OAES_RET_BUF;
	
	if( NULL == _ctx->key )
		return OAES_RET_NOKEY;
	
	// options
	memcpy(&_options, c + 6, sizeof(_options));
	// validate that all options are valid
	if( _options & ~(
			  OAES_OPTION_ECB
			| OAES_OPTION_CBC
#ifdef OAES_DEBUG
			| OAES_OPTION_STEP_ON
			| OAES_OPTION_STEP_OFF
#endif // OAES_DEBUG
			) )
		return OAES_RET_HEADER;
	if( ( _options & OAES_OPTION_ECB ) &&
			( _options & OAES_OPTION_CBC ) )
		return OAES_RET_HEADER;
	if( _options == OAES_OPTION_NONE )
		return OAES_RET_HEADER;
	
	// flags
	memcpy(&_flags, c + 8, sizeof(_flags));
	// validate that all flags are valid
	if( _flags & ~(
			  OAES_FLAG_PAD
			) )
		return OAES_RET_HEADER;

	// iv
	memcpy( _iv, c + OAES_BLOCK_SIZE, OAES_BLOCK_SIZE);
	// data + pad
	memcpy( m, c + 2 * OAES_BLOCK_SIZE, *m_len );
	
	for( _i = 0; _i < *m_len; _i += OAES_BLOCK_SIZE )
	{
		if( ( _options & OAES_OPTION_CBC ) && _i > 0 )
			memcpy( _iv, c + OAES_BLOCK_SIZE + _i, OAES_BLOCK_SIZE );
		
		_rc = _rc ||
				oaes_decrypt_block( ctx, m + _i, min( *m_len - _i, OAES_BLOCK_SIZE ) );
		
		// CBC
		if( _options & OAES_OPTION_CBC )
		{
			for( _j = 0; _j < OAES_BLOCK_SIZE; _j++ )
				m[ _i + _j ] = m[ _i + _j ] ^ _iv[_j];
		}
	}
	
	// remove pad
	if( _flags & OAES_FLAG_PAD )
	{
		int _is_pad = 1;
		size_t _temp = (size_t) m[*m_len - 1];

		if( _temp  <= 0x00 || _temp > 0x0f )
			return OAES_RET_HEADER;
		for( _i = 0; _i < _temp; _i++ )
			if( m[*m_len - 1 - _i] != _temp - _i )
				_is_pad = 0;
		if( _is_pad )
		{
			memset( m + *m_len - _temp, 0, _temp );
			*m_len -= _temp;
		}
		else
			return OAES_RET_HEADER;
	}
	
	return OAES_RET_SUCCESS;
}
        moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/OpenAES/oaes_lib.h         0000664 0000000 0000000 00000011473 12563577644 0031756 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* 
 * ---------------------------------------------------------------------------
 * OpenAES License
 * ---------------------------------------------------------------------------
 * Copyright (c) 2013, Nabil S. Al Ramli, www.nalramli.com
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   - Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   - Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * ---------------------------------------------------------------------------
 */

#ifndef _OAES_LIB_H
#define _OAES_LIB_H

#include "oaes_common.h"

#ifdef __cplusplus 
extern "C" {
#endif

#ifdef _WIN32
#	ifdef OAES_SHARED
#		ifdef oaes_lib_EXPORTS
#			define OAES_API __declspec(dllexport)
#		else
#			define OAES_API __declspec(dllimport)
#		endif
#	else
#		define OAES_API
#	endif
#else
#	define OAES_API
#endif // WIN32

#define OAES_BLOCK_SIZE 16

typedef void OAES_CTX;

/*
 * oaes_set_option() takes one of these values for its [option] parameter
 * some options accept either an optional or a required [value] parameter
 */
// no option
#define OAES_OPTION_NONE 0
// enable ECB mode, disable CBC mode
#define OAES_OPTION_ECB 1
// enable CBC mode, disable ECB mode
// value is optional, may pass uint8_t iv[OAES_BLOCK_SIZE] to specify
// the value of the initialization vector, iv
#define OAES_OPTION_CBC 2

#ifdef OAES_DEBUG
typedef int ( * oaes_step_cb ) (
		const uint8_t state[OAES_BLOCK_SIZE],
		const char * step_name,
		int step_count,
		void * user_data );
// enable state stepping mode
// value is required, must pass oaes_step_cb to receive the state at each step
#define OAES_OPTION_STEP_ON 4
// disable state stepping mode
#define OAES_OPTION_STEP_OFF 8
#endif // OAES_DEBUG

typedef uint16_t OAES_OPTION;

/*
 * // usage:
 * 
 * OAES_CTX * ctx = oaes_alloc();
 * .
 * .
 * .
 * {
 *   oaes_gen_key_xxx( ctx );
 *   {
 *     oaes_key_export( ctx, _buf, &_buf_len );
 *     // or
 *     oaes_key_export_data( ctx, _buf, &_buf_len );\
 *   }
 * }
 * // or
 * {
 *   oaes_key_import( ctx, _buf, _buf_len );
 *   // or
 *   oaes_key_import_data( ctx, _buf, _buf_len );
 * }
 * .
 * .
 * .
 * oaes_encrypt( ctx, m, m_len, c, &c_len );
 * .
 * .
 * .
 * oaes_decrypt( ctx, c, c_len, m, &m_len );
 * .
 * .
 * .
 * oaes_free( &ctx );
 */

OAES_API OAES_CTX * oaes_alloc();

OAES_API OAES_RET oaes_free( OAES_CTX ** ctx );

OAES_API OAES_RET oaes_set_option( OAES_CTX * ctx,
		OAES_OPTION option, const void * value );

OAES_API OAES_RET oaes_key_gen_128( OAES_CTX * ctx );

OAES_API OAES_RET oaes_key_gen_192( OAES_CTX * ctx );

OAES_API OAES_RET oaes_key_gen_256( OAES_CTX * ctx );

// export key with header information
// set data == NULL to get the required data_len
OAES_API OAES_RET oaes_key_export( OAES_CTX * ctx,
		uint8_t * data, size_t * data_len );

// directly export the data from key
// set data == NULL to get the required data_len
OAES_API OAES_RET oaes_key_export_data( OAES_CTX * ctx,
		uint8_t * data, size_t * data_len );

// import key with header information
OAES_API OAES_RET oaes_key_import( OAES_CTX * ctx,
		const uint8_t * data, size_t data_len );

// directly import data into key
OAES_API OAES_RET oaes_key_import_data( OAES_CTX * ctx,
		const uint8_t * data, size_t data_len );

// set c == NULL to get the required c_len
OAES_API OAES_RET oaes_encrypt( OAES_CTX * ctx,
		const uint8_t * m, size_t m_len, uint8_t * c, size_t * c_len );

// set m == NULL to get the required m_len
OAES_API OAES_RET oaes_decrypt( OAES_CTX * ctx,
		const uint8_t * c, size_t c_len, uint8_t * m, size_t * m_len );

// set buf == NULL to get the required buf_len
OAES_API OAES_RET oaes_sprintf(
		char * buf, size_t * buf_len, const uint8_t * data, size_t data_len );

#ifdef __cplusplus 
}
#endif

#endif // _OAES_LIB_H
                                                                                                                                                                                                     moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/Platform.c                 0000664 0000000 0000000 00000014222 12563577644 0030521 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include "PlatformThreads.h"
#include "Platform.h"

int initializePlatformSockets(void);
void cleanupPlatformSockets(void);

#if defined(LC_WINDOWS)
void LimelogWindows(char* Format, ...) {
	va_list va;
	char buffer[1024];

	va_start(va, Format);
	vsprintf(buffer, Format, va);
	va_end(va);

	OutputDebugStringA(buffer);
}
#endif

#if defined(LC_WINDOWS)
PLT_MUTEX thread_list_lock;
PLT_THREAD *thread_head;

DWORD WINAPI ThreadProc(LPVOID lpParameter) {
	struct thread_context *ctx = (struct thread_context *)lpParameter;

	ctx->entry(ctx->context);

	free(ctx);

	return 0;
}
#else
void* ThreadProc(void* context) {
    struct thread_context *ctx = (struct thread_context *)context;

    ctx->entry(ctx->context);
    
	free(ctx);
    
	return NULL;
}
#endif

void PltSleepMs(int ms) {
#if defined(LC_WINDOWS)
	WaitForSingleObjectEx(GetCurrentThread(), ms, FALSE);
#else
    useconds_t usecs = ms * 1000;
    usleep(usecs);
#endif
}

int PltCreateMutex(PLT_MUTEX *mutex) {
#if defined(LC_WINDOWS)
	*mutex = CreateMutexEx(NULL, NULL, 0, MUTEX_ALL_ACCESS);
	if (!*mutex) {
		return -1;
	}
	return 0;
#else
    return pthread_mutex_init(mutex, NULL);
#endif
}

void PltDeleteMutex(PLT_MUTEX *mutex) {
#if defined(LC_WINDOWS)
	CloseHandle(*mutex);
#else
    pthread_mutex_destroy(mutex);
#endif
}

void PltLockMutex(PLT_MUTEX *mutex) {
#if defined(LC_WINDOWS)
	int err;
	err = WaitForSingleObjectEx(*mutex, INFINITE, FALSE);
	if (err != WAIT_OBJECT_0) {
		LC_ASSERT(FALSE);
	}
#else
    pthread_mutex_lock(mutex);
#endif
}

void PltUnlockMutex(PLT_MUTEX *mutex) {
#if defined(LC_WINDOWS)
	ReleaseMutex(*mutex);
#else
    pthread_mutex_unlock(mutex);
#endif
}

void PltJoinThread(PLT_THREAD *thread) {
#if defined(LC_WINDOWS)
	WaitForSingleObjectEx(thread->handle, INFINITE, FALSE);
#else
    pthread_join(*thread, NULL);
#endif
}

void PltCloseThread(PLT_THREAD *thread) {
#if defined(LC_WINDOWS)
	PLT_THREAD *current_thread;
	
	PltLockMutex(&thread_list_lock);

	if (thread_head == thread)
	{
		// Remove the thread from the head
		thread_head = thread_head->next;
	}
	else
	{
		// Find the thread in the list
		current_thread = thread_head;
		while (current_thread != NULL) {
			if (current_thread->next == thread) {
				break;
			}

			current_thread = current_thread->next;
		}

		LC_ASSERT(current_thread != NULL);

		// Unlink this thread
		current_thread->next = thread->next;
	}

	PltUnlockMutex(&thread_list_lock);

	CloseHandle(thread->termRequested);
	CloseHandle(thread->handle);
#else
#endif
}

int PltIsThreadInterrupted(PLT_THREAD *thread) {
#if defined(LC_WINDOWS)
	return thread->cancelled;
#else
	// The thread will die here if a cancellation was requested
	pthread_testcancel();
	return 0;
#endif
}

void PltInterruptThread(PLT_THREAD *thread) {
#if defined(LC_WINDOWS)
	thread->cancelled = 1;
	SetEvent(thread->termRequested);
#else
	pthread_cancel(*thread);
#endif
}

int PltCreateThread(ThreadEntry entry, void* context, PLT_THREAD *thread) {
	struct thread_context *ctx;
	int err;

	ctx = (struct thread_context *)malloc(sizeof(*ctx));
	if (ctx == NULL) {
		return -1;
	}

	ctx->entry = entry;
	ctx->context = context;

#if defined(LC_WINDOWS)
	{
		thread->termRequested = CreateEventEx(NULL, NULL, CREATE_EVENT_MANUAL_RESET, EVENT_ALL_ACCESS);
		if (thread->termRequested == NULL) {
			free(ctx);
			return -1;
		}

		thread->cancelled = 0;

		thread->handle = CreateThread(NULL, 0, ThreadProc, ctx, CREATE_SUSPENDED, &thread->tid);
		if (thread->handle == NULL) {
			CloseHandle(thread->termRequested);
			free(ctx);
			return -1;
		}
		else {
			// Add this thread to the thread list
			PltLockMutex(&thread_list_lock);
			thread->next = thread_head;
			thread_head = thread;
			PltUnlockMutex(&thread_list_lock);

			// Now the thread can run
			ResumeThread(thread->handle);

			err = 0;
		}

	}
#else
    {
        err = pthread_create(thread, NULL, ThreadProc, ctx);
        if (err != 0) {
            free(ctx);
        }
    }
#endif

	return err;
}

int PltCreateEvent(PLT_EVENT *event) {
#if defined(LC_WINDOWS)
	*event = CreateEventEx(NULL, NULL, CREATE_EVENT_MANUAL_RESET, EVENT_ALL_ACCESS);
	if (!*event) {
		return -1;
	}

	return 0;
#else
    pthread_mutex_init(&event->mutex, NULL);
    pthread_cond_init(&event->cond, NULL);
    event->signalled = 0;
    return 0;
#endif
}

void PltCloseEvent(PLT_EVENT *event) {
#if defined(LC_WINDOWS)
	CloseHandle(*event);
#else
    pthread_mutex_destroy(&event->mutex);
    pthread_cond_destroy(&event->cond);
#endif
}

void PltSetEvent(PLT_EVENT *event) {
#if defined(LC_WINDOWS)
	SetEvent(*event);
#else
    event->signalled = 1;
    pthread_cond_broadcast(&event->cond);
#endif
}

void PltClearEvent(PLT_EVENT *event) {
#if defined(LC_WINDOWS)
	ResetEvent(*event);
#else
    event->signalled = 0;
#endif
}

int PltWaitForEvent(PLT_EVENT *event) {
#if defined(LC_WINDOWS)
	DWORD error;
	PLT_THREAD *current_thread;
	HANDLE objects[2];

	PltLockMutex(&thread_list_lock);
	current_thread = thread_head;
	while (current_thread != NULL) {
		if (current_thread->tid == GetCurrentThreadId()) {
			break;
		}

		current_thread = current_thread->next;
	}
	PltUnlockMutex(&thread_list_lock);

	LC_ASSERT(current_thread != NULL);

	objects[0] = *event;
	objects[1] = current_thread->termRequested;
	error = WaitForMultipleObjectsEx(2, objects, FALSE, INFINITE, FALSE);
	if (error == WAIT_OBJECT_0) {
		return PLT_WAIT_SUCCESS;
	}
	else if (error == WAIT_OBJECT_0 + 1) {
		return PLT_WAIT_INTERRUPTED;
	}
	else {
		LC_ASSERT(0);
		return -1;
	}
#else
	pthread_mutex_lock(&event->mutex);
    while (!event->signalled) {
        pthread_cond_wait(&event->cond, &event->mutex);
    }
	pthread_mutex_unlock(&event->mutex);
	return PLT_WAIT_SUCCESS;
#endif
}

uint64_t PltGetMillis(void) {
#if defined(LC_WINDOWS)
	return GetTickCount64();
#else
	struct timeval tv;

	gettimeofday(&tv, NULL);

	return (tv.tv_sec * 1000) + (tv.tv_usec / 1000);
#endif
}

int initializePlatform(void) {
	int err;

	err = initializePlatformSockets();
	if (err != 0) {
		return err;
	}

#if defined(LC_WINDOWS)
	return PltCreateMutex(&thread_list_lock);
#else
	return 0;
#endif
}

void cleanupPlatform(void) {
	cleanupPlatformSockets();

#if defined(LC_WINDOWS)
	LC_ASSERT(thread_head == NULL);

	PltDeleteMutex(&thread_list_lock);
#else
#endif
}                                                                                                                                                                                                                                                                                                                                                                              moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/Platform.h                 0000664 0000000 0000000 00000002004 12563577644 0030521 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #pragma once

#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <Winsock2.h>
#include <ws2tcpip.h>
#else
#include <unistd.h>
#include <pthread.h>
#include <sys/time.h>
#include <arpa/inet.h>
#endif

#ifdef _WIN32
# define LC_WINDOWS
#else
# define LC_POSIX
# if defined(__APPLE__)
#  define LC_DARWIN
# endif
#endif

#include <stdio.h>
#include "Limelight.h"

#if defined(LC_WINDOWS)
void LimelogWindows(char* Format, ...);
#define Limelog(s, ...) \
    LimelogWindows(s, ##__VA_ARGS__)
#else
#define Limelog(s, ...) \
    fprintf(stderr, s, ##__VA_ARGS__)
#endif

#if defined(LC_WINDOWS)
 #include <crtdbg.h>
 #ifdef LC_DEBUG
  #define LC_ASSERT(x) __analysis_assume(x); \
                       _ASSERTE(x)
 #else
  #define LC_ASSERT(x)
 #endif
#else
 #ifndef LC_DEBUG
  #define NDEBUG
 #endif
 #include <assert.h>
 #define LC_ASSERT(x) assert(x)
#endif

int initializePlatform(void);
void cleanupPlatform(void);

uint64_t PltGetMillis(void);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/PlatformSockets.c          0000664 0000000 0000000 00000006447 12563577644 0032067 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include "PlatformSockets.h"
#include "Limelight-internal.h"

void addrToUrlSafeString(struct sockaddr_storage *addr, char* string)
{
	char addrstr[INET6_ADDRSTRLEN];

    if (addr->ss_family == AF_INET6) {
        struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)addr;
        inet_ntop(addr->ss_family, &sin6->sin6_addr, addrstr, sizeof(addrstr));
        
        // IPv6 addresses need to be enclosed in brackets for URLs
        sprintf(string, "[%s]", addrstr);
    }
    else {
        struct sockaddr_in *sin = (struct sockaddr_in *)addr;
		inet_ntop(addr->ss_family, &sin->sin_addr, addrstr, sizeof(addrstr));
        
        // IPv4 addresses are returned without changes
        sprintf(string, "%s", addrstr);
    }
}

SOCKET bindUdpSocket(int addrfamily, int bufferSize) {
	SOCKET s;
    struct sockaddr_storage addr;
#ifdef LC_DARWIN
	int val;
#endif
	int err;

    LC_ASSERT(addrfamily == AF_INET || addrfamily == AF_INET6);
    
	s = socket(addrfamily, SOCK_DGRAM, IPPROTO_UDP);
	if (s == INVALID_SOCKET) {
        Limelog("socket() failed: %d\n", (int)LastSocketError());
		return INVALID_SOCKET;
	}

	memset(&addr, 0, sizeof(addr));
    addr.ss_family = addrfamily;
	if (bind(s, (struct sockaddr*) &addr,
             addrfamily == AF_INET ?
                sizeof(struct sockaddr_in) :
                sizeof(struct sockaddr_in6)) == SOCKET_ERROR) {
		err = LastSocketError();
        Limelog("bind() failed: %d\n", err);
		closesocket(s);
		SetLastSocketError(err);
		return INVALID_SOCKET;
	}
    
#ifdef LC_DARWIN
    // Disable SIGPIPE on iOS
    val = 1;
    setsockopt(s, SOL_SOCKET, SO_NOSIGPIPE, (char* )&val, sizeof(val));
#endif

	setsockopt(s, SOL_SOCKET, SO_RCVBUF, (char*) &bufferSize, sizeof(bufferSize));

	return s;
}

SOCKET connectTcpSocket(struct sockaddr_storage *dstaddr, SOCKADDR_LEN addrlen, unsigned short port) {
	SOCKET s;
    struct sockaddr_in6 addr;
	int err;
#ifdef LC_DARWIN
    int val;
#endif

	s = socket(dstaddr->ss_family, SOCK_STREAM, IPPROTO_TCP);
	if (s == INVALID_SOCKET) {
        Limelog("socket() failed: %d\n", (int)LastSocketError());
		return INVALID_SOCKET;
	}
    
#ifdef LC_DARWIN
    // Disable SIGPIPE on iOS
    val = 1;
    setsockopt(s, SOL_SOCKET, SO_NOSIGPIPE, (char* )&val, sizeof(val));
#endif

    memcpy(&addr, dstaddr, sizeof(addr));
	addr.sin6_port = htons(port);
	if (connect(s, (struct sockaddr*) &addr, addrlen) == SOCKET_ERROR) {
		err = LastSocketError();
        Limelog("connect() failed: %d\n", err);
		closesocket(s);
		SetLastSocketError(err);
		return INVALID_SOCKET;
	}

	return s;
}

int enableNoDelay(SOCKET s) {
	int err;
	int val;

	val = 1;
	err = setsockopt(s, IPPROTO_TCP, TCP_NODELAY, (char*)&val, sizeof(val));
	if (err == SOCKET_ERROR) {
		return LastSocketError();
	}

	return 0;
}

int initializePlatformSockets(void) {
#if defined(LC_WINDOWS)
	WSADATA data;
	return WSAStartup(MAKEWORD(2, 0), &data);
#elif defined(LC_POSIX)
    // Disable SIGPIPE signals to avoid us getting
    // killed when a socket gets an EPIPE error
    struct sigaction sa;
    sigemptyset(&sa.sa_mask);
    sa.sa_handler = SIG_IGN;
    sa.sa_flags = 0;
    if (sigaction(SIGPIPE, &sa, 0) == -1) {
        perror("sigaction");
        return -1;
    }
    return 0;
#else
	return 0;
#endif
}

void cleanupPlatformSockets(void) {
#if defined(LC_WINDOWS)
	WSACleanup();
#else
#endif
}
                                                                                                                                                                                                                         moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/PlatformSockets.h          0000664 0000000 0000000 00000002151 12563577644 0032060 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #pragma once

#include "Limelight.h"
#include "Platform.h"

#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#define SetLastSocketError(x) WSASetLastError(x)
#define LastSocketError() WSAGetLastError()

typedef int SOCK_RET;
typedef int SOCKADDR_LEN;

#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/tcp.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <errno.h>
#include <signal.h>

#define LastSocketError() errno
#define SetLastSocketError(x) errno = x
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define closesocket(x) close(x)

typedef int SOCKET;
typedef ssize_t SOCK_RET;
typedef socklen_t SOCKADDR_LEN;
#endif

#define LastSocketFail() ((LastSocketError() != 0) ? LastSocketError() : -1)

// IPv6 addresses have 2 extra characters for URL escaping
#define URLSAFESTRING_LEN INET6_ADDRSTRLEN+2
void addrToUrlSafeString(struct sockaddr_storage *addr, char* string);

SOCKET connectTcpSocket(struct sockaddr_storage *dstaddr, SOCKADDR_LEN addrlen, unsigned short port);
SOCKET bindUdpSocket(int addrfamily, int bufferSize);
int enableNoDelay(SOCKET s);                                                                                                                                                                                                                                                                                                                                                                                                                       moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/PlatformThreads.h          0000664 0000000 0000000 00000002466 12563577644 0032050 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #pragma once

#include "Limelight.h"
#include "Platform.h"

typedef void (*ThreadEntry)(void *context);

struct thread_context {
	ThreadEntry entry;
	void* context;
};

#if defined(LC_WINDOWS)
typedef struct _PLT_THREAD {
	HANDLE handle;
	int cancelled;
	DWORD tid;
	HANDLE termRequested;

	struct _PLT_THREAD *next;
} PLT_THREAD;
typedef HANDLE PLT_MUTEX;
typedef HANDLE PLT_EVENT;
#elif defined (LC_POSIX)
typedef pthread_t PLT_THREAD;
typedef pthread_mutex_t PLT_MUTEX;
typedef struct _PLT_EVENT {
    pthread_mutex_t mutex;
    pthread_cond_t cond;
    int signalled;
} PLT_EVENT;
#else
#error Unsupported platform
#endif

int PltCreateMutex(PLT_MUTEX *mutex);
void PltDeleteMutex(PLT_MUTEX *mutex);
void PltLockMutex(PLT_MUTEX *mutex);
void PltUnlockMutex(PLT_MUTEX *mutex);

int PltCreateThread(ThreadEntry entry, void* context, PLT_THREAD *thread);
void PltCloseThread(PLT_THREAD *thread);
void PltInterruptThread(PLT_THREAD *thread);
int PltIsThreadInterrupted(PLT_THREAD *thread);
void PltJoinThread(PLT_THREAD *thread);

int PltCreateEvent(PLT_EVENT *event);
void PltCloseEvent(PLT_EVENT *event);
void PltSetEvent(PLT_EVENT *event);
void PltClearEvent(PLT_EVENT *event);
int PltWaitForEvent(PLT_EVENT *event);

void PltRunThreadProc(void);

#define PLT_WAIT_SUCCESS 0
#define PLT_WAIT_INTERRUPTED 1

void PltSleepMs(int ms);                                                                                                                                                                                                          moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/RtpReorderQueue.c          0000664 0000000 0000000 00000016071 12563577644 0032036 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include "Limelight-internal.h"
#include "RtpReorderQueue.h"

void RtpqInitializeQueue(PRTP_REORDER_QUEUE queue, int maxSize, int maxQueueTimeMs) {
	queue->maxSize = maxSize;
	queue->maxQueueTimeMs = maxQueueTimeMs;
	queue->queueHead = NULL;
	queue->queueTail = NULL;
	queue->nextRtpSequenceNumber = UINT16_MAX;
	queue->oldestQueuedTimeMs = UINT64_MAX;
	queue->oldestQueuedEntry = NULL;
}

void RtpqCleanupQueue(PRTP_REORDER_QUEUE queue) {
	while (queue->queueHead != NULL) {
		PRTP_QUEUE_ENTRY entry = queue->queueHead;
		queue->queueHead = entry->next;
		free(entry->packet);
	}
}

// newEntry is contained within the packet buffer so we free the whole entry by freeing entry->packet
static int queuePacket(PRTP_REORDER_QUEUE queue, PRTP_QUEUE_ENTRY newEntry, int head, PRTP_PACKET packet) {
	if (queue->nextRtpSequenceNumber != UINT16_MAX) {
		PRTP_QUEUE_ENTRY entry;

		// Don't queue packets we're already ahead of
		if (isBeforeSignedInt(packet->sequenceNumber, queue->nextRtpSequenceNumber, 0)) {
			return 0;
		}

		// Don't queue duplicates either
		entry = queue->queueHead;
		while (entry != NULL) {
			if (entry->packet->sequenceNumber == packet->sequenceNumber) {
				return 0;
			}

			entry = entry->next;
		}
	}

	newEntry->packet = packet;
	newEntry->queueTimeMs = PltGetMillis();
	newEntry->prev = NULL;
	newEntry->next = NULL;

	if (queue->oldestQueuedTimeMs == UINT64_MAX) {
		queue->oldestQueuedTimeMs = newEntry->queueTimeMs;
        queue->oldestQueuedEntry = newEntry;
	}

	if (queue->queueHead == NULL) {
		LC_ASSERT(queue->queueSize == 0);
		queue->queueHead = queue->queueTail = newEntry;
	}
	else if (head) {
		LC_ASSERT(queue->queueSize > 0);
		PRTP_QUEUE_ENTRY oldHead = queue->queueHead;
		newEntry->next = oldHead;
		LC_ASSERT(oldHead->prev == NULL);
		oldHead->prev = newEntry;
		queue->queueHead = newEntry;
	}
	else {
		LC_ASSERT(queue->queueSize > 0);
		PRTP_QUEUE_ENTRY oldTail = queue->queueTail;
		newEntry->prev = oldTail;
		LC_ASSERT(oldTail->next == NULL);
		oldTail->next = newEntry;
		queue->queueTail = newEntry;
	}
	queue->queueSize++;

	return 1;
}

static void updateOldestQueued(PRTP_REORDER_QUEUE queue) {
	PRTP_QUEUE_ENTRY entry;

	queue->oldestQueuedTimeMs = UINT64_MAX;
	queue->oldestQueuedEntry = NULL;

	entry = queue->queueHead;
	while (entry != NULL) {
		if (entry->queueTimeMs < queue->oldestQueuedTimeMs) {
			queue->oldestQueuedEntry = entry;
			queue->oldestQueuedTimeMs = entry->queueTimeMs;
		}

		entry = entry->next;
	}
}

static PRTP_QUEUE_ENTRY getEntryByLowestSeq(PRTP_REORDER_QUEUE queue) {
	PRTP_QUEUE_ENTRY lowestSeqEntry, entry;
	
	lowestSeqEntry = queue->queueHead;
	entry = queue->queueHead;
	while (entry != NULL) {
		if (isBeforeSignedInt(entry->packet->sequenceNumber, lowestSeqEntry->packet->sequenceNumber, 1)) {
			lowestSeqEntry = entry;
		}

		entry = entry->next;
	}

	// Remember the updated lowest sequence number
	if (lowestSeqEntry != NULL) {
		queue->nextRtpSequenceNumber = lowestSeqEntry->packet->sequenceNumber;
	}

	return lowestSeqEntry;
}

static void removeEntry(PRTP_REORDER_QUEUE queue, PRTP_QUEUE_ENTRY entry) {
	LC_ASSERT(entry != NULL);
	LC_ASSERT(queue->queueSize > 0);
	LC_ASSERT(queue->queueHead != NULL);
	LC_ASSERT(queue->queueTail != NULL);

	if (queue->queueHead == entry) {
		queue->queueHead = entry->next;
	}
	if (queue->queueTail == entry) {
		queue->queueTail = entry->prev;
	}

	if (entry->prev != NULL) {
		entry->prev->next = entry->next;
	}
	if (entry->next != NULL) {
		entry->next->prev = entry->prev;
	}
	queue->queueSize--;
}

static PRTP_QUEUE_ENTRY validateQueueConstraints(PRTP_REORDER_QUEUE queue) {
	int needsUpdate = 0;

	// Empty queue is fine
	if (queue->queueHead == NULL) {
		return NULL;
	}

	// Check that the queue's time constraint is satisfied
	if (PltGetMillis() - queue->oldestQueuedTimeMs > queue->maxQueueTimeMs) {
		Limelog("Discarding RTP packet queued for too long\n");
		removeEntry(queue, queue->oldestQueuedEntry);
		free(queue->oldestQueuedEntry->packet);
		needsUpdate = 1;
	}

	// Check that the queue's size constraint is satisfied
	if (!needsUpdate && queue->queueSize == queue->maxSize) {
		Limelog("Discarding RTP packet after queue overgrowth\n");
		removeEntry(queue, queue->oldestQueuedEntry);
		free(queue->oldestQueuedEntry->packet);
		needsUpdate = 1;
	}

	if (needsUpdate) {
		// Recalculate the oldest entry if needed
		updateOldestQueued(queue);

		// Return the lowest seq queued
		return getEntryByLowestSeq(queue);
	}
	else {
		return NULL;
	}
}

int RtpqAddPacket(PRTP_REORDER_QUEUE queue, PRTP_PACKET packet, PRTP_QUEUE_ENTRY packetEntry) {
	if (queue->nextRtpSequenceNumber != UINT16_MAX &&
		isBeforeSignedInt(packet->sequenceNumber, queue->nextRtpSequenceNumber, 0)) {
		// Reject packets behind our current sequence number
		return RTPQ_RET_REJECTED;
	}

	if (queue->queueHead == NULL) {
		// Return immediately for an exact match with an empty queue
		if (queue->nextRtpSequenceNumber == UINT16_MAX ||
			packet->sequenceNumber == queue->nextRtpSequenceNumber) {
			queue->nextRtpSequenceNumber = packet->sequenceNumber + 1;
			return RTPQ_RET_HANDLE_IMMEDIATELY;
		}
		else {
			// Queue is empty currently so we'll put this packet on there
			if (!queuePacket(queue, packetEntry, 0, packet)) {
				return RTPQ_RET_REJECTED;
			}
			else {
				return RTPQ_RET_QUEUED_NOTHING_READY;
			}
		}
	}
	else {
		PRTP_QUEUE_ENTRY lowestEntry;

		// Validate that the queue remains within our contraints
		// and get the lowest element
		lowestEntry = validateQueueConstraints(queue);

		// If the queue is now empty after validating queue constraints,
		// this packet can be returned immediately
		if (lowestEntry == NULL && queue->queueHead == NULL) {
			queue->nextRtpSequenceNumber = packet->sequenceNumber + 1;
			return RTPQ_RET_HANDLE_IMMEDIATELY;
		}

		// Queue has data inside, so we need to see where this packet fits
		if (packet->sequenceNumber == queue->nextRtpSequenceNumber) {
			// It fits in a hole where we need a packet, now we have some ready
			if (!queuePacket(queue, packetEntry, 0, packet)) {
				return RTPQ_RET_REJECTED;
			}
			else {
				return RTPQ_RET_QUEUED_PACKETS_READY;
			}
		}
		else {
			if (!queuePacket(queue, packetEntry, 0, packet)) {
				return RTPQ_RET_REJECTED;
			}
			else {
				// Constraint validation may have changed the oldest packet to one that
				// matches the next sequence number 
				return (lowestEntry != NULL) ? RTPQ_RET_QUEUED_PACKETS_READY :
					RTPQ_RET_QUEUED_NOTHING_READY;
			}
		}
	}
}

PRTP_PACKET RtpqGetQueuedPacket(PRTP_REORDER_QUEUE queue) {
	PRTP_QUEUE_ENTRY queuedEntry, entry;

	// Find the next queued packet
	queuedEntry = NULL;
	entry = queue->queueHead;
	while (entry != NULL) {
		if (entry->packet->sequenceNumber == queue->nextRtpSequenceNumber) {
			queue->nextRtpSequenceNumber++;
			queuedEntry = entry;
			removeEntry(queue, entry);
			break;
		}

		entry = entry->next;
	}

	// Bail if we found nothing
	if (queuedEntry == NULL) {
		// Update the oldest queued packet time
		updateOldestQueued(queue);

		return NULL;
	}

	// We don't update the oldest queued entry here, because we know
	// the caller will call again until it receives null

	return queuedEntry->packet;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                       moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/RtpReorderQueue.h          0000664 0000000 0000000 00000002011 12563577644 0032030 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #pragma once

#include "Video.h"

#define RTPQ_DEFAULT_MAX_SIZE   16
#define RTPQ_DEFAULT_QUEUE_TIME 40

typedef struct _RTP_QUEUE_ENTRY {
	PRTP_PACKET packet;

	uint64_t queueTimeMs;

	struct _RTP_QUEUE_ENTRY *next;
	struct _RTP_QUEUE_ENTRY *prev;
} RTP_QUEUE_ENTRY, *PRTP_QUEUE_ENTRY;

typedef struct _RTP_REORDER_QUEUE {
	int maxSize;
	int maxQueueTimeMs;

	PRTP_QUEUE_ENTRY queueHead;
	PRTP_QUEUE_ENTRY queueTail;
	int queueSize;

	unsigned short nextRtpSequenceNumber;

	uint64_t oldestQueuedTimeMs;
	PRTP_QUEUE_ENTRY oldestQueuedEntry;
} RTP_REORDER_QUEUE, *PRTP_REORDER_QUEUE;

#define RTPQ_RET_HANDLE_IMMEDIATELY   0
#define RTPQ_RET_QUEUED_NOTHING_READY 1
#define RTPQ_RET_QUEUED_PACKETS_READY 2
#define RTPQ_RET_REJECTED             3

void RtpqInitializeQueue(PRTP_REORDER_QUEUE queue, int maxSize, int maxQueueTimeMs);
void RtpqCleanupQueue(PRTP_REORDER_QUEUE queue);
int RtpqAddPacket(PRTP_REORDER_QUEUE queue, PRTP_PACKET packet, PRTP_QUEUE_ENTRY packetEntry);
PRTP_PACKET RtpqGetQueuedPacket(PRTP_REORDER_QUEUE queue);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/Rtsp.h                     0000664 0000000 0000000 00000003515 12563577644 0027675 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define TYPE_REQUEST 0
#define TYPE_RESPONSE 1

#define TOKEN_OPTION 0

#define RTSP_ERROR_SUCCESS 0
#define RTSP_ERROR_NO_MEMORY -1
#define RTSP_ERROR_MALFORMED -2

#define SEQ_INVALID -1

#define FLAG_ALLOCATED_OPTION_FIELDS 0x1
#define FLAG_ALLOCATED_MESSAGE_BUFFER 0x2
#define FLAG_ALLOCATED_OPTION_ITEMS 0x4
#define FLAG_ALLOCATED_PAYLOAD 0x8

/* Linked List to store the options */
typedef struct _OPTION_ITEM {
	char flags;
	char *option;
	char *content;
	struct _OPTION_ITEM *next;
} OPTION_ITEM, *POPTION_ITEM;

/* RTSP Message *
* In this implementation, a flag indicates the message type:
* TYPE_REQUEST = 0
* TYPE_RESPONSE = 1 */
typedef struct _RTSP_MESSAGE {
	char type;
	char flags;
	int sequenceNumber;
	char *protocol;
	POPTION_ITEM options;
	char *payload;
	int payloadLength;

	char* messageBuffer;

	union {
		struct {
			/* Request fields */
			char *command;
			char *target;
		} request;
		struct {
			/* Response fields */
			char *statusString;
			int statusCode;
		} response;
	} message;
} RTSP_MESSAGE, *PRTSP_MESSAGE;

int parseRtspMessage(PRTSP_MESSAGE msg, char *rtspMessage, int length);
void freeMessage(PRTSP_MESSAGE msg);
void createRtspResponse(PRTSP_MESSAGE msg, char* messageBuffer, int flags, char *protocol, int statusCode, char *statusString, int sequenceNumber, POPTION_ITEM optionsHead, char *payload, int payloadLength);
void createRtspRequest(PRTSP_MESSAGE msg, char* messageBuffer, int flags, char *command, char *target, char *protocol, int sequenceNumber, POPTION_ITEM optionsHead, char *payload, int payloadLength);
char *getOptionContent(POPTION_ITEM optionsHead, char *option);
void insertOption(POPTION_ITEM *optionsHead, POPTION_ITEM opt);
void freeOptionList(POPTION_ITEM optionsHead);
char *serializeRtspMessage(PRTSP_MESSAGE msg, int *serializedLength);                                                                                                                                                                                   moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/RtspConnection.c           0000664 0000000 0000000 00000023405 12563577644 0031710 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include "Limelight-internal.h"
#include "Rtsp.h"

#define RTSP_MAX_RESP_SIZE 16384

static SOCKET sock = INVALID_SOCKET;
static int currentSeqNumber;
static char rtspTargetUrl[256];
static char sessionIdString[16];
static int hasSessionId;
static char responseBuffer[RTSP_MAX_RESP_SIZE];
static int rtspClientVersion;

/* Create RTSP Option */
static POPTION_ITEM createOptionItem(char* option, char* content)
{
	POPTION_ITEM item = malloc(sizeof(*item));
	if (item == NULL) {
		return NULL;
	}

	item->option = malloc(strlen(option) + 1);
	if (item->option == NULL) {
		free(item);
		return NULL;
	}

	strcpy(item->option, option);

	item->content = malloc(strlen(content) + 1);
	if (item->content == NULL) {
		free(item->option);
		free(item);
		return NULL;
	}

	strcpy(item->content, content);

	item->next = NULL;
	item->flags = FLAG_ALLOCATED_OPTION_FIELDS;

	return item;
}

/* Add an option to the RTSP Message */
static int addOption(PRTSP_MESSAGE msg, char* option, char* content)
{
	POPTION_ITEM item = createOptionItem(option, content);
	if (item == NULL) {
		return 0;
	}

	insertOption(&msg->options, item);
	msg->flags |= FLAG_ALLOCATED_OPTION_ITEMS;

	return 1;
}

/* Create an RTSP Request */
static int initializeRtspRequest(PRTSP_MESSAGE msg, char* command, char* target)
{
	char sequenceNumberStr[16];
    char clientVersionStr[16];

	// FIXME: Hacked CSeq attribute due to RTSP parser bug
	createRtspRequest(msg, NULL, 0, command, target, "RTSP/1.0",
		0, NULL, NULL, 0);
	
	sprintf(sequenceNumberStr, "%d", currentSeqNumber++);
    sprintf(clientVersionStr, "%d", rtspClientVersion);
	if (!addOption(msg, "CSeq", sequenceNumberStr) ||
		!addOption(msg, "X-GS-ClientVersion", clientVersionStr)) {
		freeMessage(msg);
		return 0;
	}

	return 1;
}

/* Send RTSP message and get response */
static int transactRtspMessage(PRTSP_MESSAGE request, PRTSP_MESSAGE response, int* error) {
    SOCK_RET err;
    int ret = 0;
	int offset;
	char* serializedMessage = NULL;
	int messageLen;
    
    *error = -1;

	sock = connectTcpSocket(&RemoteAddr, RemoteAddrLen, 48010);
	if (sock == INVALID_SOCKET) {
        *error = LastSocketError();
		return ret;
	}
	enableNoDelay(sock);

	serializedMessage = serializeRtspMessage(request, &messageLen);
	if (serializedMessage == NULL) {
		closesocket(sock);
        sock = INVALID_SOCKET;
		return ret;
	}

	// Send our message
	err = send(sock, serializedMessage, messageLen, 0);
	if (err == SOCKET_ERROR) {
        *error = LastSocketError();
        Limelog("Failed to send RTSP message: %d\n", *error);
		goto Exit;
	}

	// Read the response until the server closes the connection
	offset = 0;
	for (;;) {
		err = recv(sock, &responseBuffer[offset], RTSP_MAX_RESP_SIZE - offset, 0);
		if (err <= 0) {
			// Done reading
			break;
		}
		offset += err;

		// Warn if the RTSP message is too big
		if (offset == RTSP_MAX_RESP_SIZE) {
			Limelog("RTSP message too long\n");
			goto Exit;
		}
	}

	if (parseRtspMessage(response, responseBuffer, offset) == RTSP_ERROR_SUCCESS) {
		// Successfully parsed response
		ret = 1;
	}
	else {
		Limelog("Failed to parse RTSP response\n");
	}

Exit:
	if (serializedMessage != NULL) {
		free(serializedMessage);
	}

	closesocket(sock);
	sock = INVALID_SOCKET;
	return ret;
}

/* Terminate the RTSP Handshake process by closing the socket */
void terminateRtspHandshake(void) {
	if (sock != INVALID_SOCKET) {
		closesocket(sock);
		sock = INVALID_SOCKET;
	}
}

/* Send RTSP OPTIONS request */
static int requestOptions(PRTSP_MESSAGE response, int* error) {
	RTSP_MESSAGE request;
	int ret;
    
    *error = -1;

	ret = initializeRtspRequest(&request, "OPTIONS", rtspTargetUrl);
	if (ret != 0) {
		ret = transactRtspMessage(&request, response, error);
		freeMessage(&request);
	}

	return ret;
}

/* Send RTSP DESCRIBE request */
static int requestDescribe(PRTSP_MESSAGE response, int* error) {
	RTSP_MESSAGE request;
	int ret;
    
    *error = -1;

	ret = initializeRtspRequest(&request, "DESCRIBE", rtspTargetUrl);
	if (ret != 0) {
		if (addOption(&request, "Accept",
				"application/sdp") &&
			addOption(&request, "If-Modified-Since",
				"Thu, 01 Jan 1970 00:00:00 GMT")) {
			ret = transactRtspMessage(&request, response, error);
		}
		else {
			ret = 0;
		}
		freeMessage(&request);
	}

	return ret;
}

/* Send RTSP SETUP request */
static int setupStream(PRTSP_MESSAGE response, char* target, int* error) {
	RTSP_MESSAGE request;
	int ret;
    
    *error = -1;

	ret = initializeRtspRequest(&request, "SETUP", target);
	if (ret != 0) {
		if (hasSessionId) {
			if (!addOption(&request, "Session", sessionIdString)) {
				ret = 0;
				goto FreeMessage;
			}
		}

		if (addOption(&request, "Transport", " ") &&
			addOption(&request, "If-Modified-Since",
				"Thu, 01 Jan 1970 00:00:00 GMT")) {
			ret = transactRtspMessage(&request, response, error);
		}
		else {
			ret = 0;
		}

	FreeMessage:
		freeMessage(&request);
	}

	return ret;
}

/* Send RTSP PLAY request*/
static int playStream(PRTSP_MESSAGE response, char* target, int* error) {
	RTSP_MESSAGE request;
	int ret;
    
    *error = -1;

	ret = initializeRtspRequest(&request, "PLAY", target);
	if (ret != 0) {
		if (addOption(&request, "Session", sessionIdString)) {
			ret = transactRtspMessage(&request, response, error);
		}
		else {
			ret = 0;
		}
		freeMessage(&request);
	}

	return ret;
}

/* Send RTSP ANNOUNCE message */
static int sendVideoAnnounce(PRTSP_MESSAGE response, int* error) {
	RTSP_MESSAGE request;
	int ret;
	int payloadLength;
	char payloadLengthStr[16];
    
    *error = -1;

	ret = initializeRtspRequest(&request, "ANNOUNCE", "streamid=video");
	if (ret != 0) {
		ret = 0;

		if (!addOption(&request, "Session", sessionIdString) ||
			!addOption(&request, "Content-type", "application/sdp")) {
			goto FreeMessage;
		}

		request.payload = getSdpPayloadForStreamConfig(rtspClientVersion, &payloadLength);
		if (request.payload == NULL) {
			goto FreeMessage;
		}
		request.flags |= FLAG_ALLOCATED_PAYLOAD;
		request.payloadLength = payloadLength;

		sprintf(payloadLengthStr, "%d", payloadLength);
		if (!addOption(&request, "Content-length", payloadLengthStr)) {
			goto FreeMessage;
		}

		ret = transactRtspMessage(&request, response, error);

	FreeMessage:
		freeMessage(&request);
	}

	return ret;
}

/* Perform RTSP Handshake with the streaming server machine as part of the connection process */
int performRtspHandshake(void) {
    char urlAddr[URLSAFESTRING_LEN];
    
	// Initialize global state
    addrToUrlSafeString(&RemoteAddr, urlAddr);
	sprintf(rtspTargetUrl, "rtsp://%s", urlAddr);
	currentSeqNumber = 1;
	hasSessionId = 0;
    
    if (ServerMajorVersion == 3) {
        rtspClientVersion = 10;
    }
    else {
        rtspClientVersion = 11;
    }

	{
		RTSP_MESSAGE response;
        int error = -1;

		if (!requestOptions(&response, &error)) {
			Limelog("RTSP OPTIONS request failed: %d\n", error);
			return error;
		}

		if (response.message.response.statusCode != 200) {
			Limelog("RTSP OPTIONS request failed: %d\n",
				response.message.response.statusCode);
			return response.message.response.statusCode;
		}

		freeMessage(&response);
	}

	{
		RTSP_MESSAGE response;
        int error = -1;

		if (!requestDescribe(&response, &error)) {
			Limelog("RTSP DESCRIBE request failed: %d\n", error);
			return error;
		}

		if (response.message.response.statusCode != 200) {
			Limelog("RTSP DESCRIBE request failed: %d\n",
				response.message.response.statusCode);
			return response.message.response.statusCode;
		}

		freeMessage(&response);
	}

	{
		RTSP_MESSAGE response;
		char* sessionId;
        int error = -1;

		if (!setupStream(&response, "streamid=audio", &error)) {
			Limelog("RTSP SETUP streamid=audio request failed: %d\n", error);
			return error;
		}

		if (response.message.response.statusCode != 200) {
			Limelog("RTSP SETUP streamid=audio request failed: %d\n",
				response.message.response.statusCode);
			return response.message.response.statusCode;
		}

		sessionId = getOptionContent(response.options, "Session");
		if (sessionId == NULL) {
			Limelog("RTSP SETUP streamid=audio is missing session attribute");
			return -1;
		}

		strcpy(sessionIdString, sessionId);
		hasSessionId = 1;

		freeMessage(&response);
	}

	{
		RTSP_MESSAGE response;
        int error = -1;

		if (!setupStream(&response, "streamid=video", &error)) {
			Limelog("RTSP SETUP streamid=video request failed: %d\n", error);
			return error;
		}

		if (response.message.response.statusCode != 200) {
			Limelog("RTSP SETUP streamid=video request failed: %d\n",
				response.message.response.statusCode);
			return response.message.response.statusCode;
		}

		freeMessage(&response);
	}

	{
		RTSP_MESSAGE response;
        int error = -1;

		if (!sendVideoAnnounce(&response, &error)) {
			Limelog("RTSP ANNOUNCE request failed: %d\n", error);
			return error;
		}

		if (response.message.response.statusCode != 200) {
			Limelog("RTSP ANNOUNCE request failed: %d\n",
				response.message.response.statusCode);
			return response.message.response.statusCode;
		}

		freeMessage(&response);
	}

	{
		RTSP_MESSAGE response;
        int error = -1;

		if (!playStream(&response, "streamid=video", &error)) {
			Limelog("RTSP PLAY streamid=video request failed: %d\n", error);
			return error;
		}

		if (response.message.response.statusCode != 200) {
			Limelog("RTSP PLAY streamid=video failed: %d\n",
				response.message.response.statusCode);
			return response.message.response.statusCode;
		}

		freeMessage(&response);
	}

	{
		RTSP_MESSAGE response;
        int error = -1;

		if (!playStream(&response, "streamid=audio", &error)) {
			Limelog("RTSP PLAY streamid=audio request failed: %d\n", error);
			return error;
		}

		if (response.message.response.statusCode != 200) {
			Limelog("RTSP PLAY streamid=audio failed: %d\n",
				response.message.response.statusCode);
			return response.message.response.statusCode;
		}

		freeMessage(&response);
	}

	return 0;
}                                                                                                                                                                                                                                                           moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/RtspParser.c               0000664 0000000 0000000 00000025052 12563577644 0031045 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include "Rtsp.h"

/* Check if String s begins with the given prefix */
static int startsWith(const char *s, const char *prefix) {
	if (strncmp(s, prefix, strlen(prefix)) == 0){
		return 1;
	}
	else {
		return 0;
	}
}

/* Gets the length of the message */
static int getMessageLength(PRTSP_MESSAGE msg){
	POPTION_ITEM current;

	/* Initialize to 1 for null terminator */
	size_t count = 1;
	/* Add the length of the protocol */
	count += strlen(msg->protocol);

	/* Add length of request-specific strings */
	if (msg->type == TYPE_REQUEST){
		count += strlen(msg->message.request.command);
		count += strlen(msg->message.request.target);
		/* Add 4 for the two spaces and \r\n*/
		count += 4;
	}
	/* Add length of response-specific strings */
	else {
		char statusCodeStr[16];
		sprintf(statusCodeStr, "%d", msg->message.response.statusCode);
		count += strlen(statusCodeStr);
		count += strlen(msg->message.response.statusString);
		/* Add 4 for two spaces and \r\n */
		count += 4;
	}
	/* Count the size of the options */
	current = msg->options;
	while (current != NULL){
		count += strlen(current->option);
		count += strlen(current->content);
		/* Add 4 because of :[space] and \r\n */
		count += 4;
		current = current->next;
	}
	/* Add 2 more for extra /r/n ending */
	count += 2;

	/* Add the length of the payload, if any */
	count += msg->payloadLength;

	return (int)count;
}

/* Given an RTSP message string rtspMessage, parse it into an RTSP_MESSAGE struct msg */
int parseRtspMessage(PRTSP_MESSAGE msg, char *rtspMessage, int length) {
	char *token, *protocol, *endCheck, *target, *statusStr, *command, *sequence, flag;
	char messageEnded = 0, *payload = NULL, *opt = NULL;
	int statusCode = 0, sequenceNum, exitCode;
	POPTION_ITEM options = NULL;
	POPTION_ITEM newOpt;

	/* Delimeter sets for strtok() */
	char *delim = " \r\n";
	char *end = "\r\n";
	char *optDelim = " :\r\n";
	char typeFlag = TOKEN_OPTION;

	/* Put the raw message into a string we can use */
	char *messageBuffer = malloc(length + 1);
	if (messageBuffer == NULL) {
		exitCode = RTSP_ERROR_NO_MEMORY;
		goto ExitFailure;
	}
	memcpy(messageBuffer, rtspMessage, length);

	// The payload logic depends on a null-terminator at the end
	messageBuffer[length] = 0;

	/* Get the first token of the message*/
	token = strtok(messageBuffer, delim);
	if (token == NULL){
		exitCode = RTSP_ERROR_MALFORMED;
		goto ExitFailure;
	}

	/* The message is a response */
	if (startsWith(token, "RTSP")){
		flag = TYPE_RESPONSE;
		/* The current token is the protocol */
		protocol = token;

		/* Get the status code */
		token = strtok(NULL, delim);
		statusCode = atoi(token);
		if (token == NULL){
			exitCode = RTSP_ERROR_MALFORMED;
			goto ExitFailure;
		}

		/* Get the status string */
		statusStr = strtok(NULL, end);
		if (statusStr == NULL){
			exitCode = RTSP_ERROR_MALFORMED;
			goto ExitFailure;
		}

		/* Request fields - we don't care about them here */
		target = NULL;
		command = NULL;
	}
	/* The message is a request */
	else {
		flag = TYPE_REQUEST;
		/* The current token is the command */
		command = token;
		/* Get the target */
		target = strtok(NULL, delim);
		if (target == NULL){
			exitCode = RTSP_ERROR_MALFORMED;
			goto ExitFailure;
		}
		/* Get the protocol */
		protocol = strtok(NULL, delim);
		if (protocol == NULL){
			exitCode = RTSP_ERROR_MALFORMED;
			goto ExitFailure;
		}
		/* Response field - we don't care about it here */
		statusStr = NULL;
	}
	/* Check that the protocol is valid */
	if (strcmp(protocol, "RTSP/1.0")){
		exitCode = RTSP_ERROR_MALFORMED;
		goto ExitFailure;
	}
	/* Parse remaining options */
	while (token != NULL){
		token = strtok(NULL, typeFlag == TOKEN_OPTION ? optDelim : end);
		if (token != NULL){

			/* The token is an option */
			if (typeFlag == TOKEN_OPTION){
				opt = token;
			}
			/* The token is content */
			else {
				/* Create a new node containing the option and content */
				newOpt = (POPTION_ITEM)malloc(sizeof(OPTION_ITEM));
				if (newOpt == NULL){
					freeOptionList(options);
					exitCode = RTSP_ERROR_NO_MEMORY;
					goto ExitFailure;
				}
				newOpt->flags = 0;
				newOpt->option = opt;
				newOpt->content = token;
				newOpt->next = NULL;
				insertOption(&options, newOpt);

				/* Check if we're at the end of the message portion marked by \r\n\r\n
				* endCheck points to the remainder of messageBuffer after the token */
				endCheck = &token[0] + strlen(token) + 1;

				/* See if we've hit the end of the message. The first \r is missing because it's been tokenized */
				if (startsWith(endCheck, "\n\r\n")){

					/* We've encountered the end of the message - mark it thus */
					messageEnded = 1;

					/* The payload is the remainder of messageBuffer. If none, then payload = null */
					if (endCheck[3] != '\0')
						payload = &endCheck[3];

					break;
				}
			}
		}
		typeFlag ^= 1; // flip the flag
	}
	/* If we never encountered the double CRLF, then the message is malformed! */
	if (!messageEnded){
		exitCode = RTSP_ERROR_MALFORMED;
		goto ExitFailure;
	}

	/* Get sequence number as an integer */
	sequence = getOptionContent(options, "CSeq");
	if (sequence != NULL) {
		sequenceNum = atoi(sequence);
	}
	else {
		sequenceNum = SEQ_INVALID;
	}
	/* Package the new parsed message into the struct */
	if (flag == TYPE_REQUEST){
		createRtspRequest(msg, messageBuffer, FLAG_ALLOCATED_MESSAGE_BUFFER | FLAG_ALLOCATED_OPTION_ITEMS, command, target,
			protocol, sequenceNum, options, payload, payload ? length - (int)(messageBuffer - payload) : 0);
	}
	else {
		createRtspResponse(msg, messageBuffer, FLAG_ALLOCATED_MESSAGE_BUFFER | FLAG_ALLOCATED_OPTION_ITEMS, protocol, statusCode,
			statusStr, sequenceNum, options, payload, payload ? length - (int)(messageBuffer - payload) : 0);
	}
	return RTSP_ERROR_SUCCESS;

	/* Cleanup in failure condition */
ExitFailure:
	if (options) {
		free(options);
	}
	if (messageBuffer) {
		free(messageBuffer);
	}
	return exitCode;
}

/* Create new RTSP message struct with response data */
void createRtspResponse(PRTSP_MESSAGE msg, char *message, int flags, char *protocol,
	int statusCode, char *statusString, int sequenceNumber, POPTION_ITEM optionsHead, char *payload, int payloadLength) {
	msg->type = TYPE_RESPONSE;
	msg->flags = flags;
	msg->messageBuffer = message;
	msg->protocol = protocol;
	msg->options = optionsHead;
	msg->payload = payload;
	msg->payloadLength = payloadLength;
	msg->sequenceNumber = sequenceNumber;
	msg->message.response.statusString = statusString;
	msg->message.response.statusCode = statusCode;
}

/* Create new RTSP message struct with request data */
void createRtspRequest(PRTSP_MESSAGE msg, char *message, int flags,
	char *command, char *target, char *protocol, int sequenceNumber, POPTION_ITEM optionsHead, char *payload, int payloadLength) {
	msg->type = TYPE_REQUEST;
	msg->flags = flags;
	msg->protocol = protocol;
	msg->messageBuffer = message;
	msg->options = optionsHead;
	msg->payload = payload;
	msg->payloadLength = payloadLength;
	msg->sequenceNumber = sequenceNumber;
	msg->message.request.command = command;
	msg->message.request.target = target;
}

/* Retrieves option content from the linked list given the option title */
char *getOptionContent(POPTION_ITEM optionsHead, char *option){
	OPTION_ITEM *current = optionsHead;
	while (current != NULL){
		/* Check if current node is what we're looking for */
		if (!strcmp(current->option, option)){
			return current->content;
		}
		current = current->next;
	}
	/* Not found */
	return NULL;
}

/* Adds new option opt to the struct's option list */
void insertOption(POPTION_ITEM *optionsHead, POPTION_ITEM opt){
	OPTION_ITEM *current = *optionsHead;
	opt->next = NULL;

	/* Empty options list */
	if (*optionsHead == NULL){
		*optionsHead = opt;
		return;
	}
	/* Traverse the list and insert the new option at the end */
	while (current != NULL){
		/* Check for duplicate option; if so, replace the option currently there */
		if (!strcmp(current->option, opt->option)){
			current->content = opt->content;
			return;
		}
		if (current->next == NULL){
			current->next = opt;
			return;
		}
		current = current->next;
	}
}

/* Free every node in the message's option list */
void freeOptionList(POPTION_ITEM optionsHead){
	POPTION_ITEM current = optionsHead;
	POPTION_ITEM temp;
	while (current != NULL){
		temp = current;
		current = current->next;
		if (temp->flags & FLAG_ALLOCATED_OPTION_FIELDS){
			free(temp->option);
			free(temp->content);
		}
		free(temp);
	}
}

/* Serialize the message struct into a string containing the RTSP message */
char *serializeRtspMessage(PRTSP_MESSAGE msg, int *serializedLength){
	int size = getMessageLength(msg);
	char *serializedMessage;
	POPTION_ITEM current = msg->options;
	char statusCodeStr[16];

	serializedMessage = malloc(size);
	if (serializedMessage == NULL) {
		return NULL;
	}

	if (msg->type == TYPE_REQUEST){
		/* command [space] */
		strcpy(serializedMessage, msg->message.request.command);
		strcat(serializedMessage, " ");
		/* target [space] */
		strcat(serializedMessage, msg->message.request.target);
		strcat(serializedMessage, " ");
		/* protocol \r\n */
		strcat(serializedMessage, msg->protocol);
		strcat(serializedMessage, "\r\n");
	}
	else {
		/* protocol [space] */
		strcpy(serializedMessage, msg->protocol);
		strcat(serializedMessage, " ");
		/* status code [space] */
		sprintf(statusCodeStr, "%d", msg->message.response.statusCode);
		strcat(serializedMessage, statusCodeStr);
		strcat(serializedMessage, " ");
		/* status str\r\n */
		strcat(serializedMessage, msg->message.response.statusString);
		strcat(serializedMessage, "\r\n");
	}
	/* option content\r\n */
	while (current != NULL){
		strcat(serializedMessage, current->option);
		strcat(serializedMessage, ": ");
		strcat(serializedMessage, current->content);
		strcat(serializedMessage, "\r\n");
		current = current->next;
	}
	/* Final \r\n */
	strcat(serializedMessage, "\r\n");

	/* payload */
	if (msg->payload != NULL) {
		int offset;

		// Find end of the RTSP message header
		for (offset = 0; serializedMessage[offset] != 0; offset++);

		// Add the payload after
		memcpy(&serializedMessage[offset], msg->payload, msg->payloadLength);

		*serializedLength = offset + msg->payloadLength;
	}
	else {
		*serializedLength = (int)strlen(serializedMessage);
	}

	return serializedMessage;
}

/* Free everything in a msg struct */
void freeMessage(PRTSP_MESSAGE msg){
	/* If we've allocated the message buffer */
	if (msg->flags & FLAG_ALLOCATED_MESSAGE_BUFFER){
		free(msg->messageBuffer);
	}

	/* If we've allocated any option items */
	if (msg->flags & FLAG_ALLOCATED_OPTION_ITEMS){
		freeOptionList(msg->options);
	}

	/* If we've allocated the payload */
	if (msg->flags & FLAG_ALLOCATED_PAYLOAD) {
		free(msg->payload);
	}
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/SdpGenerator.c             0000664 0000000 0000000 00000023143 12563577644 0031334 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include "Limelight-internal.h"

#define MAX_OPTION_NAME_LEN 128

#define MAX_SDP_HEADER_LEN 128
#define MAX_SDP_TAIL_LEN 128

typedef struct _SDP_OPTION {
	char name[MAX_OPTION_NAME_LEN+1];
	void* payload;
	int payloadLen;
	struct _SDP_OPTION *next;
} SDP_OPTION, *PSDP_OPTION;

/* Cleanup the attribute list */
static void freeAttributeList(PSDP_OPTION head) {
	PSDP_OPTION next;
	while (head != NULL) {
		next = head->next;
		free(head);
		head = next;
	}
}

/* Get the size of the attribute list */
static int getSerializedAttributeListSize(PSDP_OPTION head) {
	PSDP_OPTION currentEntry = head;
	size_t size = 0;
	while (currentEntry != NULL) {
		size += strlen("a=");
		size += strlen(currentEntry->name);
		size += strlen(":");
		size += currentEntry->payloadLen;
		size += strlen(" \r\n");

		currentEntry = currentEntry->next;
	}
	return (int)size;
}

/* Populate the serialized attribute list into a string */
static int fillSerializedAttributeList(char* buffer, PSDP_OPTION head) {
	PSDP_OPTION currentEntry = head;
	int offset = 0;
	while (currentEntry != NULL) {
		offset += sprintf(&buffer[offset], "a=%s:", currentEntry->name);
		memcpy(&buffer[offset], currentEntry->payload, currentEntry->payloadLen);
		offset += currentEntry->payloadLen;
		offset += sprintf(&buffer[offset], " \r\n");

		currentEntry = currentEntry->next;
	}
	return offset;
}

/* Add an attribute */
static int addAttributeBinary(PSDP_OPTION *head, char* name, const void* payload, int payloadLen) {
	PSDP_OPTION option, currentOption;

	option = malloc(sizeof(*option) + payloadLen);
	if (option == NULL) {
		return -1;
	}

	option->next = NULL;
	option->payloadLen = payloadLen;
	strcpy(option->name, name);
	option->payload = (void*)(option + 1);
	memcpy(option->payload, payload, payloadLen);

	if (*head == NULL) {
		*head = option;
	}
	else {
		currentOption = *head;
		while (currentOption->next != NULL) {
			currentOption = currentOption->next;
		}
		currentOption->next = option;
	}

	return 0;
}

/* Add an attribute string */
static int addAttributeString(PSDP_OPTION *head, char* name, const char* payload) {
	// We purposefully omit the null terminating character
	return addAttributeBinary(head, name, payload, (int)strlen(payload));
}

static int addGen3Options(PSDP_OPTION *head, char* addrStr) {
    int payloadInt;
    int err = 0;
    
    err |= addAttributeString(head, "x-nv-general.serverAddress", addrStr);
    
    payloadInt = htonl(0x42774141);
    err |= addAttributeBinary(head,
                              "x-nv-general.featureFlags", &payloadInt, sizeof(payloadInt));

    
    payloadInt = htonl(0x41514141);
    err |= addAttributeBinary(head,
                              "x-nv-video[0].transferProtocol", &payloadInt, sizeof(payloadInt));
    err |= addAttributeBinary(head,
                              "x-nv-video[1].transferProtocol", &payloadInt, sizeof(payloadInt));
    err |= addAttributeBinary(head,
                              "x-nv-video[2].transferProtocol", &payloadInt, sizeof(payloadInt));
    err |= addAttributeBinary(head,
                              "x-nv-video[3].transferProtocol", &payloadInt, sizeof(payloadInt));
    
    payloadInt = htonl(0x42414141);
    err |= addAttributeBinary(head,
                              "x-nv-video[0].rateControlMode", &payloadInt, sizeof(payloadInt));
    payloadInt = htonl(0x42514141);
    err |= addAttributeBinary(head,
                              "x-nv-video[1].rateControlMode", &payloadInt, sizeof(payloadInt));
    err |= addAttributeBinary(head,
                              "x-nv-video[2].rateControlMode", &payloadInt, sizeof(payloadInt));
    err |= addAttributeBinary(head,
                              "x-nv-video[3].rateControlMode", &payloadInt, sizeof(payloadInt));
    
    err |= addAttributeString(head, "x-nv-vqos[0].bw.flags", "14083");
    
    err |= addAttributeString(head, "x-nv-vqos[0].videoQosMaxConsecutiveDrops", "0");
    err |= addAttributeString(head, "x-nv-vqos[1].videoQosMaxConsecutiveDrops", "0");
    err |= addAttributeString(head, "x-nv-vqos[2].videoQosMaxConsecutiveDrops", "0");
    err |= addAttributeString(head, "x-nv-vqos[3].videoQosMaxConsecutiveDrops", "0");
    
    return err;
}

static int addGen4Options(PSDP_OPTION *head, char* addrStr) {
    char payloadStr[92];
    int err = 0;
    
    sprintf(payloadStr, "rtsp://%s:48010", addrStr);
    err |= addAttributeString(head, "x-nv-general.serverAddress", payloadStr);
    
    err |= addAttributeString(head, "x-nv-video[0].rateControlMode", "4");
    
    // Use slicing for increased performance on some decoders
    err |= addAttributeString(head, "x-nv-video[0].videoEncoderSlicesPerFrame", "4");
    
    return err;
}

static PSDP_OPTION getAttributesList(char *urlSafeAddr) {
	PSDP_OPTION optionHead;
	char payloadStr[92];
	int err;

	optionHead = NULL;
	err = 0;

	sprintf(payloadStr, "%d", StreamConfig.width);
	err |= addAttributeString(&optionHead, "x-nv-video[0].clientViewportWd", payloadStr);
	sprintf(payloadStr, "%d", StreamConfig.height);
	err |= addAttributeString(&optionHead, "x-nv-video[0].clientViewportHt", payloadStr);

	sprintf(payloadStr, "%d", StreamConfig.fps);
	err |= addAttributeString(&optionHead, "x-nv-video[0].maxFPS", payloadStr);
    
    sprintf(payloadStr, "%d", StreamConfig.packetSize);
    err |= addAttributeString(&optionHead, "x-nv-video[0].packetSize", payloadStr);

	err |= addAttributeString(&optionHead, "x-nv-video[0].rateControlMode", "4");
    
	if (StreamConfig.remote) {
		err |= addAttributeString(&optionHead, "x-nv-video[0].averageBitrate", "4");
        	err |= addAttributeString(&optionHead, "x-nv-video[0].peakBitrate", "4");
    	}

	err |= addAttributeString(&optionHead, "x-nv-video[0].timeoutLengthMs", "7000");
	err |= addAttributeString(&optionHead, "x-nv-video[0].framesWithInvalidRefThreshold", "0");
    
    // Lock the bitrate since we're not scaling resolution so the picture doesn't get too bad
    if (StreamConfig.height >= 1080 && StreamConfig.fps >= 60) {
        if (StreamConfig.bitrate < 10000) {
            sprintf(payloadStr, "%d", StreamConfig.bitrate);
            err |= addAttributeString(&optionHead, "x-nv-vqos[0].bw.minimumBitrate", payloadStr);
        }
        else {
            err |= addAttributeString(&optionHead, "x-nv-vqos[0].bw.minimumBitrate", "10000");
        }
    }
    else if (StreamConfig.height >= 1080 || StreamConfig.fps >= 60) {
        if (StreamConfig.bitrate < 7000) {
            sprintf(payloadStr, "%d", StreamConfig.bitrate);
            err |= addAttributeString(&optionHead, "x-nv-vqos[0].bw.minimumBitrate", payloadStr);
        }
        else {
            err |= addAttributeString(&optionHead, "x-nv-vqos[0].bw.minimumBitrate", "7000");
        }
    }
    else {
        if (StreamConfig.bitrate < 3000) {
            sprintf(payloadStr, "%d", StreamConfig.bitrate);
            err |= addAttributeString(&optionHead, "x-nv-vqos[0].bw.minimumBitrate", payloadStr);
        }
        else {
            err |= addAttributeString(&optionHead, "x-nv-vqos[0].bw.minimumBitrate", "3000");
        }
    }

	sprintf(payloadStr, "%d", StreamConfig.bitrate);
	err |= addAttributeString(&optionHead, "x-nv-vqos[0].bw.maximumBitrate", payloadStr);

    // Using FEC turns padding on which makes us have to take the slow path
    // in the depacketizer, not to mention exposing some ambiguous cases with
    // distinguishing padding from valid sequences. Since we can only perform
    // execute an FEC recovery on a 1 packet frame, we'll just turn it off completely.
    err |= addAttributeString(&optionHead, "x-nv-vqos[0].fec.enable", "0");

	err |= addAttributeString(&optionHead, "x-nv-vqos[0].videoQualityScoreUpdateTime", "5000");
    
    if (StreamConfig.remote) {
        err |= addAttributeString(&optionHead, "x-nv-vqos[0].qosTrafficType", "0");
        err |= addAttributeString(&optionHead, "x-nv-aqos.qosTrafficType", "0");
    } else {
        err |= addAttributeString(&optionHead, "x-nv-vqos[0].qosTrafficType", "5");
        err |= addAttributeString(&optionHead, "x-nv-aqos.qosTrafficType", "4");
    }
    
    if (ServerMajorVersion == 3) {
        err |= addGen3Options(&optionHead, urlSafeAddr);
    }
    else {
        err |= addGen4Options(&optionHead, urlSafeAddr);
    }

	if (err == 0) {
		return optionHead;
	}

	freeAttributeList(optionHead);
	return NULL;
}

/* Populate the SDP header with required information */
static int fillSdpHeader(char* buffer, int rtspClientVersion, char *urlSafeAddr) {
	return sprintf(buffer,
		"v=0\r\n"
		"o=android 0 %d IN %s %s\r\n"
		"s=NVIDIA Streaming Client\r\n",
                   rtspClientVersion,
                   RemoteAddr.ss_family == AF_INET ? "IPv4" : "IPv6",
                   urlSafeAddr);
}

/* Populate the SDP tail with required information */
static int fillSdpTail(char* buffer) {
	return sprintf(buffer,
		"t=0 0\r\n"
		"m=video %d  \r\n",
                   ServerMajorVersion < 4 ? 47996 : 47998);
}

/* Get the SDP attributes for the stream config */
char* getSdpPayloadForStreamConfig(int rtspClientVersion, int *length) {
	PSDP_OPTION attributeList;
	int offset;
	char* payload;
    char urlSafeAddr[URLSAFESTRING_LEN];
    
    addrToUrlSafeString(&RemoteAddr, urlSafeAddr);

	attributeList = getAttributesList(urlSafeAddr);
	if (attributeList == NULL) {
		return NULL;
	}

	payload = malloc(MAX_SDP_HEADER_LEN + MAX_SDP_TAIL_LEN +
		getSerializedAttributeListSize(attributeList));
	if (payload == NULL) {
		freeAttributeList(attributeList);
		return NULL;
	}

	offset = fillSdpHeader(payload, rtspClientVersion, urlSafeAddr);
	offset += fillSerializedAttributeList(&payload[offset], attributeList);
	offset += fillSdpTail(&payload[offset]);

	freeAttributeList(attributeList);
	*length = offset;
	return payload;
}                                                                                                                                                                                                                                                                                                                                                                                                                             moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/Video.h                    0000664 0000000 0000000 00000001456 12563577644 0030015 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #pragma once

#include "LinkedBlockingQueue.h"

typedef struct _QUEUED_DECODE_UNIT {
	DECODE_UNIT decodeUnit;
	LINKED_BLOCKING_QUEUE_ENTRY entry;
} QUEUED_DECODE_UNIT, *PQUEUED_DECODE_UNIT;

void freeQueuedDecodeUnit(PQUEUED_DECODE_UNIT qdu);
int getNextQueuedDecodeUnit(PQUEUED_DECODE_UNIT *qdu);

#pragma pack(push, 1)

#define FLAG_CONTAINS_PIC_DATA 0x1
#define FLAG_EOF 0x2
#define FLAG_SOF 0x4

typedef struct _NV_VIDEO_PACKET {
	int streamPacketIndex;
	int frameIndex;
	char flags;
	char reserved[3];
	int reserved2;
} NV_VIDEO_PACKET, *PNV_VIDEO_PACKET;

#define FLAG_EXTENSION 0x10

#define FIXED_RTP_HEADER_SIZE 12
#define MAX_RTP_HEADER_SIZE 16

typedef struct _RTP_PACKET {
	char header;
	char packetType;
	unsigned short sequenceNumber;
	char reserved[8];
} RTP_PACKET, *PRTP_PACKET;

#pragma pack(pop)                                                                                                                                                                                                                  moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/VideoDepacketizer.c        0000664 0000000 0000000 00000031613 12563577644 0032341 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include "Platform.h"
#include "Limelight-internal.h"
#include "LinkedBlockingQueue.h"
#include "Video.h"

static PLENTRY nalChainHead;
static int nalChainDataLength;

static int nextFrameNumber;
static int nextPacketNumber;
static int startFrameNumber;
static int waitingForNextSuccessfulFrame;
static int waitingForIdrFrame;
static int gotNextFrameStart;
static int lastPacketInStream;
static int decodingFrame;
static int strictIdrFrameWait;

#define CONSECUTIVE_DROP_LIMIT 120
static int consecutiveFrameDrops;

static LINKED_BLOCKING_QUEUE decodeUnitQueue;
static unsigned int nominalPacketDataLength;

typedef struct _BUFFER_DESC {
	char* data;
	unsigned int offset;
	unsigned int length;
} BUFFER_DESC, *PBUFFER_DESC;

/* Init */
void initializeVideoDepacketizer(int pktSize) {
	if ((VideoCallbacks.capabilities & CAPABILITY_DIRECT_SUBMIT) == 0) {
		LbqInitializeLinkedBlockingQueue(&decodeUnitQueue, 15);
	}
	nominalPacketDataLength = pktSize - sizeof(NV_VIDEO_PACKET);

	nextFrameNumber = 1;
	nextPacketNumber = 0;
	startFrameNumber = 0;
	waitingForNextSuccessfulFrame = 0;
	waitingForIdrFrame = 1;
	gotNextFrameStart = 0;
	lastPacketInStream = -1;
	decodingFrame = 0;
    strictIdrFrameWait = !(VideoCallbacks.capabilities & CAPABILITY_REFERENCE_FRAME_INVALIDATION);
}

/* Free malloced memory in AvcFrameState*/
static void cleanupAvcFrameState(void) {
	PLENTRY lastEntry;

	while (nalChainHead != NULL) {
		lastEntry = nalChainHead;
		nalChainHead = lastEntry->next;
		free(lastEntry);
	}

	nalChainDataLength = 0;
}

/* Cleanup AVC frame state and set that we're waiting for an IDR Frame*/
static void dropAvcFrameState(void) {
    // We'll need an IDR frame now if we're in strict mode
    if (strictIdrFrameWait) {
        waitingForIdrFrame = 1;
    }

    // Count the number of consecutive frames dropped
    consecutiveFrameDrops++;
    
    // If we reach our limit, immediately request an IDR frame and reset
    if (consecutiveFrameDrops == CONSECUTIVE_DROP_LIMIT) {
        Limelog("Reached consecutive drop limit\n");
        
        // Restart the count
        consecutiveFrameDrops = 0;
        
        // Request an IDR frame
        waitingForIdrFrame = 1;
        requestIdrOnDemand();
    }
    
	cleanupAvcFrameState();
}

/* Cleanup the list of decode units */
static void freeDecodeUnitList(PLINKED_BLOCKING_QUEUE_ENTRY entry) {
	PLINKED_BLOCKING_QUEUE_ENTRY nextEntry;

	while (entry != NULL) {
		nextEntry = entry->flink;

		freeQueuedDecodeUnit((PQUEUED_DECODE_UNIT) entry->data);

		entry = nextEntry;
	}
}

/* Cleanup video depacketizer and free malloced memory */
void destroyVideoDepacketizer(void) {
	if ((VideoCallbacks.capabilities & CAPABILITY_DIRECT_SUBMIT) == 0) {
		freeDecodeUnitList(LbqDestroyLinkedBlockingQueue(&decodeUnitQueue));
	}

	cleanupAvcFrameState();
}

/* Returns 1 if candidate is a frame start and 0 otherwise */
static int isSeqFrameStart(PBUFFER_DESC candidate) {
	return (candidate->length == 4 && candidate->data[candidate->offset + candidate->length - 1] == 1);
}

/* Returns 1 if candidate an AVC start and 0 otherwise */
static int isSeqAvcStart(PBUFFER_DESC candidate) {
	return (candidate->data[candidate->offset + candidate->length - 1] == 1);
}

/* Returns 1 if candidate is padding and 0 otherwise */
static int isSeqPadding(PBUFFER_DESC candidate) {
	return (candidate->data[candidate->offset + candidate->length - 1] == 0);
}

/* Returns 1 on success, 0 otherwise */
static int getSpecialSeq(PBUFFER_DESC current, PBUFFER_DESC candidate) {
	if (current->length < 3) {
		return 0;
	}

	if (current->data[current->offset] == 0 &&
		current->data[current->offset + 1] == 0) {
		// Padding or frame start
		if (current->data[current->offset + 2] == 0) {
			if (current->length >= 4 && current->data[current->offset + 3] == 1) {
				// Frame start
				candidate->data = current->data;
				candidate->offset = current->offset;
				candidate->length = 4;
				return 1;
			}
			else {
				// Padding
				candidate->data = current->data;
				candidate->offset = current->offset;
				candidate->length = 3;
				return 1;
			}
		}
		else if (current->data[current->offset + 2] == 1) {
			// NAL start
			candidate->data = current->data;
			candidate->offset = current->offset;
			candidate->length = 3;
			return 1;
		}
	}

	return 0;
}

/* Get the first decode unit available */
int getNextQueuedDecodeUnit(PQUEUED_DECODE_UNIT *qdu) {
	int err = LbqWaitForQueueElement(&decodeUnitQueue, (void**) qdu);
	if (err == LBQ_SUCCESS) {
		return 1;
	}
	else {
		return 0;
	}
}

/* Cleanup a decode unit by freeing the buffer chain and the holder */
void freeQueuedDecodeUnit(PQUEUED_DECODE_UNIT qdu) {
	PLENTRY lastEntry;

	while (qdu->decodeUnit.bufferList != NULL) {
		lastEntry = qdu->decodeUnit.bufferList;
		qdu->decodeUnit.bufferList = lastEntry->next;
		free(lastEntry);
	}

	free(qdu);
}

/* Reassemble the frame with the given frame number */
static void reassembleAvcFrame(int frameNumber) {
	if (nalChainHead != NULL) {
		PQUEUED_DECODE_UNIT qdu = (PQUEUED_DECODE_UNIT) malloc(sizeof(*qdu));
		if (qdu != NULL) {
			qdu->decodeUnit.bufferList = nalChainHead;
			qdu->decodeUnit.fullLength = nalChainDataLength;

			nalChainHead = NULL;
			nalChainDataLength = 0;

			if ((VideoCallbacks.capabilities & CAPABILITY_DIRECT_SUBMIT) == 0) {
				if (LbqOfferQueueItem(&decodeUnitQueue, qdu, &qdu->entry) == LBQ_BOUND_EXCEEDED) {
					Limelog("Video decode unit queue overflow\n");

					// Clear frame state and wait for an IDR
					nalChainHead = qdu->decodeUnit.bufferList;
					nalChainDataLength = qdu->decodeUnit.fullLength;
					dropAvcFrameState();

					// Free the DU
					free(qdu);

					// Flush the decode unit queue
					freeDecodeUnitList(LbqFlushQueueItems(&decodeUnitQueue));

					// FIXME: Get proper lower bound
					connectionSinkTooSlow(0, frameNumber);
					return;
				}
			} else {
				int ret = VideoCallbacks.submitDecodeUnit(&qdu->decodeUnit);

				freeQueuedDecodeUnit(qdu);

				if (ret == DR_NEED_IDR) {
					Limelog("Request IDR frame on behalf of DR\n");
					requestIdrOnDemand();
				}
			}

			// Notify the control connection
			connectionReceivedFrame(frameNumber);
            
            // Clear frame drops
            consecutiveFrameDrops = 0;
		}
	}
}

static void queueFragment(char *data, int offset, int length) {
	PLENTRY entry = (PLENTRY) malloc(sizeof(*entry) + length);
	if (entry != NULL) {
		entry->next = NULL;
		entry->length = length;
		entry->data = (char*) (entry + 1);

		memcpy(entry->data, &data[offset], entry->length);

		nalChainDataLength += entry->length;

		if (nalChainHead == NULL) {
			nalChainHead = entry;
		}
		else {
			PLENTRY currentEntry = nalChainHead;

			while (currentEntry->next != NULL) {
				currentEntry = currentEntry->next;
			}

			currentEntry->next = entry;
		}
	}
}

/* Process an RTP Payload */
static void processRtpPayloadSlow(PNV_VIDEO_PACKET videoPacket, PBUFFER_DESC currentPos) {
	BUFFER_DESC specialSeq;
	int decodingAvc = 0;

	while (currentPos->length != 0) {
		int start = currentPos->offset;

		if (getSpecialSeq(currentPos, &specialSeq)) {
			if (isSeqAvcStart(&specialSeq)) {
				// Now we're decoding AVC
				decodingAvc = 1;

				if (isSeqFrameStart(&specialSeq)) {
					// Now we're working on a frame
					decodingFrame = 1;

					// Reassemble any pending frame
					reassembleAvcFrame(videoPacket->frameIndex);

					if (specialSeq.data[specialSeq.offset + specialSeq.length] == 0x65) {
						// This is the NALU code for I-frame data
						waitingForIdrFrame = 0;
					}
				}

				// Skip the start sequence
				currentPos->length -= specialSeq.length;
				currentPos->offset += specialSeq.length;
			}
			else {
				// Check if this is padding after a full AVC frame
				if (decodingAvc && isSeqPadding(currentPos)) {
					reassembleAvcFrame(videoPacket->frameIndex);
				}

				// Not decoding AVC
				decodingAvc = 0;

				// Just skip this byte
				currentPos->length--;
				currentPos->offset++;
			}
		}

		// Move to the next special sequence
		while (currentPos->length != 0) {
			// Check if this should end the current NAL
			if (getSpecialSeq(currentPos, &specialSeq)) {
				if (decodingAvc || !isSeqPadding(&specialSeq)) {
					break;
				}
			}

			// This byte is part of the NAL data
			currentPos->offset++;
			currentPos->length--;
		}

		if (decodingAvc) {
			queueFragment(currentPos->data, start, currentPos->offset - start);
		}
	}
}

/* Return 1 if packet is the first one in the frame */
static int isFirstPacket(char flags) {
	// Clear the picture data flag
	flags &= ~FLAG_CONTAINS_PIC_DATA;
	
	// Check if it's just the start or both start and end of a frame
	return (flags == (FLAG_SOF | FLAG_EOF) ||
		flags == FLAG_SOF);
}

/* Adds a fragment directly to the queue */
static void processRtpPayloadFast(BUFFER_DESC location) {
	queueFragment(location.data, location.offset, location.length);
}

/* Process an RTP Payload */
void processRtpPayload(PNV_VIDEO_PACKET videoPacket, int length) {
	BUFFER_DESC currentPos, specialSeq;
	int frameIndex;
	char flags;
	int firstPacket;
	int streamPacketIndex;

	// Mask the top 8 bits from the SPI
	videoPacket->streamPacketIndex >>= 8;
	videoPacket->streamPacketIndex &= 0xFFFFFF;
	
	currentPos.data = (char*) (videoPacket + 1);
	currentPos.offset = 0;
	currentPos.length = length - sizeof(*videoPacket);

	frameIndex = videoPacket->frameIndex;
	flags = videoPacket->flags;
	firstPacket = isFirstPacket(flags);

	// Drop duplicates or re-ordered packets
	streamPacketIndex = videoPacket->streamPacketIndex;
	if (isBeforeSignedInt((short) streamPacketIndex, (short) (lastPacketInStream + 1), 0)) {
		return;
	}

	// Drop packets from a previously completed frame
	if (isBeforeSignedInt(frameIndex, nextFrameNumber, 0)) {
		return;
	}

	// Look for a frame start before receiving a frame end
	if (firstPacket && decodingFrame)
	{
		Limelog("Network dropped end of a frame\n");
		nextFrameNumber = frameIndex;

		// Unexpected start of next frame before terminating the last
		waitingForNextSuccessfulFrame = 1;
		dropAvcFrameState();
	}
	// Look for a non-frame start before a frame start
	else if (!firstPacket && !decodingFrame) {
		// Check if this looks like a real frame
		if (flags == FLAG_CONTAINS_PIC_DATA ||
			flags == FLAG_EOF ||
			currentPos.length < nominalPacketDataLength)
		{
			Limelog("Network dropped beginning of a frame\n");
			nextFrameNumber = frameIndex + 1;

			waitingForNextSuccessfulFrame = 1;

			dropAvcFrameState();
			decodingFrame = 0;
			return;
		}
		else {
			// FEC data
			return;
		}
	}
	// Check sequencing of this frame to ensure we didn't
	// miss one in between
	else if (firstPacket) {
		// Make sure this is the next consecutive frame
		if (isBeforeSignedInt(nextFrameNumber, frameIndex, 1)) {
			Limelog("Network dropped an entire frame\n");
			nextFrameNumber = frameIndex;

			// Wait until next complete frame
			waitingForNextSuccessfulFrame = 1;
			dropAvcFrameState();
		}
		else if (nextFrameNumber != frameIndex) {
			// Duplicate packet or FEC dup
			decodingFrame = 0;
			return;
		}

		// We're now decoding a frame
		decodingFrame = 1;
	}

	// If it's not the first packet of a frame
	// we need to drop it if the stream packet index
	// doesn't match
	if (!firstPacket && decodingFrame) {
		if (streamPacketIndex != (int) (lastPacketInStream + 1)) {
			Limelog("Network dropped middle of a frame\n");
			nextFrameNumber = frameIndex + 1;

			waitingForNextSuccessfulFrame = 1;

			dropAvcFrameState();
			decodingFrame = 0;

			return;
		}
	}

	// Notify the server of any packet losses
	if (streamPacketIndex != (int) (lastPacketInStream + 1)) {
		// Packets were lost so report this to the server
		connectionLostPackets(lastPacketInStream, streamPacketIndex);
	}
	lastPacketInStream = streamPacketIndex;

	if (firstPacket &&
		getSpecialSeq(&currentPos, &specialSeq) &&
		isSeqFrameStart(&specialSeq) &&
		specialSeq.data[specialSeq.offset + specialSeq.length] == 0x67)
	{
		// SPS and PPS prefix is padded between NALs, so we must decode it with the slow path
		processRtpPayloadSlow(videoPacket, &currentPos);
	}
	else
	{
		processRtpPayloadFast(currentPos);
	}

	if (flags & FLAG_EOF) {
		// Move on to the next frame
		decodingFrame = 0;
		nextFrameNumber = frameIndex + 1;

		// If waiting for next successful frame and we got here
		// with an end flag, we can send a message to the server
		if (waitingForNextSuccessfulFrame) {
			// This is the next successful frame after a loss event
			connectionDetectedFrameLoss(startFrameNumber, nextFrameNumber - 1);
			waitingForNextSuccessfulFrame = 0;
		}

		// If we need an IDR frame first, then drop this frame
		if (waitingForIdrFrame) {
			Limelog("Waiting for IDR frame\n");

			dropAvcFrameState();
			return;
		}

		reassembleAvcFrame(frameIndex);

		startFrameNumber = nextFrameNumber;
	}
}

/* Add an RTP Packet to the queue */
void queueRtpPacket(PRTP_PACKET rtpPacket, int length) {
	int dataOffset;

	dataOffset = sizeof(*rtpPacket);
	if (rtpPacket->header & FLAG_EXTENSION) {
		dataOffset += 4; // 2 additional fields
	}

	processRtpPayload((PNV_VIDEO_PACKET)(((char*)rtpPacket) + dataOffset), length - dataOffset);
}
                                                                                                                     moonlight-embedded-2.1.1/third_party/moonlight-common-c/limelight-common/VideoStream.c              0000664 0000000 0000000 00000014504 12563577644 0031162 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include "Limelight-internal.h"
#include "PlatformSockets.h"
#include "PlatformThreads.h"
#include "LinkedBlockingQueue.h"
#include "RtpReorderQueue.h"

#define FIRST_FRAME_MAX 1500

#define RTP_PORT 47998
#define FIRST_FRAME_PORT 47996

#define RTP_RECV_BUFFER (64 * 1024)

static RTP_REORDER_QUEUE rtpQueue;

static SOCKET rtpSocket = INVALID_SOCKET;
static SOCKET firstFrameSocket = INVALID_SOCKET;

static PLT_THREAD udpPingThread;
static PLT_THREAD receiveThread;
static PLT_THREAD decoderThread;

// We can't request an IDR frame until the depacketizer knows
// that a packet was lost. This timeout bounds the time that
// the RTP queue will wait for missing/reordered packets.
#define RTP_QUEUE_DELAY 10

/* Initialize the video stream */
void initializeVideoStream(void) {
	initializeVideoDepacketizer(StreamConfig.packetSize);
	RtpqInitializeQueue(&rtpQueue, RTPQ_DEFAULT_MAX_SIZE, RTP_QUEUE_DELAY);
}

/* Clean up the video stream */
void destroyVideoStream(void) {
	destroyVideoDepacketizer();
	RtpqCleanupQueue(&rtpQueue);
}

/* UDP Ping proc */
static void UdpPingThreadProc(void *context) {
	char pingData [] = { 0x50, 0x49, 0x4E, 0x47 };
	struct sockaddr_in6 saddr;
	SOCK_RET err;

	memcpy(&saddr, &RemoteAddr, sizeof(saddr));
	saddr.sin6_port = htons(RTP_PORT);

	while (!PltIsThreadInterrupted(&udpPingThread)) {
		err = sendto(rtpSocket, pingData, sizeof(pingData), 0, (struct sockaddr*)&saddr, RemoteAddrLen);
		if (err != sizeof(pingData)) {
			Limelog("Video Ping: send() failed: %d\n", (int)LastSocketError());
			ListenerCallbacks.connectionTerminated(LastSocketError());
			return;
		}

		PltSleepMs(500);
	}
}

/* Receive thread proc */
static void ReceiveThreadProc(void* context) {
	int err;
	int bufferSize, receiveSize;
	char* buffer;
	int queueStatus;

	receiveSize = StreamConfig.packetSize + MAX_RTP_HEADER_SIZE;
	bufferSize = receiveSize + sizeof(int) + sizeof(RTP_QUEUE_ENTRY);
	buffer = NULL;

	while (!PltIsThreadInterrupted(&receiveThread)) {
        PRTP_PACKET packet;
        
		if (buffer == NULL) {
			buffer = (char*) malloc(bufferSize);
			if (buffer == NULL) {
				Limelog("Video Receive: malloc() failed\n");
				ListenerCallbacks.connectionTerminated(-1);
				return;
			}
		}

		err = (int) recv(rtpSocket, buffer, receiveSize, 0);
		if (err <= 0) {
			Limelog("Video Receive: recv() failed: %d\n", (int)LastSocketError());
			ListenerCallbacks.connectionTerminated(LastSocketError());
			break;
		}

		memcpy(&buffer[receiveSize], &err, sizeof(int));
        
        // RTP sequence number must be in host order for the RTP queue
        packet = (PRTP_PACKET) &buffer[0];
        packet->sequenceNumber = htons(packet->sequenceNumber);

		queueStatus = RtpqAddPacket(&rtpQueue, packet, (PRTP_QUEUE_ENTRY) &buffer[receiveSize + sizeof(int)]);
		if (queueStatus == RTPQ_RET_HANDLE_IMMEDIATELY) {
			// queueRtpPacket() copies the data it needs to we can reuse the buffer
			queueRtpPacket(packet, err);
		}
		else if (queueStatus == RTPQ_RET_QUEUED_PACKETS_READY) {
			// The packet queue now has packets ready
			while ((buffer = (char*) RtpqGetQueuedPacket(&rtpQueue)) != NULL) {
				memcpy(&err, &buffer[receiveSize], sizeof(int));
				queueRtpPacket((PRTP_PACKET) buffer, err);
				free(buffer);
			}
		}
        else if (queueStatus == RTPQ_RET_QUEUED_NOTHING_READY) {
            // The queue owns the buffer
            buffer = NULL;
        }
	}

	if (buffer != NULL) {
		free(buffer);
	}
}

/* Decoder thread proc */
static void DecoderThreadProc(void* context) {
	PQUEUED_DECODE_UNIT qdu;
	while (!PltIsThreadInterrupted(&decoderThread)) {
		if (!getNextQueuedDecodeUnit(&qdu)) {
			return;
		}

		int ret = VideoCallbacks.submitDecodeUnit(&qdu->decodeUnit);

		freeQueuedDecodeUnit(qdu);
        
        if (ret == DR_NEED_IDR) {
            Limelog("Requesting IDR frame on behalf of DR\n");
            requestIdrOnDemand();
        }
	}
}

/* Read the first frame of the video stream */
int readFirstFrame(void) {
    // All that matters is that we close this socket.
    // This starts the flow of video on Gen 3 servers.
    
    closesocket(firstFrameSocket);
    firstFrameSocket = INVALID_SOCKET;
    
	return 0;
}

/* Terminate the video stream */
void stopVideoStream(void) {
	PltInterruptThread(&udpPingThread);
	PltInterruptThread(&receiveThread);
	if ((VideoCallbacks.capabilities & CAPABILITY_DIRECT_SUBMIT) == 0) {
		PltInterruptThread(&decoderThread);
	}

	if (firstFrameSocket != INVALID_SOCKET) {
		closesocket(firstFrameSocket);
		firstFrameSocket = INVALID_SOCKET;
	}
	if (rtpSocket != INVALID_SOCKET) {
		closesocket(rtpSocket);
		rtpSocket = INVALID_SOCKET;
	}

	PltJoinThread(&udpPingThread);
	PltJoinThread(&receiveThread);
	if ((VideoCallbacks.capabilities & CAPABILITY_DIRECT_SUBMIT) == 0) {
		PltJoinThread(&decoderThread);
	}

	PltCloseThread(&udpPingThread);
	PltCloseThread(&receiveThread);
	if ((VideoCallbacks.capabilities & CAPABILITY_DIRECT_SUBMIT) == 0) {
		PltCloseThread(&decoderThread);
	}

    VideoCallbacks.cleanup();
}

/* Start the video stream */
int startVideoStream(void* rendererContext, int drFlags) {
	int err;

    // This must be called before the decoder thread starts submitting
    // decode units
	VideoCallbacks.setup(StreamConfig.width,
		StreamConfig.height, StreamConfig.fps, rendererContext, drFlags);
    
	rtpSocket = bindUdpSocket(RemoteAddr.ss_family, RTP_RECV_BUFFER);
	if (rtpSocket == INVALID_SOCKET) {
		return LastSocketError();
	}

	err = PltCreateThread(ReceiveThreadProc, NULL, &receiveThread);
	if (err != 0) {
		return err;
	}

	if ((VideoCallbacks.capabilities & CAPABILITY_DIRECT_SUBMIT) == 0) {
		err = PltCreateThread(DecoderThreadProc, NULL, &decoderThread);
		if (err != 0) {
			return err;
		}
	}
    
    if (ServerMajorVersion == 3) {
        // Connect this socket to open port 47998 for our ping thread
        firstFrameSocket = connectTcpSocket(&RemoteAddr, RemoteAddrLen, FIRST_FRAME_PORT);
        if (firstFrameSocket == INVALID_SOCKET) {
            return LastSocketError();
        }
    }
    
    // Start pinging before reading the first frame so GFE knows where
    // to send UDP data
    err = PltCreateThread(UdpPingThreadProc, NULL, &udpPingThread);
    if (err != 0) {
        return err;
    }
    
    if (ServerMajorVersion == 3) {
        // Read the first frame to start the flow of video
        err = readFirstFrame();
        if (err != 0) {
            return err;
        }
    }

	return 0;
}
                                                                                                                                                                                            moonlight-embedded-2.1.1/third_party/moonlight-common-c/moonlight-common.xcodeproj/                 0000775 0000000 0000000 00000000000 12563577644 0030606 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        moonlight-embedded-2.1.1/third_party/moonlight-common-c/moonlight-common.xcodeproj/project.pbxproj  0000664 0000000 0000000 00000053741 12563577644 0033674 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 46;
	objects = {

/* Begin PBXBuildFile section */
		988814E81B044E570081B9A8 /* FakeCallbacks.c in Sources */ = {isa = PBXBuildFile; fileRef = 988814E71B044E570081B9A8 /* FakeCallbacks.c */; };
		98E197771B1752B200F421E2 /* Platform.c in Sources */ = {isa = PBXBuildFile; fileRef = 98E197761B1752B200F421E2 /* Platform.c */; };
		98E1977A1B1752C300F421E2 /* RtpReorderQueue.c in Sources */ = {isa = PBXBuildFile; fileRef = 98E197781B1752C300F421E2 /* RtpReorderQueue.c */; };
		98E1977B1B1752C300F421E2 /* RtpReorderQueue.h in Headers */ = {isa = PBXBuildFile; fileRef = 98E197791B1752C300F421E2 /* RtpReorderQueue.h */; };
		98E1977D1B1752EA00F421E2 /* Misc.c in Sources */ = {isa = PBXBuildFile; fileRef = 98E1977C1B1752EA00F421E2 /* Misc.c */; };
		FB290E5A19B37A8B004C83CF /* AudioStream.c in Sources */ = {isa = PBXBuildFile; fileRef = FB290E3619B37A8B004C83CF /* AudioStream.c */; };
		FB290E5B19B37A8B004C83CF /* ByteBuffer.c in Sources */ = {isa = PBXBuildFile; fileRef = FB290E3719B37A8B004C83CF /* ByteBuffer.c */; };
		FB290E5C19B37A8B004C83CF /* ByteBuffer.h in Headers */ = {isa = PBXBuildFile; fileRef = FB290E3819B37A8B004C83CF /* ByteBuffer.h */; };
		FB290E5D19B37A8B004C83CF /* Connection.c in Sources */ = {isa = PBXBuildFile; fileRef = FB290E3919B37A8B004C83CF /* Connection.c */; };
		FB290E5E19B37A8B004C83CF /* ControlStream.c in Sources */ = {isa = PBXBuildFile; fileRef = FB290E3A19B37A8B004C83CF /* ControlStream.c */; };
		FB290E5F19B37A8B004C83CF /* Input.h in Headers */ = {isa = PBXBuildFile; fileRef = FB290E3B19B37A8B004C83CF /* Input.h */; };
		FB290E6019B37A8B004C83CF /* InputStream.c in Sources */ = {isa = PBXBuildFile; fileRef = FB290E3C19B37A8B004C83CF /* InputStream.c */; };
		FB290E6119B37A8B004C83CF /* Limelight-internal.h in Headers */ = {isa = PBXBuildFile; fileRef = FB290E3F19B37A8B004C83CF /* Limelight-internal.h */; };
		FB290E6219B37A8B004C83CF /* Limelight.h in Headers */ = {isa = PBXBuildFile; fileRef = FB290E4019B37A8B004C83CF /* Limelight.h */; };
		FB290E6319B37A8B004C83CF /* LinkedBlockingQueue.c in Sources */ = {isa = PBXBuildFile; fileRef = FB290E4119B37A8B004C83CF /* LinkedBlockingQueue.c */; };
		FB290E6419B37A8B004C83CF /* LinkedBlockingQueue.h in Headers */ = {isa = PBXBuildFile; fileRef = FB290E4219B37A8B004C83CF /* LinkedBlockingQueue.h */; };
		FB290E6519B37A8B004C83CF /* oaes_base64.c in Sources */ = {isa = PBXBuildFile; fileRef = FB290E4519B37A8B004C83CF /* oaes_base64.c */; };
		FB290E6619B37A8B004C83CF /* oaes_base64.h in Headers */ = {isa = PBXBuildFile; fileRef = FB290E4619B37A8B004C83CF /* oaes_base64.h */; };
		FB290E6719B37A8B004C83CF /* oaes_common.h in Headers */ = {isa = PBXBuildFile; fileRef = FB290E4719B37A8B004C83CF /* oaes_common.h */; };
		FB290E6819B37A8B004C83CF /* oaes_config.h in Headers */ = {isa = PBXBuildFile; fileRef = FB290E4819B37A8B004C83CF /* oaes_config.h */; };
		FB290E6919B37A8B004C83CF /* oaes_lib.c in Sources */ = {isa = PBXBuildFile; fileRef = FB290E4919B37A8B004C83CF /* oaes_lib.c */; };
		FB290E6A19B37A8B004C83CF /* oaes_lib.h in Headers */ = {isa = PBXBuildFile; fileRef = FB290E4A19B37A8B004C83CF /* oaes_lib.h */; };
		FB290E6B19B37A8B004C83CF /* Platform.h in Headers */ = {isa = PBXBuildFile; fileRef = FB290E4D19B37A8B004C83CF /* Platform.h */; };
		FB290E6C19B37A8B004C83CF /* PlatformSockets.c in Sources */ = {isa = PBXBuildFile; fileRef = FB290E4E19B37A8B004C83CF /* PlatformSockets.c */; };
		FB290E6D19B37A8B004C83CF /* PlatformSockets.h in Headers */ = {isa = PBXBuildFile; fileRef = FB290E4F19B37A8B004C83CF /* PlatformSockets.h */; };
		FB290E6F19B37A8B004C83CF /* PlatformThreads.h in Headers */ = {isa = PBXBuildFile; fileRef = FB290E5119B37A8B004C83CF /* PlatformThreads.h */; };
		FB290E7019B37A8B004C83CF /* Rtsp.h in Headers */ = {isa = PBXBuildFile; fileRef = FB290E5219B37A8B004C83CF /* Rtsp.h */; };
		FB290E7119B37A8B004C83CF /* RtspConnection.c in Sources */ = {isa = PBXBuildFile; fileRef = FB290E5319B37A8B004C83CF /* RtspConnection.c */; };
		FB290E7219B37A8B004C83CF /* RtspParser.c in Sources */ = {isa = PBXBuildFile; fileRef = FB290E5419B37A8B004C83CF /* RtspParser.c */; };
		FB290E7319B37A8B004C83CF /* SdpGenerator.c in Sources */ = {isa = PBXBuildFile; fileRef = FB290E5519B37A8B004C83CF /* SdpGenerator.c */; };
		FB290E7419B37A8B004C83CF /* Video.h in Headers */ = {isa = PBXBuildFile; fileRef = FB290E5619B37A8B004C83CF /* Video.h */; };
		FB290E7519B37A8B004C83CF /* VideoDepacketizer.c in Sources */ = {isa = PBXBuildFile; fileRef = FB290E5719B37A8B004C83CF /* VideoDepacketizer.c */; };
		FB290E7619B37A8B004C83CF /* VideoStream.c in Sources */ = {isa = PBXBuildFile; fileRef = FB290E5819B37A8B004C83CF /* VideoStream.c */; };
/* End PBXBuildFile section */

/* Begin PBXFileReference section */
		988814E71B044E570081B9A8 /* FakeCallbacks.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = FakeCallbacks.c; sourceTree = "<group>"; };
		98E197761B1752B200F421E2 /* Platform.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = Platform.c; sourceTree = "<group>"; };
		98E197781B1752C300F421E2 /* RtpReorderQueue.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = RtpReorderQueue.c; sourceTree = "<group>"; };
		98E197791B1752C300F421E2 /* RtpReorderQueue.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = RtpReorderQueue.h; sourceTree = "<group>"; };
		98E1977C1B1752EA00F421E2 /* Misc.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = Misc.c; path = "limelight-common/Misc.c"; sourceTree = SOURCE_ROOT; };
		FB290E2E19B37A4E004C83CF /* libmoonlight-common.a */ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; path = "libmoonlight-common.a"; sourceTree = BUILT_PRODUCTS_DIR; };
		FB290E3619B37A8B004C83CF /* AudioStream.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = AudioStream.c; sourceTree = "<group>"; };
		FB290E3719B37A8B004C83CF /* ByteBuffer.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ByteBuffer.c; sourceTree = "<group>"; };
		FB290E3819B37A8B004C83CF /* ByteBuffer.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ByteBuffer.h; sourceTree = "<group>"; };
		FB290E3919B37A8B004C83CF /* Connection.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = Connection.c; sourceTree = "<group>"; };
		FB290E3A19B37A8B004C83CF /* ControlStream.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ControlStream.c; sourceTree = "<group>"; };
		FB290E3B19B37A8B004C83CF /* Input.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Input.h; sourceTree = "<group>"; };
		FB290E3C19B37A8B004C83CF /* InputStream.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = InputStream.c; sourceTree = "<group>"; };
		FB290E3F19B37A8B004C83CF /* Limelight-internal.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "Limelight-internal.h"; sourceTree = "<group>"; };
		FB290E4019B37A8B004C83CF /* Limelight.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Limelight.h; sourceTree = "<group>"; };
		FB290E4119B37A8B004C83CF /* LinkedBlockingQueue.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = LinkedBlockingQueue.c; sourceTree = "<group>"; };
		FB290E4219B37A8B004C83CF /* LinkedBlockingQueue.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = LinkedBlockingQueue.h; sourceTree = "<group>"; };
		FB290E4419B37A8B004C83CF /* LICENSE */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = LICENSE; sourceTree = "<group>"; };
		FB290E4519B37A8B004C83CF /* oaes_base64.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = oaes_base64.c; sourceTree = "<group>"; };
		FB290E4619B37A8B004C83CF /* oaes_base64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = oaes_base64.h; sourceTree = "<group>"; };
		FB290E4719B37A8B004C83CF /* oaes_common.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = oaes_common.h; sourceTree = "<group>"; };
		FB290E4819B37A8B004C83CF /* oaes_config.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = oaes_config.h; sourceTree = "<group>"; };
		FB290E4919B37A8B004C83CF /* oaes_lib.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = oaes_lib.c; sourceTree = "<group>"; };
		FB290E4A19B37A8B004C83CF /* oaes_lib.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = oaes_lib.h; sourceTree = "<group>"; };
		FB290E4B19B37A8B004C83CF /* README */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = README; sourceTree = "<group>"; };
		FB290E4C19B37A8B004C83CF /* VERSION */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = VERSION; sourceTree = "<group>"; };
		FB290E4D19B37A8B004C83CF /* Platform.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Platform.h; sourceTree = "<group>"; };
		FB290E4E19B37A8B004C83CF /* PlatformSockets.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = PlatformSockets.c; sourceTree = "<group>"; };
		FB290E4F19B37A8B004C83CF /* PlatformSockets.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PlatformSockets.h; sourceTree = "<group>"; };
		FB290E5119B37A8B004C83CF /* PlatformThreads.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PlatformThreads.h; sourceTree = "<group>"; };
		FB290E5219B37A8B004C83CF /* Rtsp.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Rtsp.h; sourceTree = "<group>"; };
		FB290E5319B37A8B004C83CF /* RtspConnection.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = RtspConnection.c; sourceTree = "<group>"; };
		FB290E5419B37A8B004C83CF /* RtspParser.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = RtspParser.c; sourceTree = "<group>"; };
		FB290E5519B37A8B004C83CF /* SdpGenerator.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = SdpGenerator.c; sourceTree = "<group>"; };
		FB290E5619B37A8B004C83CF /* Video.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Video.h; sourceTree = "<group>"; };
		FB290E5719B37A8B004C83CF /* VideoDepacketizer.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = VideoDepacketizer.c; sourceTree = "<group>"; };
		FB290E5819B37A8B004C83CF /* VideoStream.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = VideoStream.c; sourceTree = "<group>"; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		FB290E2B19B37A4E004C83CF /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		FB290E2519B37A4E004C83CF = {
			isa = PBXGroup;
			children = (
				FB290E3519B37A8B004C83CF /* limelight-common */,
				FB290E2F19B37A4E004C83CF /* Products */,
			);
			sourceTree = "<group>";
		};
		FB290E2F19B37A4E004C83CF /* Products */ = {
			isa = PBXGroup;
			children = (
				FB290E2E19B37A4E004C83CF /* libmoonlight-common.a */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		FB290E3519B37A8B004C83CF /* limelight-common */ = {
			isa = PBXGroup;
			children = (
				FB290E3619B37A8B004C83CF /* AudioStream.c */,
				FB290E3719B37A8B004C83CF /* ByteBuffer.c */,
				FB290E3819B37A8B004C83CF /* ByteBuffer.h */,
				FB290E3919B37A8B004C83CF /* Connection.c */,
				FB290E3A19B37A8B004C83CF /* ControlStream.c */,
				988814E71B044E570081B9A8 /* FakeCallbacks.c */,
				FB290E3B19B37A8B004C83CF /* Input.h */,
				FB290E3C19B37A8B004C83CF /* InputStream.c */,
				FB290E3F19B37A8B004C83CF /* Limelight-internal.h */,
				FB290E4019B37A8B004C83CF /* Limelight.h */,
				FB290E4119B37A8B004C83CF /* LinkedBlockingQueue.c */,
				FB290E4219B37A8B004C83CF /* LinkedBlockingQueue.h */,
				98E1977C1B1752EA00F421E2 /* Misc.c */,
				FB290E4319B37A8B004C83CF /* OpenAES */,
				FB290E4D19B37A8B004C83CF /* Platform.h */,
				FB290E4E19B37A8B004C83CF /* PlatformSockets.c */,
				98E197761B1752B200F421E2 /* Platform.c */,
				FB290E4F19B37A8B004C83CF /* PlatformSockets.h */,
				FB290E5119B37A8B004C83CF /* PlatformThreads.h */,
				98E197781B1752C300F421E2 /* RtpReorderQueue.c */,
				98E197791B1752C300F421E2 /* RtpReorderQueue.h */,
				FB290E5219B37A8B004C83CF /* Rtsp.h */,
				FB290E5319B37A8B004C83CF /* RtspConnection.c */,
				FB290E5419B37A8B004C83CF /* RtspParser.c */,
				FB290E5519B37A8B004C83CF /* SdpGenerator.c */,
				FB290E5619B37A8B004C83CF /* Video.h */,
				FB290E5719B37A8B004C83CF /* VideoDepacketizer.c */,
				FB290E5819B37A8B004C83CF /* VideoStream.c */,
			);
			path = "limelight-common";
			sourceTree = "<group>";
		};
		FB290E4319B37A8B004C83CF /* OpenAES */ = {
			isa = PBXGroup;
			children = (
				FB290E4419B37A8B004C83CF /* LICENSE */,
				FB290E4519B37A8B004C83CF /* oaes_base64.c */,
				FB290E4619B37A8B004C83CF /* oaes_base64.h */,
				FB290E4719B37A8B004C83CF /* oaes_common.h */,
				FB290E4819B37A8B004C83CF /* oaes_config.h */,
				FB290E4919B37A8B004C83CF /* oaes_lib.c */,
				FB290E4A19B37A8B004C83CF /* oaes_lib.h */,
				FB290E4B19B37A8B004C83CF /* README */,
				FB290E4C19B37A8B004C83CF /* VERSION */,
			);
			path = OpenAES;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXHeadersBuildPhase section */
		FB290E2C19B37A4E004C83CF /* Headers */ = {
			isa = PBXHeadersBuildPhase;
			buildActionMask = 2147483647;
			files = (
				FB290E6219B37A8B004C83CF /* Limelight.h in Headers */,
				FB290E7019B37A8B004C83CF /* Rtsp.h in Headers */,
				FB290E6819B37A8B004C83CF /* oaes_config.h in Headers */,
				FB290E6619B37A8B004C83CF /* oaes_base64.h in Headers */,
				FB290E6F19B37A8B004C83CF /* PlatformThreads.h in Headers */,
				98E1977B1B1752C300F421E2 /* RtpReorderQueue.h in Headers */,
				FB290E5C19B37A8B004C83CF /* ByteBuffer.h in Headers */,
				FB290E6719B37A8B004C83CF /* oaes_common.h in Headers */,
				FB290E5F19B37A8B004C83CF /* Input.h in Headers */,
				FB290E6A19B37A8B004C83CF /* oaes_lib.h in Headers */,
				FB290E6119B37A8B004C83CF /* Limelight-internal.h in Headers */,
				FB290E6419B37A8B004C83CF /* LinkedBlockingQueue.h in Headers */,
				FB290E6B19B37A8B004C83CF /* Platform.h in Headers */,
				FB290E7419B37A8B004C83CF /* Video.h in Headers */,
				FB290E6D19B37A8B004C83CF /* PlatformSockets.h in Headers */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXHeadersBuildPhase section */

/* Begin PBXNativeTarget section */
		FB290E2D19B37A4E004C83CF /* moonlight-common */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = FB290E3219B37A4E004C83CF /* Build configuration list for PBXNativeTarget "moonlight-common" */;
			buildPhases = (
				FB290E2A19B37A4E004C83CF /* Sources */,
				FB290E2B19B37A4E004C83CF /* Frameworks */,
				FB290E2C19B37A4E004C83CF /* Headers */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = "moonlight-common";
			productName = "limelight-common";
			productReference = FB290E2E19B37A4E004C83CF /* libmoonlight-common.a */;
			productType = "com.apple.product-type.library.static";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		FB290E2619B37A4E004C83CF /* Project object */ = {
			isa = PBXProject;
			attributes = {
				LastUpgradeCheck = 0700;
				ORGANIZATIONNAME = "Limelight Stream";
			};
			buildConfigurationList = FB290E2919B37A4E004C83CF /* Build configuration list for PBXProject "moonlight-common" */;
			compatibilityVersion = "Xcode 3.2";
			developmentRegion = English;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
			);
			mainGroup = FB290E2519B37A4E004C83CF;
			productRefGroup = FB290E2F19B37A4E004C83CF /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				FB290E2D19B37A4E004C83CF /* moonlight-common */,
			);
		};
/* End PBXProject section */

/* Begin PBXSourcesBuildPhase section */
		FB290E2A19B37A4E004C83CF /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				98E197771B1752B200F421E2 /* Platform.c in Sources */,
				98E1977D1B1752EA00F421E2 /* Misc.c in Sources */,
				FB290E5D19B37A8B004C83CF /* Connection.c in Sources */,
				FB290E6919B37A8B004C83CF /* oaes_lib.c in Sources */,
				FB290E7219B37A8B004C83CF /* RtspParser.c in Sources */,
				98E1977A1B1752C300F421E2 /* RtpReorderQueue.c in Sources */,
				FB290E6C19B37A8B004C83CF /* PlatformSockets.c in Sources */,
				FB290E6519B37A8B004C83CF /* oaes_base64.c in Sources */,
				FB290E6319B37A8B004C83CF /* LinkedBlockingQueue.c in Sources */,
				988814E81B044E570081B9A8 /* FakeCallbacks.c in Sources */,
				FB290E7619B37A8B004C83CF /* VideoStream.c in Sources */,
				FB290E5E19B37A8B004C83CF /* ControlStream.c in Sources */,
				FB290E7519B37A8B004C83CF /* VideoDepacketizer.c in Sources */,
				FB290E7119B37A8B004C83CF /* RtspConnection.c in Sources */,
				FB290E7319B37A8B004C83CF /* SdpGenerator.c in Sources */,
				FB290E6019B37A8B004C83CF /* InputStream.c in Sources */,
				FB290E5A19B37A8B004C83CF /* AudioStream.c in Sources */,
				FB290E5B19B37A8B004C83CF /* ByteBuffer.c in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin XCBuildConfiguration section */
		FB290E3019B37A4E004C83CF /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				CODE_SIGN_IDENTITY = "Mac Developer";
				COPY_PHASE_STRIP = NO;
				ENABLE_TESTABILITY = YES;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_ENABLE_OBJC_EXCEPTIONS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					LC_DEBUG,
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_SYMBOLS_PRIVATE_EXTERN = NO;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				MACOSX_DEPLOYMENT_TARGET = 10.10;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = macosx;
				SKIP_INSTALL = YES;
			};
			name = Debug;
		};
		FB290E3119B37A4E004C83CF /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				CODE_SIGN_IDENTITY = "3rd Party Mac Developer Application";
				COPY_PHASE_STRIP = YES;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_ENABLE_OBJC_EXCEPTIONS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				MACOSX_DEPLOYMENT_TARGET = 10.10;
				PROVISIONING_PROFILE = "";
				SDKROOT = macosx;
				SKIP_INSTALL = YES;
			};
			name = Release;
		};
		FB290E3319B37A4E004C83CF /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_IDENTITY = "iPhone Developer";
				EXECUTABLE_PREFIX = lib;
				IPHONEOS_DEPLOYMENT_TARGET = 8.0;
				ONLY_ACTIVE_ARCH = NO;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SDKROOT = iphoneos;
				SUPPORTED_PLATFORMS = "iphonesimulator iphoneos";
			};
			name = Debug;
		};
		FB290E3419B37A4E004C83CF /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_IDENTITY = "iPhone Distribution";
				EXECUTABLE_PREFIX = lib;
				IPHONEOS_DEPLOYMENT_TARGET = 8.0;
				ONLY_ACTIVE_ARCH = NO;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SDKROOT = iphoneos;
				SUPPORTED_PLATFORMS = "iphonesimulator iphoneos";
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		FB290E2919B37A4E004C83CF /* Build configuration list for PBXProject "moonlight-common" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				FB290E3019B37A4E004C83CF /* Debug */,
				FB290E3119B37A4E004C83CF /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		FB290E3219B37A4E004C83CF /* Build configuration list for PBXNativeTarget "moonlight-common" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				FB290E3319B37A4E004C83CF /* Debug */,
				FB290E3419B37A4E004C83CF /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */
	};
	rootObject = FB290E2619B37A4E004C83CF /* Project object */;
}
                               project.xcworkspace/                                                                                0000775 0000000 0000000 00000000000 12563577644 0034525 5                                                                                                    ustar 00root                            root                            0000000 0000000 moonlight-embedded-2.1.1/third_party/moonlight-common-c/moonlight-common.xcodeproj                                                                                     contents.xcworkspacedata                                                                            0000664 0000000 0000000 00000000241 12563577644 0041464 0                                                                                                    ustar 00root                            root                            0000000 0000000 moonlight-embedded-2.1.1/third_party/moonlight-common-c/moonlight-common.xcodeproj/project.xcworkspace                                                                 <?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "self:limelight-common.xcodeproj">
   </FileRef>
</Workspace>
                                                                                                                                                                                                                                                                                                                                                               xcshareddata/                                                                                       0000775 0000000 0000000 00000000000 12563577644 0037160 5                                                                                                    ustar 00root                            root                            0000000 0000000 moonlight-embedded-2.1.1/third_party/moonlight-common-c/moonlight-common.xcodeproj/project.xcworkspace                                                                 limelight-common.xccheckout                                                                         0000664 0000000 0000000 00000003007 12563577644 0044506 0                                                                                                    ustar 00root                            root                            0000000 0000000 moonlight-embedded-2.1.1/third_party/moonlight-common-c/moonlight-common.xcodeproj/project.xcworkspace/xcshareddata                                                    <?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDESourceControlProjectFavoriteDictionaryKey</key>
	<false/>
	<key>IDESourceControlProjectIdentifier</key>
	<string>662F3EBE-A540-4F33-A434-3BBB22ECCB12</string>
	<key>IDESourceControlProjectName</key>
	<string>limelight-common</string>
	<key>IDESourceControlProjectOriginsDictionary</key>
	<dict>
		<key>151E8452-E928-4FE9-BF31-5F5C490B9DD4</key>
		<string>ssh://github.com/limelight-stream/limelight-common-c.git</string>
	</dict>
	<key>IDESourceControlProjectPath</key>
	<string>limelight-common.xcodeproj/project.xcworkspace</string>
	<key>IDESourceControlProjectRelativeInstallPathDictionary</key>
	<dict>
		<key>151E8452-E928-4FE9-BF31-5F5C490B9DD4</key>
		<string>../..</string>
	</dict>
	<key>IDESourceControlProjectURL</key>
	<string>ssh://github.com/limelight-stream/limelight-common-c.git</string>
	<key>IDESourceControlProjectVersion</key>
	<integer>110</integer>
	<key>IDESourceControlProjectWCCIdentifier</key>
	<string>151E8452-E928-4FE9-BF31-5F5C490B9DD4</string>
	<key>IDESourceControlProjectWCConfigurations</key>
	<array>
		<dict>
			<key>IDESourceControlRepositoryExtensionIdentifierKey</key>
			<string>public.vcs.git</string>
			<key>IDESourceControlWCCIdentifierKey</key>
			<string>151E8452-E928-4FE9-BF31-5F5C490B9DD4</string>
			<key>IDESourceControlWCCName</key>
			<string>limelight-common-c</string>
		</dict>
	</array>
</dict>
</plist>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
